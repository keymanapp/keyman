//Autogenerated file - do not modify!
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var environment;
        (function (environment) {
            environment.VERSION = "15.0";
            environment.BUILD = 86;
            environment.ENVIRONMENT = "local";
            environment.SENTRY_RELEASE = "release-15.0.86-alpha-local";
        })(environment = keyman.environment || (keyman.environment = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            /**
             * Function     deepCopy
             * Scope        Private
             * @param       {Object}      p           object to copy
             * @param       {Array=}      c0          array member being copied
             * @return      {Object}                  clone ('deep copy') of object
             * Description  Makes an actual copy (not a reference) of an object, copying simple members,
             *              arrays and member objects but not functions, so use with care!
             */
            function deepCopy(p, c0) {
                var c = c0 || {};
                for (var i in p) {
                    if (typeof p[i] === 'object' && p[i] != null) {
                        c[i] = (p[i].constructor === Array) ? [] : {};
                        deepCopy(p[i], c[i]);
                    }
                    else {
                        c[i] = p[i];
                    }
                }
                return c;
            }
            utils.deepCopy = deepCopy;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            /**
             * Returns the base global object available to the current JS platform.
             * - In browsers, returns `window`.
             * - In WebWorkers, returns `self`.
             * - In Node, returns `global`.
             */
            function getGlobalObject() {
                // Evergreen browsers have started defining 'globalThis'.  
                // Refer to https://devblogs.microsoft.com/typescript/announcing-typescript-3-4/#type-checking-for-globalthis
                // and its referenced polyfill.  Said polyfill is very complex, so we opt for this far leaner variant.
                if (typeof globalThis != 'undefined') {
                    return globalThis; // Not available in IE or older Edge versions
                    // @ts-ignore (TS will throw errors for whatever platform we're not compiling for.)
                }
                else if (typeof window != 'undefined') {
                    // @ts-ignore
                    return window; // The browser-based classic
                    // @ts-ignore
                }
                else if (typeof self != 'undefined') {
                    // @ts-ignore
                    return self; // WebWorker global
                }
                else {
                    // Assumption - if neither of the above exist, we're in Node, for unit-testing.
                    // Node doesn't have as many methods and properties as the other two, but what 
                    // matters for us is that it's the base global.
                    //
                    // Some other headless JS solutions use 'this' instead, but Node's enough for our needs.
                    // @ts-ignore
                    return global;
                }
            }
            utils.getGlobalObject = getGlobalObject;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Ensure that this class contains no reference into core KMW code - it is referenced
// by components intended to be modular and possible to separate from core KMW.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            // Dotted-decimal version
            var Version = /** @class */ (function () {
                /**
                 * Parses version information, preparing it for use in comparisons.
                 * @param text Either a string representing a version number (ex: "9.0.0") or an array representing
                 *             its components (ex: [9, 0, 0]).
                 */
                function Version(text) {
                    // If a keyboard doesn't specify a version, use the DEVELOPER_VERSION_FALLBACK values.
                    if (text === undefined || text === null) {
                        this.components = [].concat(Version.DEVELOPER_VERSION_FALLBACK.components);
                        return;
                    }
                    if (Array.isArray(text)) {
                        var components = text;
                        if (components.length < 2) {
                            throw new Error("Version string must have at least a major and minor component!");
                        }
                        else {
                            this.components = [].concat(components);
                            return;
                        }
                    }
                    // else, standard constructor path.
                    var parts = text.split('.');
                    var componentArray = [];
                    if (parts.length < 2) {
                        throw new Error("Version string must have at least a major and minor component!");
                    }
                    for (var i = 0; i < parts.length; i++) {
                        var value = parseInt(parts[i], 10);
                        if (isNaN(value)) {
                            throw new Error("Version string components must be numerical!");
                        }
                        componentArray.push(value);
                    }
                    this.components = componentArray;
                }
                Object.defineProperty(Version.prototype, "major", {
                    get: function () {
                        return this.components[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Version.prototype, "minor", {
                    get: function () {
                        return this.components[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                Version.prototype.toString = function () {
                    return this.components.join('.');
                };
                Version.prototype.toJSON = function () {
                    return this.toString();
                };
                Version.prototype.equals = function (other) {
                    return this.compareTo(other) == 0;
                };
                Version.prototype.precedes = function (other) {
                    return this.compareTo(other) < 0;
                };
                Version.prototype.compareTo = function (other) {
                    // If the version info depth differs, we need a flag to indicate which instance is shorter.
                    var isShorter = this.components.length < other.components.length;
                    var maxDepth = (this.components.length < other.components.length) ? this.components.length : other.components.length;
                    var i;
                    for (i = 0; i < maxDepth; i++) {
                        var delta = this.components[i] - other.components[i];
                        if (delta != 0) {
                            return delta;
                        }
                    }
                    var longList = isShorter ? other.components : this.components;
                    do {
                        if (longList[i] > 0) {
                            return isShorter ? -1 : 1;
                        }
                        i++;
                    } while (i < longList.length);
                    // Equal.
                    return 0;
                };
                Version.CURRENT = new Version(com.keyman.environment.VERSION);
                // Represents a default version value for keyboards compiled before this was compiled into keyboards.
                // The exact version is unknown at this point, but the value is "good enough" for what we need.
                Version.DEVELOPER_VERSION_FALLBACK = new Version([9, 0, 0]);
                // For 12.0, the old default behavior of adding missing keycaps to the default layers was removed,
                // as it results in unexpected, bug-like behavior for keyboard designers when it is unwanted.
                Version.NO_DEFAULT_KEYCAPS = new Version([12, 0]);
                Version.MAC_POSSIBLE_IPAD_ALIAS = new Version([10, 15]);
                return Version;
            }());
            utils.Version = Version;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 14.0
   Copyright 2020 SIL International
***/
/**
 * Constructs a string from one or more Unicode character codepoint values
 * passed as integer parameters.
 *
 * @param  {number} cp0,...   1 or more Unicode codepoints, e.g. 0x0065, 0x10000
 * @return {string|null}      The new String object.
 */
String.kmwFromCharCode = function (cp0) {
    var chars = [], i;
    for (i = 0; i < arguments.length; i++) {
        var c = Number(arguments[i]);
        if (!isFinite(c) || c < 0 || c > 0x10FFFF || Math.floor(c) !== c) {
            throw new RangeError("Invalid code point " + c);
        }
        if (c < 0x10000) {
            chars.push(c);
        }
        else {
            c -= 0x10000;
            chars.push((c >> 10) + 0xD800);
            chars.push((c % 0x400) + 0xDC00);
        }
    }
    return String.fromCharCode.apply(undefined, chars);
};
/**
 * Returns a number indicating the Unicode value of the character at the given
 * code point index, with support for supplementary plane characters.
 *
 * @param  {number}  codePointIndex  The code point index into the string (not
                                     the code unit index) to return
 * @return {number}                  The Unicode character value
 */
String.prototype.kmwCharCodeAt = function (codePointIndex) {
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0 || codePointIndex >= str.length) {
        return NaN;
    }
    for (var i = 0; i < codePointIndex; i++) {
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        if (codeUnitIndex === null)
            return NaN;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;
        }
    }
    return first;
};
/**
 * Returns the code point index within the calling String object of the first occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  [fromIndex]    Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.indexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the code point index within the calling String object of the last occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  fromIndex      Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwLastIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.lastIndexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the length of the string in code points, as opposed to code units.
 *
 * @return {number}                 The length of the string in code points
 */
String.prototype.kmwLength = function () {
    var str = String(this);
    if (str.length == 0)
        return 0;
    for (var i = 0, codeUnitIndex = 0; codeUnitIndex !== null; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return i;
};
/**
 * Extracts a section of a string and returns a new string.
 *
 * @param  {number}  beginSlice    The start code point index in the string to
 *                                 extract from
 * @param  {number}  endSlice      Optional end code point index in the string
 *                                 to extract to
 * @return {string}                The substring as selected by beginSlice and
 *                                 endSlice
 */
String.prototype.kmwSlice = function (beginSlice, endSlice) {
    var str = String(this);
    var beginSliceCodeUnit = str.kmwCodePointToCodeUnit(beginSlice);
    var endSliceCodeUnit = str.kmwCodePointToCodeUnit(endSlice);
    if (beginSliceCodeUnit === null || endSliceCodeUnit === null)
        return '';
    else
        return str.slice(beginSliceCodeUnit, endSliceCodeUnit);
};
/**
 * Returns the characters in a string beginning at the specified location through
 * the specified number of characters.
 *
 * @param  {number}  start         The start code point index in the string to
 *                                 extract from
 * @param  {number=}  length        Optional length to extract
 * @return {string}                The substring as selected by start and length
 */
String.prototype.kmwSubstr = function (start, length) {
    var str = String(this);
    if (start < 0) {
        start = str.kmwLength() + start;
    }
    if (start < 0)
        start = 0;
    var startCodeUnit = str.kmwCodePointToCodeUnit(start);
    var endCodeUnit = startCodeUnit;
    if (startCodeUnit === null)
        return '';
    if (arguments.length < 2) {
        endCodeUnit = str.length;
    }
    else {
        for (var i = 0; i < length; i++)
            endCodeUnit = str.kmwNextChar(endCodeUnit);
    }
    if (endCodeUnit === null)
        return str.substring(startCodeUnit);
    else
        return str.substring(startCodeUnit, endCodeUnit);
};
/**
 * Returns the characters in a string between two indexes into the string.
 *
 * @param  {number}  indexA        The start code point index in the string to
 *                                 extract from
 * @param  {number}  indexB        The end code point index in the string to
 *                                 extract to
 * @return {string}                The substring as selected by indexA and indexB
 */
String.prototype.kmwSubstring = function (indexA, indexB) {
    var str = String(this), indexACodeUnit, indexBCodeUnit;
    if (typeof (indexB) == 'undefined') {
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.length;
    }
    else {
        if (indexA > indexB) {
            var c = indexA;
            indexA = indexB;
            indexB = c;
        }
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.kmwCodePointToCodeUnit(indexB);
    }
    if (isNaN(indexACodeUnit) || indexACodeUnit === null)
        indexACodeUnit = 0;
    if (isNaN(indexBCodeUnit) || indexBCodeUnit === null)
        indexBCodeUnit = str.length;
    return str.substring(indexACodeUnit, indexBCodeUnit);
};
/*
  Helper functions
*/
/**
 * Returns the code unit index for the next code point in the string, accounting for
 * supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to increment
 * @return {number|null}                 The index of the next code point in the string,
 *                                       in code units
 */
String.prototype.kmwNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null || codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            if (codeUnitIndex == str.length - 2) {
                return null;
            }
            return codeUnitIndex + 2;
        }
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string, accounting
 * for supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to decrement
 * @return {number|null}                 The index of the previous code point in the
 *                                       string, in code units
*/
String.prototype.kmwPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex == null || codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    var second = str.charCodeAt(codeUnitIndex - 1);
    if (second >= 0xDC00 && second <= 0xDFFF && codeUnitIndex > 1) {
        var first = str.charCodeAt(codeUnitIndex - 2);
        if (first >= 0xD800 && first <= 0xDBFF) {
            return codeUnitIndex - 2;
        }
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the corresponding code unit index to the code point index passed
 *
 * @param  {number|null} codePointIndex  A code point index in the string
 * @return {number|null}                 The corresponding code unit index
 */
String.prototype.kmwCodePointToCodeUnit = function (codePointIndex) {
    if (codePointIndex === null)
        return null;
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0) {
        codeUnitIndex = str.length;
        for (var i = 0; i > codePointIndex; i--)
            codeUnitIndex = str.kmwPrevChar(codeUnitIndex);
        return codeUnitIndex;
    }
    if (codePointIndex == str.kmwLength())
        return str.length;
    for (var i = 0; i < codePointIndex; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return codeUnitIndex;
};
/**
 * Returns the corresponding code point index to the code unit index passed
 *
 * @param  {number|null}  codeUnitIndex  A code unit index in the string
 * @return {number|null}                 The corresponding code point index
 */
String.prototype.kmwCodeUnitToCodePoint = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null)
        return null;
    else if (codeUnitIndex == 0)
        return 0;
    else if (codeUnitIndex < 0)
        return str.substr(codeUnitIndex).kmwLength();
    else
        return str.substr(0, codeUnitIndex).kmwLength();
};
/**
 * Returns the character at a the code point index passed
 *
 * @param  {number}  codePointIndex  A code point index in the string
 * @return {string}                  The corresponding character
 */
String.prototype.kmwCharAt = function (codePointIndex) {
    var str = String(this);
    if (codePointIndex >= 0)
        return str.kmwSubstr(codePointIndex, 1);
    else
        return '';
};
/**
 * String prototype library extensions for basic plane characters,
 * to simplify enabling or disabling supplementary plane functionality (I3319)
 */
/**
 * Returns the code unit index for the next code point in the string
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string
 *
 * @param  {number}  codeUnitIndex    A code unit index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the code unit index for a code point index
 *
 * @param  {number}  codePointIndex   A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodePointToCodeUnit = function (codePointIndex) {
    return codePointIndex;
};
/**
 * Returns the code point index for a code unit index
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodeUnitToCodePoint = function (codeUnitIndex) {
    return codeUnitIndex;
};
/**
 * Returns the length of a BMP string
 *
 * @return {number}                   The length in code points
 */
String.prototype.kmwBMPLength = function () {
    var str = String(this);
    return str.length;
};
/**
 * Returns a substring
 *
 * @param  {number}  n
 * @param  {number=}  ln
 * @return {string}
 */
String.prototype.kmwBMPSubstr = function (n, ln) {
    var str = String(this);
    if (n > -1)
        return str.substr(n, ln);
    else
        return str.substr(str.length + n, -n);
};
/**
 * Enable or disable supplementary plane string handling
 *
 * @param  {boolean}  bEnable
 */
String.kmwEnableSupplementaryPlane = function (bEnable) {
    var p = String.prototype;
    String._kmwFromCharCode = bEnable ? String.kmwFromCharCode : String.fromCharCode;
    p._kmwCharAt = bEnable ? p.kmwCharAt : p.charAt;
    p._kmwCharCodeAt = bEnable ? p.kmwCharCodeAt : p.charCodeAt;
    p._kmwIndexOf = bEnable ? p.kmwIndexOf : p.indexOf;
    p._kmwLastIndexOf = bEnable ? p.kmwLastIndexOf : p.lastIndexOf;
    p._kmwSlice = bEnable ? p.kmwSlice : p.slice;
    p._kmwSubstring = bEnable ? p.kmwSubstring : p.substring;
    p._kmwSubstr = bEnable ? p.kmwSubstr : p.kmwBMPSubstr;
    p._kmwLength = bEnable ? p.kmwLength : p.kmwBMPLength;
    p._kmwNextChar = bEnable ? p.kmwNextChar : p.kmwBMPNextChar;
    p._kmwPrevChar = bEnable ? p.kmwPrevChar : p.kmwBMPPrevChar;
    p._kmwCodePointToCodeUnit = bEnable ? p.kmwCodePointToCodeUnit : p.kmwBMPCodePointToCodeUnit;
    p._kmwCodeUnitToCodePoint = bEnable ? p.kmwCodeUnitToCodePoint : p.kmwBMPCodeUnitToCodePoint;
};
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            var Browser;
            (function (Browser) {
                Browser["Chrome"] = "chrome";
                Browser["Edge"] = "edge";
                Browser["Firefox"] = "firefox";
                Browser["Native"] = "native";
                Browser["Opera"] = "opera";
                Browser["Safari"] = "safari";
                Browser["Other"] = "other";
            })(Browser = utils.Browser || (utils.Browser = {}));
            var OperatingSystem;
            (function (OperatingSystem) {
                OperatingSystem["Windows"] = "windows";
                OperatingSystem["macOS"] = "macosx";
                OperatingSystem["Linux"] = "linux";
                OperatingSystem["Android"] = "android";
                OperatingSystem["iOS"] = "ios";
                OperatingSystem["Other"] = "other";
            })(OperatingSystem = utils.OperatingSystem || (utils.OperatingSystem = {}));
            var FormFactor;
            (function (FormFactor) {
                FormFactor["Desktop"] = "desktop";
                FormFactor["Phone"] = "phone";
                FormFactor["Tablet"] = "tablet";
            })(FormFactor = utils.FormFactor || (utils.FormFactor = {}));
            /**
             * This class provides an abstract version of com.keyman.Device that is core-friendly,
             * containing only the information needed by web-core for text processing use, devoid
             * of any direct references to the DOM.
             */
            var DeviceSpec = /** @class */ (function () {
                function DeviceSpec(browser, formFactor, OS, touchable) {
                    switch (browser.toLowerCase()) {
                        case Browser.Chrome:
                        case Browser.Edge:
                        case Browser.Firefox:
                        case Browser.Native:
                        case Browser.Opera:
                        case Browser.Safari:
                            this.browser = browser.toLowerCase();
                            break;
                        default:
                            this.browser = Browser.Other;
                    }
                    switch (formFactor.toLowerCase()) {
                        case FormFactor.Desktop:
                        case FormFactor.Phone:
                        case FormFactor.Tablet:
                            this.formFactor = formFactor.toLowerCase();
                            break;
                        default:
                            throw ("Invalid form factor specified for device: " + formFactor);
                    }
                    switch (OS.toLowerCase()) {
                        case OperatingSystem.Windows.toLowerCase():
                        case OperatingSystem.macOS.toLowerCase():
                        case OperatingSystem.Linux.toLowerCase():
                        case OperatingSystem.Android.toLowerCase():
                        case OperatingSystem.iOS.toLowerCase():
                            this.OS = OS.toLowerCase();
                            break;
                        default:
                            this.OS = OperatingSystem.Other;
                    }
                    this.touchable = touchable;
                }
                return DeviceSpec;
            }());
            utils.DeviceSpec = DeviceSpec;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// References all utility includes from a single file, making import/export simple.
///<reference path="deepCopy.ts" />
///<reference path="globalObject.ts" />
///<reference path="version.ts" />
///<reference path="kmwstring.ts" />
///<reference path="deviceSpec.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            // Defines the base Deadkey-tracking object.
            var Deadkey = /** @class */ (function () {
                function Deadkey(pos, id) {
                    this.p = pos;
                    this.d = id;
                    this.o = Deadkey.ordinalSeed++;
                }
                Deadkey.prototype.match = function (p, d) {
                    var result = (this.p == p && this.d == d);
                    return result;
                };
                Deadkey.prototype.set = function () {
                    this.matched = 1;
                };
                Deadkey.prototype.reset = function () {
                    this.matched = 0;
                };
                Deadkey.prototype.before = function (other) {
                    return this.o < other.o;
                };
                Deadkey.prototype.clone = function () {
                    var dk = new Deadkey(this.p, this.d);
                    dk.o = this.o;
                    return dk;
                };
                Deadkey.ordinalSeed = 0;
                /**
                 * Sorts the deadkeys in reverse order.
                 */
                Deadkey.sortFunc = function (a, b) {
                    // We want descending order, so we want 'later' deadkeys first.
                    if (a.p != b.p) {
                        return b.p - a.p;
                    }
                    else {
                        return b.o - a.o;
                    }
                };
                return Deadkey;
            }());
            text.Deadkey = Deadkey;
            // Object-orients deadkey management.
            var DeadkeyTracker = /** @class */ (function () {
                function DeadkeyTracker() {
                    this.dks = [];
                }
                DeadkeyTracker.prototype.toSortedArray = function () {
                    this.dks = this.dks.sort(Deadkey.sortFunc);
                    return [].concat(this.dks);
                };
                DeadkeyTracker.prototype.clone = function () {
                    var dkt = new DeadkeyTracker();
                    var dks = this.toSortedArray();
                    // Make sure to clone the deadkeys themselves - the Deadkey object is mutable.
                    dkt.dks = [];
                    dks.forEach(function (value) {
                        dkt.dks.push(value.clone());
                    });
                    return dkt;
                };
                /**
                 * Function     isMatch
                 * Scope        Public
                 * @param       {number}      caretPos  current cursor position
                 * @param       {number}      n         expected offset of deadkey from cursor
                 * @param       {number}      d         deadkey
                 * @return      {boolean}               True if deadkey found selected context matches val
                 * Description  Match deadkey at current cursor position
                 */
                DeadkeyTracker.prototype.isMatch = function (caretPos, n, d) {
                    if (this.dks.length == 0) {
                        return false; // I3318
                    }
                    var sp = caretPos;
                    n = sp - n;
                    for (var i = 0; i < this.dks.length; i++) {
                        // Don't re-match an already-matched deadkey.  It's possible to have two identical 
                        // entries, and they should be kept separately.
                        if (this.dks[i].match(n, d) && !this.dks[i].matched) {
                            this.dks[i].set();
                            // Assumption:  since we match the first possible entry in the array, we
                            // match the entry with the lower ordinal - the 'first' deadkey in the position.
                            return true; // I3318
                        }
                    }
                    this.resetMatched(); // I3318
                    return false;
                };
                DeadkeyTracker.prototype.add = function (dk) {
                    this.dks = this.dks.concat(dk);
                };
                DeadkeyTracker.prototype.remove = function (dk) {
                    var index = this.dks.indexOf(dk);
                    this.dks.splice(index, 1);
                };
                DeadkeyTracker.prototype.clear = function () {
                    this.dks = [];
                };
                DeadkeyTracker.prototype.resetMatched = function () {
                    for (var _i = 0, _a = this.dks; _i < _a.length; _i++) {
                        var dk = _a[_i];
                        dk.reset();
                    }
                };
                DeadkeyTracker.prototype.deleteMatched = function () {
                    for (var Li = 0; Li < this.dks.length; Li++) {
                        if (this.dks[Li].matched) {
                            this.dks.splice(Li--, 1); // Don't forget to decrement!
                        }
                    }
                };
                /**
                 * Function     adjustPositions (formerly _DeadkeyAdjustPos)
                 * Scope        Private
                 * @param       {number}      Lstart      start position in context
                 * @param       {number}      Ldelta      characters to adjust by
                 * Description  Adjust saved positions of deadkeys in context
                 */
                DeadkeyTracker.prototype.adjustPositions = function (Lstart, Ldelta) {
                    if (Ldelta == 0) {
                        return;
                    }
                    for (var _i = 0, _a = this.dks; _i < _a.length; _i++) {
                        var dk = _a[_i];
                        if (dk.p > Lstart) {
                            dk.p += Ldelta;
                        }
                    }
                };
                DeadkeyTracker.prototype.count = function () {
                    return this.dks.length;
                };
                return DeadkeyTracker;
            }());
            text.DeadkeyTracker = DeadkeyTracker;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Defines deadkey management in a manner attachable to each element interface.
///<reference path="../text/deadkeys.ts" />
// Defines the KeyEvent type.
///<reference path="keyEvent.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// Also relies on string-extensions provided by the web-utils package.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text_1) {
            var TextTransform = /** @class */ (function () {
                function TextTransform(insert, deleteLeft, deleteRight) {
                    this.insert = insert;
                    this.deleteLeft = deleteLeft;
                    this.deleteRight = deleteRight || 0;
                }
                TextTransform.nil = new TextTransform('', 0, 0);
                return TextTransform;
            }());
            text_1.TextTransform = TextTransform;
            var Transcription = /** @class */ (function () {
                function Transcription(keystroke, transform, preInput, alternates /*, removedDks: Deadkey[], insertedDks: Deadkey[]*/) {
                    var token = this.token = Transcription.tokenSeed++;
                    this.keystroke = keystroke;
                    this.transform = transform;
                    this.alternates = alternates;
                    this.preInput = preInput;
                    this.transform.id = this.token;
                    // Assign the ID to each alternate, as well.
                    if (alternates) {
                        alternates.forEach(function (alt) {
                            alt.sample.id = token;
                        });
                    }
                }
                Transcription.tokenSeed = 0;
                return Transcription;
            }());
            text_1.Transcription = Transcription;
            var OutputTarget = /** @class */ (function () {
                function OutputTarget() {
                    this._dks = new text.DeadkeyTracker();
                }
                Object.defineProperty(OutputTarget.prototype, "isSynthetic", {
                    /**
                     * Signifies that this OutputTarget has no default key processing behaviors.  This should be false
                     * for OutputTargets backed by web elements like HTMLInputElement or HTMLTextAreaElement.
                     */
                    get: function () {
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                OutputTarget.prototype.resetContext = function () {
                    this.deadkeys().clear();
                };
                OutputTarget.prototype.deadkeys = function () {
                    return this._dks;
                };
                OutputTarget.prototype.hasDeadkeyMatch = function (n, d) {
                    return this.deadkeys().isMatch(this.getDeadkeyCaret(), n, d);
                };
                OutputTarget.prototype.insertDeadkeyBeforeCaret = function (d) {
                    var dk = new text_1.Deadkey(this.getDeadkeyCaret(), d);
                    this.deadkeys().add(dk);
                };
                /**
                 * Should be called by each output target immediately before text mutation operations occur.
                 *
                 * Maintains solutions to old issues:  I3318,I3319
                 * @param {number} delta  Use negative values if characters were deleted, positive if characters were added.
                 */
                OutputTarget.prototype.adjustDeadkeys = function (delta) {
                    this.deadkeys().adjustPositions(this.getDeadkeyCaret(), delta);
                };
                /**
                 * Needed to properly clone deadkeys for use with Mock element interfaces toward predictive text purposes.
                 * @param {object}  dks   An existing set of deadkeys to deep-copy for use by this element interface.
                 */
                OutputTarget.prototype.setDeadkeys = function (dks) {
                    this._dks = dks.clone();
                };
                /**
                 * Determines the basic operations needed to reconstruct the current OutputTarget's text from the prior state specified
                 * by another OutputTarget based on their text and caret positions.
                 *
                 * This is designed for use as a "before and after" comparison to determine the effect of a single keyboard rule at a time.
                 * As such, it assumes that the caret is immediately after any inserted text.
                 * @param from An output target (preferably a Mock) representing the prior state of the input/output system.
                 */
                OutputTarget.prototype.buildTransformFrom = function (original) {
                    var to = this.getText();
                    var from = original.getText();
                    var fromCaret = original.getDeadkeyCaret();
                    var toCaret = this.getDeadkeyCaret();
                    // Step 1:  Determine the number of left-deletions.
                    var maxSMPLeftMatch = fromCaret < toCaret ? fromCaret : toCaret;
                    // We need the corresponding non-SMP caret location in order to binary-search efficiently.
                    // (Examining code units is much more computationally efficient.)
                    var maxLeftMatch = to._kmwCodePointToCodeUnit(maxSMPLeftMatch);
                    // 1.1:  use a non-SMP-aware binary search to determine the divergence point.
                    var start = 0;
                    var end = maxLeftMatch; // the index AFTER the last possible matching char.
                    // This search is O(maxLeftMatch).  1/2 + 1/4 + 1/8 + ... converges to = 1.
                    while (start < end) {
                        var mid = Math.floor((end + start + 1) / 2); // round up (compare more)
                        var fromLeft = from.substr(start, mid - start);
                        var toLeft = to.substr(start, mid - start);
                        if (fromLeft == toLeft) {
                            start = mid;
                        }
                        else {
                            end = mid - 1;
                        }
                    }
                    // At the loop's end:  `end` now holds the non-SMP-aware divergence point.
                    // The 'caret' is after the last matching code unit.
                    // 1.2:  detect a possible surrogate-pair split scenario, correcting for it
                    //       (by moving the split before the high-surrogate) if detected.
                    // If the split location is precisely on either end of the context, we can't
                    // have split a surrogate pair.
                    if (end > 0 && end < maxLeftMatch) {
                        var potentialHigh = from.charCodeAt(end - 1);
                        var potentialFromLow = from.charCodeAt(end);
                        var potentialToLow = to.charCodeAt(end);
                        // if potentialHigh is a possible high surrogate...
                        if (potentialHigh >= 0xD800 && potentialHigh <= 0xDBFF) {
                            // and at least one potential 'low' is a possible low surrogate...
                            var flag = potentialFromLow >= 0xDC00 && potentialFromLow <= 0xDFFF;
                            flag = flag || (potentialToLow >= 0XDC00 && potentialToLow <= 0xDFFF);
                            // Correct the split location, moving it 'before' the high surrogate.
                            if (flag) {
                                end = end - 1;
                            }
                        }
                    }
                    // 1.3:  take substring from start to the split point; determine SMP-aware length.
                    //       This yields the SMP-aware divergence index, which gives the number of left-deletes.
                    var newCaret = from._kmwCodeUnitToCodePoint(end);
                    var deletedLeft = fromCaret - newCaret;
                    // Step 2:  Determine the other properties.
                    // Since the 'after' OutputTarget's caret indicates the end of any inserted text, we
                    // can easily calculate the rest.
                    var insertedLength = toCaret - newCaret;
                    var delta = to._kmwSubstr(newCaret, insertedLength);
                    var undeletedRight = to._kmwLength() - toCaret;
                    var originalRight = from._kmwLength() - fromCaret;
                    var deletedRight = originalRight - undeletedRight;
                    // May occur when reverting a suggestion that had been applied mid-word.
                    if (deletedRight < 0) {
                        // Restores deleteRight characters.
                        delta = delta + to._kmwSubstr(toCaret, -deletedRight);
                        deletedRight = 0;
                    }
                    return new TextTransform(delta, deletedLeft, deletedRight);
                };
                OutputTarget.prototype.buildTranscriptionFrom = function (original, keyEvent, alternates) {
                    var transform = this.buildTransformFrom(original);
                    // If we ever decide to re-add deadkey tracking, this is the place for it.
                    return new Transcription(keyEvent, transform, Mock.from(original), alternates);
                };
                /**
                 * Restores the `OutputTarget` to the indicated state.  Designed for use with `Transcription.preInput`.
                 * @param original An `OutputTarget` (usually a `Mock`).
                 */
                OutputTarget.prototype.restoreTo = function (original) {
                    //
                    this.setTextBeforeCaret(original.getTextBeforeCaret());
                    this.setTextAfterCaret(original.getTextAfterCaret());
                    // Also, restore the deadkeys!
                    this._dks = original._dks.clone();
                };
                OutputTarget.prototype.apply = function (transform) {
                    if (transform.deleteRight) {
                        this.setTextAfterCaret(this.getTextAfterCaret()._kmwSubstr(transform.deleteRight));
                    }
                    if (transform.deleteLeft) {
                        this.deleteCharsBeforeCaret(transform.deleteLeft);
                    }
                    if (transform.insert) {
                        this.insertTextBeforeCaret(transform.insert);
                    }
                    // We assume that all deadkeys are invalidated after applying a Transform, since
                    // prediction implies we'll be completing a word, post-deadkeys.
                    this._dks.clear();
                };
                /**
                 * Helper to `restoreTo` - allows directly setting the 'before' context to that of another
                 * `OutputTarget`.
                 * @param s
                 */
                OutputTarget.prototype.setTextBeforeCaret = function (s) {
                    // This one's easy enough to provide a default implementation for.
                    this.deleteCharsBeforeCaret(this.getTextBeforeCaret()._kmwLength());
                    this.insertTextBeforeCaret(s);
                };
                /**
                 * Saves element-specific state properties prone to mutation, enabling restoration after
                 * text-output operations.
                 */
                OutputTarget.prototype.saveProperties = function () {
                    // Most element interfaces won't need anything here.
                };
                /**
                 * Restores previously-saved element-specific state properties.  Designed for use after text-output
                 * ops to facilitate more-seamless web-dev and user interactions.
                 */
                OutputTarget.prototype.restoreProperties = function () {
                    // Most element interfaces won't need anything here. 
                };
                return OutputTarget;
            }());
            text_1.OutputTarget = OutputTarget;
            // Due to some interesting requirements on compile ordering in TS,
            // this needs to be in the same file as OutputTarget now.
            var Mock = /** @class */ (function (_super) {
                __extends(Mock, _super);
                function Mock(text, caretPos) {
                    var _this = _super.call(this) || this;
                    _this.text = text ? text : "";
                    var defaultLength = _this.text._kmwLength();
                    // Ensures that `caretPos == 0` is handled correctly.
                    _this.caretIndex = typeof caretPos == "number" ? caretPos : defaultLength;
                    return _this;
                }
                // Clones the state of an existing EditableElement, creating a Mock version of its state.
                Mock.from = function (outputTarget) {
                    var clone;
                    if (outputTarget instanceof Mock) {
                        // Avoids the need to run expensive kmwstring.ts / `_kmwLength()`
                        // calculations when deep-copying Mock instances.
                        var priorMock = outputTarget;
                        clone = new Mock(priorMock.text, priorMock.caretIndex);
                    }
                    else {
                        // If we're 'cloning' a different OutputTarget type, we don't have a
                        // guaranteed way to more efficiently get these values; these are the
                        // best methods specified by the abstraction.
                        var preText = outputTarget.getTextBeforeCaret();
                        var caretIndex = preText._kmwLength();
                        // We choose to ignore (rather, pre-emptively remove) any actively-selected text,
                        // as since it's always removed instantly during any text mutation operations.
                        clone = new Mock(preText + outputTarget.getTextAfterCaret(), caretIndex);
                    }
                    // Also duplicate deadkey state!  (Needed for fat-finger ops.)
                    clone.setDeadkeys(outputTarget.deadkeys());
                    return clone;
                };
                Mock.prototype.clearSelection = function () {
                    return;
                };
                Mock.prototype.invalidateSelection = function () {
                    return;
                };
                Mock.prototype.hasSelection = function () {
                    return true;
                };
                Mock.prototype.getDeadkeyCaret = function () {
                    return this.caretIndex;
                };
                Mock.prototype.setDeadkeyCaret = function (index) {
                    if (index < 0 || index > this.text._kmwLength()) {
                        throw new Error("Provided caret index is out of range.");
                    }
                    this.caretIndex = index;
                };
                Mock.prototype.getTextBeforeCaret = function () {
                    return this.text.kmwSubstr(0, this.caretIndex);
                };
                Mock.prototype.getTextAfterCaret = function () {
                    return this.text.kmwSubstr(this.caretIndex);
                };
                Mock.prototype.getText = function () {
                    return this.text;
                };
                Mock.prototype.deleteCharsBeforeCaret = function (dn) {
                    if (dn >= 0) {
                        if (dn > this.caretIndex) {
                            dn = this.caretIndex;
                        }
                        this.text = this.text.kmwSubstr(0, this.caretIndex - dn) + this.getTextAfterCaret();
                        this.caretIndex -= dn;
                    }
                };
                Mock.prototype.insertTextBeforeCaret = function (s) {
                    this.text = this.getTextBeforeCaret() + s + this.getTextAfterCaret();
                    this.caretIndex += s.kmwLength();
                };
                Mock.prototype.handleNewlineAtCaret = function () {
                    this.insertTextBeforeCaret('\n');
                };
                Mock.prototype.setTextAfterCaret = function (s) {
                    this.text = this.getTextBeforeCaret() + s;
                };
                Mock.prototype.doInputEvent = function () {
                    // Mock isn't backed by an element, so it won't have any event listeners.
                };
                return Mock;
            }(OutputTarget));
            text_1.Mock = Mock;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="outputTarget.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            /**
             * This class is defined within its own file so that it can be loaded by code outside of KMW without
             * having to actually load the entirety of KMW.
             */
            var KeyEvent = /** @class */ (function () {
                function KeyEvent() {
                    /**
                     * `true` if this event was produced by sources other than a DOM-based KeyboardEvent.
                     */
                    this.isSynthetic = true;
                }
                return KeyEvent;
            }());
            text.KeyEvent = KeyEvent;
            ;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var KMWRecorder;
(function (KMWRecorder) {
    /**
     * Facilitates running Recorder-generated tests on various platforms.
     *
     * Note that DOM-aware KeymanWeb will implement a Browser-based version, while
     * keyboard-processor and input-processor will use a Node-based version instead.
     */
    var Proctor = /** @class */ (function () {
        function Proctor(device, assert) {
            this.device = device;
            this._assert = assert;
        }
        Proctor.prototype.assertEquals = function (s1, s2, msg) {
            if (this._assert) {
                this._assert(s1, s2, msg);
            }
        };
        return Proctor;
    }());
    KMWRecorder.Proctor = Proctor;
})(KMWRecorder || (KMWRecorder = {}));
/// <reference path="../node_modules/@keymanapp/keyboard-processor/src/text/keyEvent.ts" />
/// <reference path="proctor.ts" />
var KMWRecorder;
(function (KMWRecorder) {
    //#region Defines the InputEventSpec set, used to reconstruct DOM-based events for browser-based simulation
    var InputEventSpec = /** @class */ (function () {
        function InputEventSpec() {
        }
        InputEventSpec.fromJSONObject = function (obj) {
            if (obj && obj.type) {
                if (obj.type == "key") {
                    return new PhysicalInputEventSpec(obj);
                }
                else if (obj.type == "osk") {
                    return new OSKInputEventSpec(obj);
                }
            }
            else {
                throw new SyntaxError("Error in JSON format corresponding to an InputEventSpec!");
            }
        };
        InputEventSpec.prototype.toPrettyJSON = function () {
            // We want the default, non-spaced JSON for this class, even when otherwise adding whitespace.
            var str = JSON.stringify(this);
            return str;
        };
        return InputEventSpec;
    }());
    KMWRecorder.InputEventSpec = InputEventSpec;
    var PhysicalInputEventSpec = /** @class */ (function (_super) {
        __extends(PhysicalInputEventSpec, _super);
        function PhysicalInputEventSpec(e) {
            var _this = _super.call(this) || this;
            // KeyboardEvent properties
            _this.type = "key";
            if (e) {
                _this.key = e.key;
                _this.code = e.code;
                _this.keyCode = e.keyCode;
                _this.modifierSet = e.modifierSet;
                _this.location = e.location;
            }
            return _this;
        }
        PhysicalInputEventSpec.prototype.getModifierState = function (key) {
            return (PhysicalInputEventSpec.modifierCodes[key] & this.modifierSet) != 0;
        };
        PhysicalInputEventSpec.prototype.generateModifierString = function () {
            var list = "";
            for (var key in PhysicalInputEventSpec.modifierCodes) {
                if (this.getModifierState(key)) {
                    list += ((list != "" ? " " : "") + key);
                }
            }
            return list;
        };
        PhysicalInputEventSpec.modifierCodes = {
            "Shift": 0x0001,
            "Control": 0x0002,
            "Alt": 0x0004,
            "Meta": 0x0008,
            "CapsLock": 0x0010,
            "NumLock": 0x0020,
            "ScrollLock": 0x0040
        };
        return PhysicalInputEventSpec;
    }(InputEventSpec));
    KMWRecorder.PhysicalInputEventSpec = PhysicalInputEventSpec;
    var OSKInputEventSpec = /** @class */ (function (_super) {
        __extends(OSKInputEventSpec, _super);
        // The parameter may be used to reconstruct the item from raw JSON.
        function OSKInputEventSpec(e) {
            var _this = _super.call(this) || this;
            _this.type = "osk";
            if (e) {
                _this.keyID = e.keyID;
            }
            return _this;
        }
        return OSKInputEventSpec;
    }(InputEventSpec));
    KMWRecorder.OSKInputEventSpec = OSKInputEventSpec;
    //#endregion
    var RecordedKeystroke = /** @class */ (function () {
        function RecordedKeystroke() {
        }
        RecordedKeystroke.fromJSONObject = function (obj) {
            if (obj && obj.type) {
                if (obj.type == "key") {
                    return new RecordedPhysicalKeystroke(obj);
                }
                else if (obj && obj.type) {
                    return new RecordedSyntheticKeystroke(obj);
                }
            }
            else {
                throw new SyntaxError("Error in JSON format corresponding to a RecordedKeystroke!");
            }
        };
        RecordedKeystroke.prototype.toPrettyJSON = function () {
            // We want the default, non-spaced JSON for this class, even when otherwise adding whitespace.
            var str = JSON.stringify(this);
            return str;
        };
        return RecordedKeystroke;
    }());
    KMWRecorder.RecordedKeystroke = RecordedKeystroke;
    var RecordedPhysicalKeystroke = /** @class */ (function (_super) {
        __extends(RecordedPhysicalKeystroke, _super);
        function RecordedPhysicalKeystroke(keystroke, eventSpec) {
            var _this = _super.call(this) || this;
            // KeyboardEvent properties
            _this.type = "key";
            if (keystroke instanceof com.keyman.text.KeyEvent || typeof keystroke.type === 'undefined') {
                // Store what is necessary for headless event reconstruction.
                keystroke = keystroke;
                _this.keyCode = keystroke.Lcode;
                _this.states = keystroke.Lstates;
                _this.modifiers = keystroke.Lmodifiers;
                _this.modifierChanged = !!keystroke.LmodifierChange;
                _this.isVirtualKey = keystroke.LisVirtualKey;
                _this.vkCode = keystroke.vkCode;
                // Also store the DOM-based event spec for use in integrated testing.
                _this.eventSpec = eventSpec;
            }
            else {
                // It might be a raw object, from JSON.
                _this.keyCode = keystroke.keyCode;
                _this.states = keystroke.states;
                _this.modifiers = keystroke.modifiers;
                _this.modifierChanged = keystroke.modifierChanged;
                _this.isVirtualKey = keystroke.isVirtualKey;
                _this.vkCode = keystroke.vkCode;
                _this.eventSpec = new PhysicalInputEventSpec(keystroke.eventSpec); // must also be reconstructed.
            }
            return _this;
        }
        Object.defineProperty(RecordedPhysicalKeystroke.prototype, "inputEventSpec", {
            get: function () {
                return this.eventSpec;
            },
            enumerable: true,
            configurable: true
        });
        return RecordedPhysicalKeystroke;
    }(RecordedKeystroke));
    KMWRecorder.RecordedPhysicalKeystroke = RecordedPhysicalKeystroke;
    var RecordedSyntheticKeystroke = /** @class */ (function (_super) {
        __extends(RecordedSyntheticKeystroke, _super);
        function RecordedSyntheticKeystroke(keystroke) {
            var _this = _super.call(this) || this;
            // KeyboardEvent properties
            _this.type = "osk";
            if (keystroke instanceof com.keyman.text.KeyEvent || typeof keystroke.type === 'undefined') {
                keystroke = keystroke;
                // Store what is necessary for headless event reconstruction.
                // Also store the DOM-based event spec for use in integrated testing.
                _this.layer = keystroke.kbdLayer;
                _this.keyName = keystroke.kName;
                _this.keyDistribution = keystroke.keyDistribution;
            }
            else {
                // It might be a raw object, from JSON.
                _this.layer = keystroke.layer;
                _this.keyName = keystroke.keyName;
                _this.keyDistribution = keystroke.keyDistribution;
            }
            return _this;
        }
        Object.defineProperty(RecordedSyntheticKeystroke.prototype, "inputEventSpec", {
            get: function () {
                var eventSpec = new OSKInputEventSpec();
                eventSpec.keyID = this.layer + '-' + this.keyName;
                return eventSpec;
            },
            enumerable: true,
            configurable: true
        });
        return RecordedSyntheticKeystroke;
    }(RecordedKeystroke));
    KMWRecorder.RecordedSyntheticKeystroke = RecordedSyntheticKeystroke;
    var TestSequence = /** @class */ (function () {
        function TestSequence() {
        }
        TestSequence.prototype.test = function (proctor, target) {
            // Start with an empty OutputTarget and a fresh KeyboardProcessor.
            if (!target) {
                target = new com.keyman.text.Mock();
            }
            proctor.before();
            var result = proctor.simulateSequence(this, target);
            proctor.assertEquals(result, this.output, this.msg);
            return { success: (result == this.output), result: result };
        };
        TestSequence.prototype.toPrettyJSON = function () {
            var str = "{ ";
            if (this.output) {
                str += "\"output\": \"" + this.output + "\", ";
            }
            str += "\"inputs\": [\n";
            for (var i = 0; i < this.inputs.length; i++) {
                str += "  " + this.inputs[i].toPrettyJSON() + ((i == this.inputs.length - 1) ? "\n" : ",\n");
            }
            if (this.msg) {
                str += "], \"message\": \"" + this.msg + "\" }";
            }
            else {
                str += "]}";
            }
            return str;
        };
        return TestSequence;
    }());
    KMWRecorder.TestSequence = TestSequence;
    var InputEventSpecSequence = /** @class */ (function (_super) {
        __extends(InputEventSpecSequence, _super);
        function InputEventSpecSequence(ins, outs, msg) {
            var _this = _super.call(this) || this;
            if (ins) {
                if (ins instanceof Array) {
                    _this.inputs = [].concat(ins);
                }
                else {
                    // We're constructing from existing JSON.
                    _this.inputs = [];
                    for (var ie = 0; ie < ins.inputs.length; ie++) {
                        _this.inputs.push(InputEventSpec.fromJSONObject(ins.inputs[ie]));
                    }
                    _this.output = ins.output;
                    _this.msg = ins.msg;
                    return _this;
                }
            }
            else {
                _this.inputs = [];
            }
            if (outs) {
                _this.output = outs;
            }
            if (msg) {
                _this.msg = msg;
            }
            return _this;
        }
        InputEventSpecSequence.prototype.addInput = function (event, output) {
            this.inputs.push(event);
            this.output = output;
        };
        InputEventSpecSequence.prototype.hasOSKInteraction = function () {
            for (var i = 0; i < this.inputs.length; i++) {
                if (this.inputs[i] instanceof OSKInputEventSpec) {
                    return true;
                }
            }
            return false;
        };
        return InputEventSpecSequence;
    }(TestSequence));
    KMWRecorder.InputEventSpecSequence = InputEventSpecSequence;
    var RecordedKeystrokeSequence = /** @class */ (function (_super) {
        __extends(RecordedKeystrokeSequence, _super);
        function RecordedKeystrokeSequence(ins, outs, msg) {
            var _this = _super.call(this) || this;
            if (ins) {
                if (ins instanceof Array) {
                    _this.inputs = [].concat(ins);
                }
                else {
                    // We're constructing from existing JSON.
                    _this.inputs = [];
                    for (var ie = 0; ie < ins.inputs.length; ie++) {
                        _this.inputs.push(RecordedKeystroke.fromJSONObject(ins.inputs[ie]));
                    }
                    _this.output = ins.output;
                    _this.msg = ins.msg;
                    return _this;
                }
            }
            else {
                _this.inputs = [];
            }
            if (outs) {
                _this.output = outs;
            }
            if (msg) {
                _this.msg = msg;
            }
            return _this;
        }
        RecordedKeystrokeSequence.prototype.addInput = function (event, output) {
            this.inputs.push(event);
            this.output = output;
        };
        RecordedKeystrokeSequence.prototype.hasOSKInteraction = function () {
            for (var i = 0; i < this.inputs.length; i++) {
                if (this.inputs[i] instanceof RecordedSyntheticKeystroke) {
                    return true;
                }
            }
            return false;
        };
        return RecordedKeystrokeSequence;
    }(TestSequence));
    KMWRecorder.RecordedKeystrokeSequence = RecordedKeystrokeSequence;
    var FontStubForLanguage = /** @class */ (function () {
        function FontStubForLanguage(activeStubEntry) {
            this.family = activeStubEntry.family;
            var src = activeStubEntry.files;
            if (!(src instanceof Array)) {
                src = [src];
            }
            this.source = [];
            for (var i = 0; i < src.length; i++) {
                this.source.push(activeStubEntry.path + src[i]);
            }
        }
        return FontStubForLanguage;
    }());
    var LanguageStubForKeyboard = /** @class */ (function () {
        function LanguageStubForKeyboard(activeStub) {
            if (activeStub.KLC) {
                this.id = activeStub.KLC;
                this.name = activeStub.KL;
                this.region = activeStub.KR;
                // Fonts.
                if (activeStub.KFont) {
                    this.font = new FontStubForLanguage(activeStub.KFont);
                }
                if (activeStub.KOskFont) {
                    this.oskFont = new FontStubForLanguage(activeStub.KOskFont);
                }
            }
            else {
                this.id = activeStub.id;
                this.name = activeStub.name;
                this.region = activeStub.region;
                // If we end up adding functionality to FontStubForLanguage, we'll need to properly reconstruct these.
                this.font = activeStub.font;
                this.oskFont = activeStub.oskFont;
            }
        }
        return LanguageStubForKeyboard;
    }());
    KMWRecorder.LanguageStubForKeyboard = LanguageStubForKeyboard;
    var KeyboardStub = /** @class */ (function () {
        // Constructs a stub usable with KeymanWeb's addKeyboards() API function from
        // the internally-tracked ActiveStub value for that keyboard.
        function KeyboardStub(json) {
            if (json) {
                this.id = json.id;
                this.name = json.name;
                this.filename = json.filename;
                if (!Array.isArray(json.languages)) {
                    this.languages = new LanguageStubForKeyboard(json.languages);
                }
                else {
                    this.languages = [];
                    for (var i = 0; i < json.languages.length; i++) {
                        this.languages.push(new LanguageStubForKeyboard(json.languages[i]));
                    }
                }
            }
        }
        KeyboardStub.prototype.getFirstLanguage = function () {
            if (this.languages instanceof LanguageStubForKeyboard) {
                return this.languages.id;
            }
            else {
                return this.languages[0].id;
            }
        };
        return KeyboardStub;
    }());
    KMWRecorder.KeyboardStub = KeyboardStub;
    var Constraint = /** @class */ (function () {
        function Constraint(target, validOSList, validBrowsers) {
            if (typeof (target) == 'string') {
                this.target = target;
                this.validOSList = validOSList;
                this.validBrowsers = validBrowsers;
            }
            else {
                var json = target;
                this.target = json.target;
                this.validOSList = json.validOSList;
                this.validBrowsers = json.validBrowsers;
            }
        }
        Constraint.prototype.matchesClient = function (device, usingOSK) {
            // #1:  Platform check.
            if (usingOSK === true) {
                if (this.target != device.formFactor) {
                    return false;
                }
            }
            else if (usingOSK === false) {
                if (this.target != 'hardware') {
                    return false;
                }
            }
            else if (this.target != device.formFactor && this.target != 'hardware') {
                return false;
            }
            if (this.validOSList) {
                if (this.validOSList.indexOf(device.OS) == -1) {
                    return false;
                }
            }
            if (this.validBrowsers) {
                if (this.validBrowsers.indexOf(device.browser) == -1) {
                    return false;
                }
            }
            return true;
        };
        // Checks if another Constraint instance is functionally identical to this one.
        Constraint.prototype.equals = function (other) {
            if (this.target != other.target) {
                return false;
            }
            var list1 = this.validOSList ? this.validOSList : ['any'];
            var list2 = other.validOSList ? other.validOSList : ['any'];
            if (list1.sort().join(',') != list2.sort().join(',')) {
                return false;
            }
            list1 = this.validBrowsers ? this.validBrowsers : ['web'];
            list2 = other.validBrowsers ? other.validBrowsers : ['web'];
            if (list1.sort().join(',') != list2.sort().join(',')) {
                return false;
            }
            return true;
        };
        return Constraint;
    }());
    KMWRecorder.Constraint = Constraint;
    var TestFailure = /** @class */ (function () {
        function TestFailure(constraint, test, output) {
            this.constraint = constraint;
            this.test = test;
            this.result = output;
        }
        return TestFailure;
    }());
    KMWRecorder.TestFailure = TestFailure;
    /**
     * The core constraint-specific test set definition used for testing versions 10.0 to 13.0.
     */
    var EventSpecTestSet = /** @class */ (function () {
        function EventSpecTestSet(constraint) {
            if ("target" in constraint) {
                this.constraint = constraint;
                this.testSet = [];
            }
            else {
                var json = constraint;
                this.constraint = new Constraint(json.constraint);
                this.testSet = [];
                // Clone each test sequence / reconstruct from methodless JSON object.
                for (var i = 0; i < json.testSet.length; i++) {
                    this.testSet.push(new InputEventSpecSequence(json.testSet[i]));
                }
            }
        }
        EventSpecTestSet.prototype.addTest = function (seq) {
            this.testSet.push(seq);
        };
        // Used to determine if the current EventSpecTestSet is applicable to be run on a device.
        EventSpecTestSet.prototype.isValidForDevice = function (device, usingOSK) {
            return this.constraint.matchesClient(device, usingOSK);
        };
        // Validity should be checked before calling this method.
        EventSpecTestSet.prototype.test = function (proctor) {
            var failures = [];
            var testSet = this.testSet;
            for (var i = 0; i < testSet.length; i++) {
                var testSeq = this[i];
                var simResult = testSet[i].test(proctor);
                if (!simResult.success) {
                    // Failed test!
                    failures.push(new TestFailure(this.constraint, testSeq, simResult.result));
                }
            }
            return failures.length > 0 ? failures : null;
        };
        return EventSpecTestSet;
    }());
    KMWRecorder.EventSpecTestSet = EventSpecTestSet;
    /**
     * The core constraint-specific test set definition used for testing versions 10.0 to 13.0.
     */
    var RecordedSequenceTestSet = /** @class */ (function () {
        function RecordedSequenceTestSet(constraint) {
            if ("target" in constraint) {
                this.constraint = constraint;
                this.testSet = [];
            }
            else {
                var json = constraint;
                this.constraint = new Constraint(json.constraint);
                this.testSet = [];
                // Clone each test sequence / reconstruct from methodless JSON object.
                for (var i = 0; i < json.testSet.length; i++) {
                    this.testSet.push(new RecordedKeystrokeSequence(json.testSet[i]));
                }
            }
        }
        RecordedSequenceTestSet.prototype.addTest = function (seq) {
            this.testSet.push(seq);
        };
        // Used to determine if the current EventSpecTestSet is applicable to be run on a device.
        RecordedSequenceTestSet.prototype.isValidForDevice = function (device, usingOSK) {
            return this.constraint.matchesClient(device, usingOSK);
        };
        // Validity should be checked before calling this method.
        RecordedSequenceTestSet.prototype.test = function (proctor) {
            var failures = [];
            var testSet = this.testSet;
            for (var i = 0; i < testSet.length; i++) {
                var testSeq = this[i];
                var simResult = testSet[i].test(proctor);
                if (!simResult.success) {
                    // Failed test!
                    failures.push(new TestFailure(this.constraint, testSeq, simResult.result));
                }
            }
            return failures.length > 0 ? failures : null;
        };
        RecordedSequenceTestSet.prototype.toTestName = function () {
            var name = "constraint: for " + this.constraint.target;
            if (this.constraint.target == 'hardware') {
                name += " keyboard";
            }
            else {
                name += " OSK";
            }
            if (this.constraint.validOSList) {
                name += " on OS of " + JSON.stringify(this.constraint.validOSList);
            }
            if (this.constraint.validBrowsers) {
                name += " in browser of " + JSON.stringify(this.constraint.validBrowsers);
            }
            return name;
        };
        return RecordedSequenceTestSet;
    }());
    KMWRecorder.RecordedSequenceTestSet = RecordedSequenceTestSet;
    var KeyboardTest = /** @class */ (function () {
        /**
         * Reconstructs a KeyboardTest object from its JSON representation, restoring its methods.
         * @param fromJSON
         */
        function KeyboardTest(fromJSON) {
            /**
             * Indicates what version of KMW's recorder the spec conforms to.
             */
            this.specVersion = KeyboardTest.CURRENT_VERSION;
            if (!fromJSON) {
                this.keyboard = null;
                this.inputTestSets = [];
                return;
            }
            else if (typeof (fromJSON) == 'string') {
                fromJSON = JSON.parse(fromJSON);
            }
            else if (fromJSON instanceof KeyboardStub) {
                this.keyboard = fromJSON;
                this.inputTestSets = [];
                return;
            }
            if (!fromJSON.specVersion) {
                fromJSON.specVersion = KeyboardTest.FALLBACK_VERSION;
            }
            else {
                // Is serialized to a String when saved.
                fromJSON.specVersion = new com.keyman.utils.Version(fromJSON.specVersion);
            }
            this.keyboard = new KeyboardStub(fromJSON.keyboard);
            this.inputTestSets = [];
            this.specVersion = fromJSON.specVersion;
            if (this.specVersion.equals(KeyboardTest.FALLBACK_VERSION)) {
                // Top-level test spec:  EventSpecTestSet, based entirely on browser events.
                for (var i = 0; i < fromJSON.inputTestSets.length; i++) {
                    this.inputTestSets[i] = new EventSpecTestSet(fromJSON.inputTestSets[i]);
                }
            }
            else {
                for (var i = 0; i < fromJSON.inputTestSets.length; i++) {
                    this.inputTestSets[i] = new RecordedSequenceTestSet(fromJSON.inputTestSets[i]);
                }
            }
        }
        KeyboardTest.prototype.addTest = function (constraint, seq) {
            if (!this.specVersion.equals(KeyboardTest.CURRENT_VERSION)) {
                throw new Error("The currently-loaded test was built to an outdated specification and may not be altered.");
            }
            for (var i = 0; i < this.inputTestSets.length; i++) {
                if (this.inputTestSets[i].constraint.equals(constraint)) {
                    this.inputTestSets[i].addTest(seq);
                    return;
                }
            }
            var newSet = new RecordedSequenceTestSet(new Constraint(constraint));
            this.inputTestSets.push(newSet);
            newSet.addTest(seq);
        };
        KeyboardTest.prototype.test = function (proctor) {
            var setHasRun = false;
            var failures = [];
            proctor.beforeAll();
            // The original test spec requires a browser environment and thus requires its own `.run` implementation.
            if (!(proctor.compatibleWithSuite(this))) {
                throw Error("Cannot perform version " + KeyboardTest.FALLBACK_VERSION + "-based testing outside of browser-based environments.");
            }
            // Otherwise, the test spec instances will know how to run in any currently-supported environment.
            for (var i = 0; i < this.inputTestSets.length; i++) {
                var testSet = this.inputTestSets[i];
                if (proctor.matchesTestSet(testSet)) {
                    var testFailures = testSet.test(proctor);
                    if (testFailures) {
                        failures = failures.concat(testFailures);
                    }
                    setHasRun = true;
                }
            }
            if (!setHasRun) {
                // The sets CAN be empty, allowing silent failure if/when we actually want that.
                console.warn("No test sets for this keyboard were applicable for this device!");
            }
            // Allow the method's caller to trigger a 'fail'.
            if (failures.length > 0) {
                return failures;
            }
            else {
                return null;
            }
        };
        KeyboardTest.prototype.isEmpty = function () {
            return this.inputTestSets.length == 0;
        };
        KeyboardTest.prototype.toPrettyJSON = function () {
            return JSON.stringify(this, null, '  ');
        };
        Object.defineProperty(KeyboardTest.prototype, "isLegacy", {
            get: function () {
                return !this.specVersion.equals(KeyboardTest.CURRENT_VERSION);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * The version of KMW in which the Recorder was first written.  Worked from 10.0 to 13.0 with
         * only backward-compatible changes and minor tweaks to conform to internal API shifts.
         */
        KeyboardTest.FALLBACK_VERSION = new com.keyman.utils.Version("10.0");
        KeyboardTest.CURRENT_VERSION = new com.keyman.utils.Version("14.0");
        return KeyboardTest;
    }());
    KMWRecorder.KeyboardTest = KeyboardTest;
})(KMWRecorder || (KMWRecorder = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            text.Codes = {
                // Define Keyman Developer modifier bit-flags (exposed for use by other modules)
                // Compare against /common/core/desktop/src/kmx/kmx_file.h.  CTRL+F "#define LCTRLFLAG" to find the secton.
                modifierCodes: {
                    "LCTRL": 0x0001,
                    "RCTRL": 0x0002,
                    "LALT": 0x0004,
                    "RALT": 0x0008,
                    "SHIFT": 0x0010,
                    "CTRL": 0x0020,
                    "ALT": 0x0040,
                    // TENTATIVE:  Represents command keys, which some OSes use for shortcuts we don't
                    // want to block.  No rule will ever target a modifier set with this bit set to 1. 
                    "META": 0x0080,
                    "CAPS": 0x0100,
                    "NO_CAPS": 0x0200,
                    "NUM_LOCK": 0x0400,
                    "NO_NUM_LOCK": 0x0800,
                    "SCROLL_LOCK": 0x1000,
                    "NO_SCROLL_LOCK": 0x2000,
                    "VIRTUAL_KEY": 0x4000,
                    "VIRTUAL_CHAR_KEY": 0x8000 // VIRTUALCHARKEY // Unused by KMW, but reserved for use by other Keyman engines.
                },
                modifierBitmasks: {
                    "ALL": 0x007F,
                    "ALT_GR_SIM": (0x0001 | 0x0004),
                    "CHIRAL": 0x001F,
                    "IS_CHIRAL": 0x000F,
                    "NON_CHIRAL": 0x0070 // The default bitmask, for non-chiral keyboards
                },
                stateBitmasks: {
                    "ALL": 0x3F00,
                    "CAPS": 0x0300,
                    "NUM_LOCK": 0x0C00,
                    "SCROLL_LOCK": 0x3000
                },
                // Define standard keycode numbers (exposed for use by other modules)
                keyCodes: {
                    "K_BKSP": 8, "K_TAB": 9, "K_ENTER": 13,
                    "K_SHIFT": 16, "K_CONTROL": 17, "K_ALT": 18, "K_PAUSE": 19, "K_CAPS": 20,
                    "K_ESC": 27, "K_SPACE": 32, "K_PGUP": 33,
                    "K_PGDN": 34, "K_END": 35, "K_HOME": 36, "K_LEFT": 37, "K_UP": 38,
                    "K_RIGHT": 39, "K_DOWN": 40, "K_SEL": 41, "K_PRINT": 42, "K_EXEC": 43,
                    "K_INS": 45, "K_DEL": 46, "K_HELP": 47, "K_0": 48,
                    "K_1": 49, "K_2": 50, "K_3": 51, "K_4": 52, "K_5": 53, "K_6": 54, "K_7": 55,
                    "K_8": 56, "K_9": 57, "K_A": 65, "K_B": 66, "K_C": 67, "K_D": 68, "K_E": 69,
                    "K_F": 70, "K_G": 71, "K_H": 72, "K_I": 73, "K_J": 74, "K_K": 75, "K_L": 76,
                    "K_M": 77, "K_N": 78, "K_O": 79, "K_P": 80, "K_Q": 81, "K_R": 82, "K_S": 83,
                    "K_T": 84, "K_U": 85, "K_V": 86, "K_W": 87, "K_X": 88, "K_Y": 89, "K_Z": 90,
                    "K_NP0": 96, "K_NP1": 97, "K_NP2": 98,
                    "K_NP3": 99, "K_NP4": 100, "K_NP5": 101, "K_NP6": 102,
                    "K_NP7": 103, "K_NP8": 104, "K_NP9": 105, "K_NPSTAR": 106,
                    "K_NPPLUS": 107, "K_SEPARATOR": 108, "K_NPMINUS": 109, "K_NPDOT": 110,
                    "K_NPSLASH": 111, "K_F1": 112, "K_F2": 113, "K_F3": 114, "K_F4": 115,
                    "K_F5": 116, "K_F6": 117, "K_F7": 118, "K_F8": 119, "K_F9": 120,
                    "K_F10": 121, "K_F11": 122, "K_F12": 123, "K_NUMLOCK": 144, "K_SCROLL": 145,
                    "K_LSHIFT": 160, "K_RSHIFT": 161, "K_LCONTROL": 162, "K_RCONTROL": 163,
                    "K_LALT": 164, "K_RALT": 165,
                    "K_COLON": 186, "K_EQUAL": 187, "K_COMMA": 188, "K_HYPHEN": 189,
                    "K_PERIOD": 190, "K_SLASH": 191, "K_BKQUOTE": 192,
                    "K_LBRKT": 219, "K_BKSLASH": 220, "K_RBRKT": 221,
                    "K_QUOTE": 222, "K_oE2": 226, "K_OE2": 226,
                    "K_LOPT": 50001, "K_ROPT": 50002,
                    "K_NUMERALS": 50003, "K_SYMBOLS": 50004, "K_CURRENCIES": 50005,
                    "K_UPPER": 50006, "K_LOWER": 50007, "K_ALPHA": 50008,
                    "K_SHIFTED": 50009, "K_ALTGR": 50010,
                    "K_TABBACK": 50011, "K_TABFWD": 50012
                },
                codesUS: [
                    ['0123456789', ';=,-./`', '[\\]\''],
                    [')!@#$%^&*(', ':+<_>?~', '{|}"']
                ]
            };
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            /**
             * Represents the commands and state changes that result from a matched keyboard rule.
             */
            var RuleBehavior = /** @class */ (function () {
                function RuleBehavior() {
                    /**
                     * The before-and-after Transform from matching a keyboard rule.  May be `null`
                     * if no keyboard rules were matched for the keystroke.
                     */
                    this.transcription = null;
                    /**
                     * A set of changed store values triggered by the matched keyboard rule.
                     */
                    this.setStore = {};
                    /**
                     * A set of variable stores with save requests triggered by the matched keyboard rule
                     */
                    this.saveStore = {};
                    /**
                     * Denotes a non-output default behavior; this should be evaluated later, against the true keystroke.
                     */
                    this.triggersDefaultCommand = false;
                }
                RuleBehavior.prototype.finalize = function (processor, outputTarget) {
                    if (!this.transcription) {
                        throw "Cannot finalize a RuleBehavior with no transcription.";
                    }
                    if (processor.beepHandler && this.beep) {
                        processor.beepHandler(outputTarget);
                    }
                    for (var storeID in this.setStore) {
                        var sysStore = processor.keyboardInterface.systemStores[storeID];
                        if (sysStore) {
                            try {
                                sysStore.set(this.setStore[storeID]);
                            }
                            catch (error) {
                                if (processor.errorLogger) {
                                    processor.errorLogger("Rule attempted to perform illegal operation - 'platform' may not be changed.");
                                }
                            }
                        }
                        else if (processor.warningLogger) {
                            processor.warningLogger("Unknown store affected by keyboard rule: " + storeID);
                        }
                    }
                    if (processor.keyboardInterface.variableStoreSerializer) {
                        for (var storeID in this.saveStore) {
                            processor.keyboardInterface.variableStoreSerializer.saveStore(processor.activeKeyboard.id, storeID, this.saveStore[storeID]);
                        }
                    }
                    if (this.triggersDefaultCommand) {
                        var keyEvent = this.transcription.keystroke;
                        text.DefaultOutput.applyCommand(keyEvent, outputTarget);
                    }
                    if (processor.warningLogger && this.warningLog) {
                        processor.warningLogger(this.warningLog);
                    }
                    else if (processor.errorLogger && this.errorLog) {
                        processor.errorLogger(this.errorLog);
                    }
                };
                return RuleBehavior;
            }());
            text.RuleBehavior = RuleBehavior;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Establishes key-code definitions.
/// <reference path="codes.ts" />
// Defines our generalized "KeyEvent" class.
/// <reference path="keyEvent.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var EmulationKeystrokes;
            (function (EmulationKeystrokes) {
                EmulationKeystrokes["Enter"] = "\n";
                EmulationKeystrokes["Backspace"] = "\b";
            })(EmulationKeystrokes = text.EmulationKeystrokes || (text.EmulationKeystrokes = {}));
            /**
             * Defines a collection of static library functions that define KeymanWeb's default (implied) keyboard rule behaviors.
             */
            var DefaultOutput = /** @class */ (function () {
                function DefaultOutput() {
                }
                DefaultOutput.codeForEvent = function (Lkc) {
                    return text.Codes.keyCodes[Lkc.kName] || Lkc.Lcode;
                    ;
                };
                /**
                 * Serves as a default keycode lookup table.  This may be referenced safely by mnemonic handling without fear of side-effects.
                 * Also used by Processor.defaultRuleBehavior to generate output after filtering for special cases.
                 */
                DefaultOutput.forAny = function (Lkc, isMnemonic, ruleBehavior) {
                    var char = '';
                    // A pretty simple table of lookups, corresponding VERY closely to the original defaultKeyOutput.
                    if ((char = DefaultOutput.forSpecialEmulation(Lkc, ruleBehavior)) != null) {
                        return char;
                    }
                    else if (!isMnemonic && ((char = DefaultOutput.forNumpadKeys(Lkc, ruleBehavior)) != null)) {
                        return char;
                    }
                    else if ((char = DefaultOutput.forUnicodeKeynames(Lkc, ruleBehavior)) != null) {
                        return char;
                    }
                    else if ((char = DefaultOutput.forBaseKeys(Lkc, ruleBehavior)) != null) {
                        return char;
                    }
                    else {
                        // // For headless and embeddded, we may well allow '\t'.  It's DOM mode that has other uses.
                        // // Not originally defined for text output within defaultKeyOutput.
                        // // We can't enable it yet, as it'll cause hardware keystrokes in the DOM to output '\t' rather
                        // // than rely on the browser-default handling.
                        var code = DefaultOutput.codeForEvent(Lkc);
                        switch (code) {
                            //   case Codes.keyCodes['K_TAB']:
                            //   case Codes.keyCodes['K_TABBACK']:
                            //   case Codes.keyCodes['K_TABFWD']:
                            //     return '\t';
                            default:
                                return null;
                        }
                    }
                };
                /**
                 * isCommand - returns a boolean indicating if a non-text event should be triggered by the keystroke.
                 */
                DefaultOutput.isCommand = function (Lkc) {
                    var code = DefaultOutput.codeForEvent(Lkc);
                    switch (code) {
                        // Should we ever implement them:
                        // case Codes.keyCodes['K_LEFT']:  // would not output text, but would alter the caret's position in the context.
                        // case Codes.keyCodes['K_RIGHT']:
                        //   return true;
                        default:
                            return false;
                    }
                };
                /**
                 * Used when a RuleBehavior represents a non-text "command" within the Engine.  This will generally
                 * trigger events that require context reset - often by moving the caret or by moving what OutputTarget
                 * the caret is in.  However, we let those events perform the actual context reset.
                 *
                 * Note:  is extended by DOM-aware KeymanWeb code.
                 */
                DefaultOutput.applyCommand = function (Lkc, outputTarget) {
                    // Notes for potential default-handling extensions:
                    // 
                    // switch(code) {
                    // // Problem:  clusters, and doing them right.
                    // // The commented-out code below should be a decent starting point, but clusters make it complex.
                    // // Mostly based on pre-12.0 code, but the general idea should be relatively clear.
                    //
                    // case Codes.keyCodes['K_LEFT']:
                    //   if(touchAlias) {
                    //     var caretPos = keymanweb.getTextCaret(Lelem);
                    //     keymanweb.setTextCaret(Lelem, caretPos - 1 >= 0 ? caretPos - 1 : 0);
                    //   }
                    //   break;
                    // case Codes.keyCodes['K_RIGHT']:
                    //   if(touchAlias) {
                    //     var caretPos = keymanweb.getTextCaret(Lelem);
                    //     keymanweb.setTextCaret(Lelem, caretPos + 1);
                    //   }
                    //   if(code == VisualKeyboard.keyCodes['K_RIGHT']) {
                    //     break;
                    //   }
                    // }
                    //
                    // Note that these would be useful even outside of a DOM context.
                };
                /**
                 * Codes matched here generally have default implementations when in a browser but require emulation
                 * for 'synthetic' `OutputTarget`s like `Mock`s, which have no default text handling.
                 */
                DefaultOutput.forSpecialEmulation = function (Lkc, ruleBehavior) {
                    var code = DefaultOutput.codeForEvent(Lkc);
                    switch (code) {
                        case text.Codes.keyCodes['K_BKSP']:
                            return EmulationKeystrokes.Backspace;
                        case text.Codes.keyCodes['K_ENTER']:
                            return EmulationKeystrokes.Enter;
                        // case Codes.keyCodes['K_DEL']:
                        //   return '\u007f'; // 127, ASCII / Unicode control code for DEL.
                        default:
                            return null;
                    }
                };
                // Should not be used for mnenomic keyboards.  forAny()'s use of this method checks first.
                DefaultOutput.forNumpadKeys = function (Lkc, ruleBehavior) {
                    // Translate numpad keystrokes into their non-numpad equivalents
                    if (Lkc.Lcode >= text.Codes.keyCodes["K_NP0"] && Lkc.Lcode <= text.Codes.keyCodes["K_NPSLASH"]) {
                        // Number pad, numlock on
                        if (Lkc.Lcode < 106) {
                            var Lch = Lkc.Lcode - 48;
                        }
                        else {
                            Lch = Lkc.Lcode - 64;
                        }
                        var ch = String._kmwFromCharCode(Lch); //I3319
                        return ch;
                    }
                    else {
                        return null;
                    }
                };
                // Test for fall back to U_xxxxxx key id
                // For this first test, we ignore the keyCode and use the keyName
                DefaultOutput.forUnicodeKeynames = function (Lkc, ruleBehavior) {
                    var keyName = Lkc.kName;
                    // Test for fall back to U_xxxxxx key id
                    // For this first test, we ignore the keyCode and use the keyName
                    if (!keyName || keyName.substr(0, 2) != 'U_') {
                        return null;
                    }
                    var codePoint = parseInt(keyName.substr(2, 6), 16);
                    if (((0x0 <= codePoint) && (codePoint <= 0x1F)) || ((0x80 <= codePoint) && (codePoint <= 0x9F))) {
                        // Code points [U_0000 - U_001F] and [U_0080 - U_009F] refer to Unicode C0 and C1 control codes.
                        // Check the codePoint number and do not allow output of these codes via U_xxxxxx shortcuts.
                        if (ruleBehavior) {
                            ruleBehavior.errorLog = ("Suppressing Unicode control code: U_00" + codePoint.toString(16));
                        }
                        return null;
                    }
                    else {
                        // String.fromCharCode() is inadequate to handle the entire range of Unicode
                        // Someday after upgrading to ES2015, can use String.fromCodePoint()
                        return String.kmwFromCharCode(codePoint);
                    }
                };
                // Test for otherwise unimplemented keys on the the base default & shift layers.
                // Those keys must be blocked by keyboard rules if intentionally unimplemented; otherwise, this function will trigger.
                DefaultOutput.forBaseKeys = function (Lkc, ruleBehavior) {
                    var n = Lkc.Lcode;
                    var keyShiftState = Lkc.Lmodifiers;
                    // check if exact match to SHIFT's code.  Only the 'default' and 'shift' layers should have default key outputs.
                    // TODO:  Extend to allow AltGr as well - better mnemonic support.
                    if (keyShiftState == text.Codes.modifierCodes['SHIFT']) {
                        keyShiftState = 1;
                    }
                    else if (keyShiftState != 0) {
                        if (ruleBehavior) {
                            ruleBehavior.warningLog = "KMW only defines default key output for the 'default' and 'shift' layers!";
                        }
                        return null;
                    }
                    // Now that keyShiftState is either 0 or 1, we can use the following structure to determine the default output.
                    try {
                        if (n == text.Codes.keyCodes['K_SPACE']) {
                            return ' ';
                        }
                        else if (n >= text.Codes.keyCodes['K_0'] && n <= text.Codes.keyCodes['K_9']) { // The number keys.
                            return text.Codes.codesUS[keyShiftState][0][n - text.Codes.keyCodes['K_0']];
                        }
                        else if (n >= text.Codes.keyCodes['K_A'] && n <= text.Codes.keyCodes['K_Z']) { // The base letter keys
                            return String.fromCharCode(n + (keyShiftState ? 0 : 32)); // 32 is the offset from uppercase to lowercase.
                        }
                        else if (n >= text.Codes.keyCodes['K_COLON'] && n <= text.Codes.keyCodes['K_BKQUOTE']) {
                            return text.Codes.codesUS[keyShiftState][1][n - text.Codes.keyCodes['K_COLON']];
                        }
                        else if (n >= text.Codes.keyCodes['K_LBRKT'] && n <= text.Codes.keyCodes['K_QUOTE']) {
                            return text.Codes.codesUS[keyShiftState][2][n - text.Codes.keyCodes['K_LBRKT']];
                        }
                    }
                    catch (e) {
                        if (ruleBehavior) {
                            ruleBehavior.errorLog = "Error detected with default mapping for key:  code = " + n + ", shift state = " + (keyShiftState == 1 ? 'shift' : 'default');
                        }
                    }
                    return null;
                };
                return DefaultOutput;
            }());
            text.DefaultOutput = DefaultOutput;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 10.0
   Copyright 2017 SIL International
***/
// Relies on web-utils for version and deep-copy functionality.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var keyboards;
        (function (keyboards) {
            var Codes = com.keyman.text.Codes;
            // This class manages default layout construction for consumption by OSKs without a specified layout.
            var Layouts = /** @class */ (function () {
                function Layouts() {
                }
                /**
                * Build a default layout for keyboards with no explicit layout
                *
                * @param   {Object}  PVK         raw specifications
                * @param   {Keyboard} keyboard   keyboard object (as loaded)
                * @param   {string} formFactor   (really utils.FormFactor)
                * @return  {LayoutFormFactor}
                */
                Layouts.buildDefaultLayout = function (PVK, keyboard, formFactor) {
                    // Build a layout using the default for the device
                    var layoutType = formFactor;
                    if (typeof Layouts.dfltLayout[layoutType] != 'object') {
                        layoutType = 'desktop';
                    }
                    var kbdBitmask = Codes.modifierBitmasks['NON_CHIRAL'];
                    // An unfortunate dependency there.  Should probably also set a version within web-core for use.
                    var kbdDevVersion = keyman.utils.Version.CURRENT;
                    if (keyboard) {
                        kbdBitmask = keyboard.modifierBitmask;
                        kbdDevVersion = keyboard.compilerVersion;
                    }
                    if (!PVK) {
                        PVK = this.DEFAULT_RAW_SPEC;
                    }
                    // Clone the default layout object for this device
                    var layout = keyman.utils.deepCopy(Layouts.dfltLayout[layoutType]);
                    var n, layers = layout['layer'], keyLabels = PVK['KLS'], key102 = PVK['K102'];
                    var i, j, k, m, row, rows, key, keys;
                    var chiral = (kbdBitmask & Codes.modifierBitmasks.IS_CHIRAL) != 0;
                    var kmw10Plus = !(typeof keyLabels == 'undefined' || !keyLabels);
                    if (!kmw10Plus) {
                        // Save the processed key label information to the keyboard's general data.
                        // Makes things more efficient elsewhere and for reloading after keyboard swaps.
                        keyLabels = PVK['KLS'] = Layouts.processLegacyDefinitions(PVK['BK']);
                    }
                    // Identify key labels (e.g. *Shift*) that require the special OSK font
                    var specialLabel = /\*\w+\*/;
                    // *** Step 1:  instantiate the layer objects. ***
                    // Get the list of valid layers, enforcing that the 'default' layer must be the first one processed.
                    var validIdList = Object.getOwnPropertyNames(keyLabels), invalidIdList = [];
                    validIdList.splice(validIdList.indexOf('default'), 1);
                    validIdList = ['default'].concat(validIdList);
                    // Automatic AltGr emulation if the 'leftctrl-leftalt' layer is otherwise undefined.
                    if (keyboard && keyboard.emulatesAltGr) {
                        // We insert only the layers that need to be emulated.
                        if ((validIdList.indexOf('leftctrl-leftalt') == -1) && validIdList.indexOf('rightalt') != -1) {
                            validIdList.push('leftctrl-leftalt');
                            keyLabels['leftctrl-leftalt'] = keyLabels['rightalt'];
                        }
                        if ((validIdList.indexOf('leftctrl-leftalt-shift') == -1) && validIdList.indexOf('rightalt-shift') != -1) {
                            validIdList.push('leftctrl-leftalt-shift');
                            keyLabels['leftctrl-leftalt-shift'] = keyLabels['rightalt-shift'];
                        }
                    }
                    // If there is no predefined layout, even touch layouts will follow the desktop's
                    // setting for the displayUnderlying flag.  As the desktop layout uses a different
                    // format for its layout spec, that's found at the field referenced below.
                    layout["displayUnderlying"] = keyboard ? !!keyboard.scriptObject['KDU'] : false;
                    // For desktop devices, we must create all layers, even if invalid.
                    if (formFactor == 'desktop') {
                        invalidIdList = Layouts.generateLayerIds(chiral);
                        // Filter out all ids considered valid.  (We also don't want duplicates in the following list...)
                        for (n = 0; n < invalidIdList.length; n++) {
                            if (validIdList.indexOf(invalidIdList[n]) != -1) {
                                invalidIdList.splice(n--, 1);
                            }
                        }
                    }
                    // This ensures all 'valid' layers are at the front of the layer array and managed by the main loop below.
                    // 'invalid' layers aren't handled by the loop and thus remain blank after it.
                    var idList = validIdList.concat(invalidIdList);
                    if (kmw10Plus && formFactor != 'desktop') { // KLS exists, so we know the exact layer set.
                        // Find the SHIFT key...
                        var shiftKey = null;
                        rows = layers[0]['row'];
                        for (var r = 0; r < rows.length; r++) {
                            keys = rows[r]['key'];
                            for (var c = 0; c < keys.length; c++) {
                                key = keys[c];
                                if (key['id'] == 'K_SHIFT') {
                                    shiftKey = key;
                                }
                            }
                        }
                        if (shiftKey) {
                            // Erase the legacy shifted subkey array.
                            shiftKey['sk'] = [];
                            for (var layerID in keyLabels) {
                                if (layerID == 'default' || layerID == 'shift') {
                                    // These two are accessible from the layer without subkeys.
                                    continue;
                                }
                                // Create a new subkey for the specified layer so that it will be accessible via OSK.
                                var specialChar = Layouts.modifierSpecials[layerID];
                                var subkey = {
                                    id: "K_" + specialChar,
                                    text: specialChar,
                                    sp: "1",
                                    nextlayer: layerID
                                };
                                shiftKey['sk'].push(subkey);
                            }
                        }
                        else {
                            // Seriously, this should never happen.  It's here for the debugging log only.
                            console.warn("Error in default layout - cannot find default Shift key!");
                        }
                    }
                    for (n = 0; n < idList.length; n++) {
                        // Populate non-default (shifted) keygroups
                        if (n > 0) {
                            layers[n] = keyman.utils.deepCopy(layers[0]);
                        }
                        layers[n]['id'] = idList[n];
                        layers[n]['nextlayer'] = idList[n]; // This would only be different for a dynamic keyboard
                        // Extraced into a helper method to improve readability.
                        Layouts.formatDefaultLayer(layers[n], chiral, formFactor, !!key102);
                    }
                    // *** Step 2: Layer objects now exist; time to fill them with the appropriate key labels and key styles ***
                    for (n = 0; n < layers.length; n++) {
                        var layer = layers[n], kx, shiftKey = null, nextKey = null, allText = '';
                        var capsKey = null, numKey = null, scrollKey = null; // null if not in the OSK layout.
                        var layerSpec = keyLabels[layer['id']];
                        var isShift = layer['id'] == 'shift' ? 1 : 0;
                        var isDefault = layer['id'] == 'default' || isShift ? 1 : 0;
                        rows = layer['row'];
                        for (i = 0; i < rows.length; i++) {
                            keys = rows[i]['key'];
                            for (j = 0; j < keys.length; j++) {
                                key = keys[j];
                                kx = Layouts.dfltCodes.indexOf(key['id']);
                                // Only create keys for defined layers.  ('default' and 'shift' are always defined.)
                                if (layerSpec || isDefault) {
                                    // Get keycap text from visual keyboard array, if defined in keyboard
                                    if (layerSpec) {
                                        if (kx >= 0 && kx < layerSpec.length)
                                            key['text'] = layerSpec[kx];
                                    }
                                    // Legacy (pre 12.0) behavior:  fall back to US English keycap text as default for the base two layers
                                    // if a key cap is not otherwise defined. (Any intentional 'ghost' keys must be explicitly defined.)
                                    if (isDefault && kbdDevVersion.precedes(keyman.utils.Version.NO_DEFAULT_KEYCAPS)) {
                                        if (key['id'] != 'K_SPACE' && kx + 65 * isShift < Layouts.dfltText.length && key['text'] !== null) {
                                            key['text'] = key['text'] || Layouts.dfltText[kx + 65 * isShift];
                                        }
                                    }
                                }
                                // Leave any unmarked key caps as null strings
                                if (key['text'] !== null) {
                                    key['text'] = key['text'] || '';
                                }
                                // Detect important tracking keys.
                                switch (key['id']) {
                                    case "K_SHIFT":
                                        shiftKey = key;
                                        break;
                                    case "K_TAB":
                                        nextKey = key;
                                        break;
                                    case "K_CAPS":
                                        capsKey = key;
                                        break;
                                    case "K_NUMLOCK":
                                        numKey = key;
                                        break;
                                    case "K_SCROLL":
                                        scrollKey = key;
                                        break;
                                }
                                // Remove pop-up shift keys referencing invalid layers (Build 349)
                                if (key['sk'] != null) {
                                    for (k = 0; k < key['sk'].length; k++) {
                                        if (validIdList.indexOf(key['sk'][k]['nextlayer']) == -1) {
                                            key['sk'].splice(k--, 1);
                                        }
                                    }
                                    if (key['sk'].length == 0) {
                                        key['sk'] = null;
                                    }
                                }
                            }
                        }
                        // We're done with the layer keys initialization pass.  Time to do post-analysis layer-level init where necessary.
                        layer.shiftKey = shiftKey;
                        layer.capsKey = capsKey;
                        layer.numKey = numKey;
                        layer.scrollKey = scrollKey;
                        // Set modifier key appearance and behaviour for non-desktop devices using the default layout
                        if (formFactor != 'desktop') {
                            if (n > 0 && shiftKey != null) {
                                shiftKey['sp'] = Layouts.buttonClasses['SHIFT-ON'];
                                shiftKey['sk'] = null;
                                shiftKey['text'] = Layouts.modifierSpecials[layers[n].id] ? Layouts.modifierSpecials[layers[n].id] : "*Shift*";
                            }
                        }
                    }
                    return layout;
                };
                /**
             * Function     getLayerId
             * Scope        Private
             * @param       {number}      m     shift modifier code
             * @return      {string}            layer string from shift modifier code (desktop keyboards)
             * Description  Get name of layer from code, where the modifer order is determined by ascending bit-flag value.
             */
                Layouts.getLayerId = function (m) {
                    var modifierCodes = Codes.modifierCodes;
                    var s = '';
                    if (m == 0) {
                        return 'default';
                    }
                    else {
                        if (m & modifierCodes['LCTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'leftctrl';
                        }
                        if (m & modifierCodes['RCTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'rightctrl';
                        }
                        if (m & modifierCodes['LALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'leftalt';
                        }
                        if (m & modifierCodes['RALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'rightalt';
                        }
                        if (m & modifierCodes['SHIFT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'shift';
                        }
                        if (m & modifierCodes['CTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'ctrl';
                        }
                        if (m & modifierCodes['ALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'alt';
                        }
                        return s;
                    }
                };
                /**
                 * Generates a list of potential layer ids for the specified chirality mode.
                 *
                 * @param   {boolean}   chiral    // Does the keyboard use chiral modifiers or not?
                 */
                Layouts.generateLayerIds = function (chiral) {
                    var layerCnt, offset;
                    if (chiral) {
                        layerCnt = 32;
                        offset = 0x01;
                    }
                    else {
                        layerCnt = 8;
                        offset = 0x10;
                    }
                    var layerIds = [];
                    for (var i = 0; i < layerCnt; i++) {
                        layerIds.push(Layouts.getLayerId(i * offset));
                    }
                    return layerIds;
                };
                /**
                 * Sets a formatting property for the modifier keys when constructing a default layout for a keyboard.
                 *
                 * @param   {Object}    layer   // One layer specification
                 * @param   {boolean}   chiral  // Whether or not the keyboard uses chiral modifier information.
                 * @param   {string}    formFactor  // The form factor of the device the layout is being constructed for.
                 * @param   {boolean}   key102      // Whether or not the extended key 102 should be hidden.
                 */
                Layouts.formatDefaultLayer = function (layer, chiral, formFactor, key102) {
                    var layerId = layer['id'];
                    var buttonClasses = Layouts.buttonClasses;
                    // Correct appearance of state-dependent modifier keys according to group
                    for (var i = 0; i < layer['row'].length; i++) {
                        var row = layer['row'][i];
                        var keys = row['key'];
                        for (var j = 0; j < keys.length; j++) {
                            var key = keys[j];
                            switch (key['id']) {
                                case 'K_SHIFT':
                                case 'K_LSHIFT':
                                case 'K_RSHIFT':
                                    if (layerId.indexOf('shift') != -1) {
                                        key['sp'] = buttonClasses['SHIFT-ON'];
                                    }
                                    if (formFactor != 'desktop') {
                                        if (layerId != 'default') {
                                            key['nextlayer'] = 'default';
                                        }
                                        else {
                                            key['nextlayer'] = 'shift';
                                        }
                                    }
                                    break;
                                case 'K_LCTRL':
                                case 'K_LCONTROL':
                                    if (chiral) {
                                        if (layerId.indexOf('leftctrl') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_RCTRL':
                                case 'K_RCONTROL':
                                    if (chiral) {
                                        if (layerId.indexOf('rightctrl') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_CONTROL':
                                    if (layerId.indexOf('ctrl') != -1) {
                                        if (!chiral || (layerId.indexOf('leftctrl') != -1 && layerId.indexOf('rightctrl') != -1)) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                    }
                                    break;
                                case 'K_LALT':
                                    if (chiral) {
                                        if (layerId.indexOf('leftalt') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_RALT':
                                    if (chiral) {
                                        if (layerId.indexOf('rightalt') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_ALT':
                                    if (layerId.indexOf('alt') != -1) {
                                        if (!chiral || (layerId.indexOf('leftalt') != -1 && layerId.indexOf('rightalt') != -1)) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                    }
                                    break;
                                case 'K_oE2':
                                    if (typeof key102 == 'undefined' || !key102) {
                                        if (formFactor == 'desktop') {
                                            keys.splice(j--, 1);
                                            keys[0]['width'] = '200';
                                        }
                                        else {
                                            keys[j]['sp'] = buttonClasses['HIDDEN'];
                                        }
                                    }
                                    break;
                            }
                        }
                    }
                };
                /**
                 * Converts the legacy BK property from pre 10.0 into the KLS keyboard layer spec format,
                 * sparsifying it as possible to pre-emptively check invalid layers.
                 *
                 * @param   {Array}   BK      keyboard object (as loaded)
                 * @return  {Object}
                 */
                Layouts.processLegacyDefinitions = function (BK) {
                    //['default','shift','ctrl','shiftctrl','alt','shiftalt','ctrlalt','shiftctrlalt'];
                    var idList = Layouts.generateLayerIds(false); // Non-chiral.
                    var KLS = {};
                    // The old default:  eight auto-managed layers...
                    for (var n = 0; n < idList.length; n++) {
                        var id = idList[n], arr = [], valid = false;
                        // ... with keycode mappings in blocks of 65.
                        for (var k = 0; k < 65; k++) {
                            var index = k + 65 * n;
                            arr.push(BK[index]);
                            // The entry for K_SPACE's keycode tends to hold ' ' instead of '', which causes
                            // the whole layer to be treated as 'valid' if not included in the conditional.
                            if (index < BK.length && BK[index] != '' && k != Layouts.dfltCodes.indexOf('K_SPACE')) {
                                valid = true;
                            }
                        }
                        if (valid) {
                            KLS[id] = arr;
                        }
                    }
                    // There must always be at least a plain 'default' layer.  Array(65).fill('') would be preferable but isn't supported on IE,
                    // but buildDefaultLayer will set the defaults for these layers if no entry exists for them in the array due to length.
                    if (typeof KLS['default'] == 'undefined' || !KLS['default']) {
                        KLS['default'] = [''];
                    }
                    // There must always be at least a plain 'shift' layer.
                    if (typeof KLS['shift'] == 'undefined' || !KLS['shift']) {
                        KLS['shift'] = [''];
                    }
                    return KLS;
                };
                Layouts.dfltCodes = [
                    "K_BKQUOTE", "K_1", "K_2", "K_3", "K_4", "K_5", "K_6", "K_7", "K_8", "K_9", "K_0",
                    "K_HYPHEN", "K_EQUAL", "K_*", "K_*", "K_*", "K_Q", "K_W", "K_E", "K_R", "K_T",
                    "K_Y", "K_U", "K_I", "K_O", "K_P", "K_LBRKT", "K_RBRKT", "K_BKSLASH", "K_*",
                    "K_*", "K_*", "K_A", "K_S", "K_D", "K_F", "K_G", "K_H", "K_J", "K_K", "K_L",
                    "K_COLON", "K_QUOTE", "K_*", "K_*", "K_*", "K_*", "K_*", "K_oE2",
                    "K_Z", "K_X", "K_C", "K_V", "K_B", "K_N", "K_M", "K_COMMA", "K_PERIOD",
                    "K_SLASH", "K_*", "K_*", "K_*", "K_*", "K_*", "K_SPACE"
                ];
                Layouts.dfltText = '`1234567890-=\xA7~~qwertyuiop[]\\~~~asdfghjkl;\'~~~~~?zxcvbnm,./~~~~~ '
                    + '~!@#$%^&*()_+\xA7~~QWERTYUIOP{}\\~~~ASDFGHJKL:"~~~~~?ZXCVBNM<>?~~~~~ ';
                Layouts.DEFAULT_RAW_SPEC = { 'F': 'Tahoma', 'BK': Layouts.dfltText };
                // Cross-reference with the ids in osk.setButtonClass.
                Layouts.buttonClasses = {
                    'DEFAULT': '0',
                    'SHIFT': '1',
                    'SHIFT-ON': '2',
                    'SPECIAL': '3',
                    'SPECIAL-ON': '4',
                    'DEADKEY': '8',
                    'BLANK': '9',
                    'HIDDEN': '10'
                };
                Layouts.modifierSpecials = {
                    'leftalt': '*LAlt*',
                    'rightalt': '*RAlt*',
                    'alt': '*Alt*',
                    'leftctrl': '*LCtrl*',
                    'rightctrl': '*RCtrl*',
                    'ctrl': '*Ctrl*',
                    'ctrl-alt': '*AltGr*',
                    'leftctrl-leftalt': '*LAltCtrl*',
                    'rightctrl-rightalt': '*RAltCtrl*',
                    'leftctrl-leftalt-shift': '*LAltCtrlShift*',
                    'rightctrl-rightalt-shift': '*RAltCtrlShift*',
                    'shift': '*Shift*',
                    'shift-alt': '*AltShift*',
                    'shift-ctrl': '*CtrlShift*',
                    'shift-ctrl-alt': '*AltCtrlShift*',
                    'leftalt-shift': '*LAltShift*',
                    'rightalt-shift': '*RAltShift*',
                    'leftctrl-shift': '*LCtrlShift*',
                    'rightctrl-shift': '*RCtrlShift*'
                };
                // Defines the default visual layout for a keyboard.
                Layouts.dfltLayout = {
                    "desktop": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_BKQUOTE" },
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "sp": "1", "width": "130" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_TAB", "text": "*Tab*", "sp": "1", "width": "130" },
                                            { "id": "K_Q" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "id": "K_BKSLASH" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_CAPS", "text": "*Caps*", "sp": "1", "width": "165" },
                                            { "id": "K_A" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_ENTER", "text": "*Enter*", "sp": "1", "width": "165" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            { "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "130" },
                                            { "id": "K_oE2" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_RSHIFT", "text": "*Shift*", "sp": "1", "width": "130" }
                                        ]
                                    },
                                    {
                                        "id": "5",
                                        "key": [
                                            { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "170" },
                                            { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "160" },
                                            { "id": "K_SPACE", "text": "", "width": "770" },
                                            { "id": "K_RALT", "text": "*Alt*", "sp": "1", "width": "160" },
                                            { "id": "K_RCONTROL", "text": "*Ctrl*", "sp": "1", "width": "170" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    "tablet": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "0",
                                        "key": [
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_Q", "pad": "25" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_A", "pad": "50" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_BKSLASH", "width": "90" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_oE2", "width": "90" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_BKQUOTE" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            {
                                                "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "200", "sk": [
                                                    { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "50", "nextlayer": "ctrl" },
                                                    { "id": "K_LCONTROL", "text": "*LCtrl*", "sp": "1", "width": "50", "nextlayer": "leftctrl" },
                                                    { "id": "K_RCONTROL", "text": "*RCtrl*", "sp": "1", "width": "50", "nextlayer": "rightctrl" },
                                                    { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "50", "nextlayer": "alt" },
                                                    { "id": "K_LALT", "text": "*LAlt*", "sp": "1", "width": "50", "nextlayer": "leftalt" },
                                                    { "id": "K_RALT", "text": "*RAlt*", "sp": "1", "width": "50", "nextlayer": "rightalt" },
                                                    { "id": "K_ALTGR", "text": "*AltGr*", "sp": "1", "width": "50", "nextlayer": "ctrl-alt" }
                                                ]
                                            },
                                            { "id": "K_LOPT", "text": "*Menu*", "sp": "1", "width": "150" },
                                            { "id": "K_SPACE", "text": "", "width": "570" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "sp": "1", "width": "150" },
                                            { "id": "K_ENTER", "text": "*Enter*", "sp": "1", "width": "200" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    "phone": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "0",
                                        "key": [
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_Q", "pad": "25" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_A", "pad": "50" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_BKSLASH", "width": "90" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_oE2", "width": "90" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_BKQUOTE" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            {
                                                "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "200", "sk": [
                                                    { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "50", "nextlayer": "ctrl" },
                                                    { "id": "K_LCONTROL", "text": "*LCtrl*", "sp": "1", "width": "50", "nextlayer": "leftctrl" },
                                                    { "id": "K_RCONTROL", "text": "*RCtrl*", "sp": "1", "width": "50", "nextlayer": "rightctrl" },
                                                    { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "50", "nextlayer": "alt" },
                                                    { "id": "K_LALT", "text": "*LAlt*", "sp": "1", "width": "50", "nextlayer": "leftalt" },
                                                    { "id": "K_RALT", "text": "*RAlt*", "sp": "1", "width": "50", "nextlayer": "rightalt" },
                                                    { "id": "K_ALTGR", "text": "*AltGr*", "sp": "1", "width": "50", "nextlayer": "ctrl-alt" }
                                                ]
                                            },
                                            { "id": "K_LOPT", "text": "*Menu*", "width": "150", "sp": "1" },
                                            { "id": "K_SPACE", "width": "570", "text": "" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "width": "150", "sp": "1" },
                                            { "id": "K_ENTER", "text": "*Enter*", "width": "200", "sp": "1" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                };
                return Layouts;
            }());
            keyboards.Layouts = Layouts;
        })(keyboards = keyman.keyboards || (keyman.keyboards = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var keyboards;
        (function (keyboards) {
            var ActiveKey = /** @class */ (function () {
                function ActiveKey() {
                    this.isMnemonic = false;
                }
                Object.defineProperty(ActiveKey.prototype, "baseKeyID", {
                    // Keeping things simple here, as this was added LATE in 14.0 beta.
                    // Could definitely extend in the future to instead return an object
                    // that denotes the 'nature' of the key.
                    // - isUnicode
                    // - isHardwareKey
                    // - etc.
                    // Reference for the terminology in the comments below:
                    // https://help.keyman.com/developer/current-version/guides/develop/creating-a-touch-keyboard-layout-for-amharic-the-nitty-gritty
                    /**
                     * Matches the key code as set within Keyman Developer for the layout.
                     * For example, K_R or U_0020.  Denotes either physical keys or virtual keys with custom output,
                     * with no additional metadata like layer or active modifiers.
                     *
                     * Is used to determine the keycode for input events, rule-matching, and keystroke processing.
                     */
                    get: function () {
                        if (typeof this.id === 'undefined') {
                            return undefined;
                        }
                        return this.id;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ActiveKey.prototype, "coreID", {
                    /**
                     * A unique identifier based on both the key ID & the 'desktop layer' to be used for the key.
                     *
                     * Allows diambiguation of scenarios where the same key ID is used twice within a layer, but
                     * with different innate modifiers.  (Refer to https://github.com/keymanapp/keyman/issues/4617)
                     * The 'desktop layer' may be omitted if it matches the key's display layer.
                     *
                     * Examples, given a 'default' display layer, matching keys to Keyman keyboard language:
                     *
                     * ```
                     * "K_Q"
                     * + [K_Q]
                     * "K_Q+shift"
                     * + [K_Q SHIFT]
                     * ```
                     *
                     * Useful when the active layer of an input-event is already known.
                     */
                    get: function () {
                        if (typeof this.id === 'undefined') {
                            return undefined;
                        }
                        var baseID = this.id || '';
                        if (this.displayLayer != this.layer) {
                            baseID = baseID + '+' + this.layer;
                        }
                        return baseID;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ActiveKey.prototype, "elementID", {
                    /**
                     * A keyboard-unique identifier to be used for any display elements representing this key
                     * in user interfaces and/or on-screen keyboards.
                     *
                     * Distinguishes between otherwise-identical keys on different layers of an OSK.
                     * Includes identifying information about the key's display layer.
                     *
                     * Examples, given a 'default' display layer, matching keys to Keyman keyboard language:
                     *
                     * ```
                     * "default-K_Q"
                     * + [K_Q]
                     * "default-K_Q+shift"
                     * + [K_Q SHIFT]
                     * ```
                     *
                     * Useful when only the active keyboard is known about an input event.
                     */
                    get: function () {
                        if (typeof this.id === 'undefined') {
                            return undefined;
                        }
                        return this.displayLayer + '-' + this.coreID;
                    },
                    enumerable: true,
                    configurable: true
                });
                ActiveKey.polyfill = function (key, layout, displayLayer) {
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveKey();
                    var proto = Object.getPrototypeOf(dummy);
                    for (var prop in dummy) {
                        if (!key.hasOwnProperty(prop)) {
                            var descriptor = Object.getOwnPropertyDescriptor(proto, prop);
                            if (descriptor) {
                                // It's a computed property!  Copy the descriptor onto the key's object.
                                Object.defineProperty(key, prop, descriptor);
                            }
                            else {
                                key[prop] = dummy[prop];
                            }
                        }
                    }
                    // Ensure subkeys are also properly extended.
                    if (key.sk) {
                        for (var _i = 0, _a = key.sk; _i < _a.length; _i++) {
                            var subkey = _a[_i];
                            ActiveKey.polyfill(subkey, layout, displayLayer);
                        }
                    }
                    var aKey = key;
                    aKey.displayLayer = displayLayer;
                    aKey.layer = aKey.layer || displayLayer;
                    // Compute the key's base KeyEvent properties for use in future event generation
                    aKey.constructBaseKeyEvent(layout, displayLayer);
                };
                ActiveKey.prototype.constructBaseKeyEvent = function (layout, displayLayer) {
                    // Get key name and keyboard shift state (needed only for default layouts and physical keyboard handling)
                    // Note - virtual keys should be treated case-insensitive, so we force uppercasing here.
                    var layer = this.layer || displayLayer || '';
                    var keyName = this.id ? this.id.toUpperCase() : null;
                    // Start:  mirrors _GetKeyEventProperties
                    // Override key shift state if specified for key in layout (corrected for popup keys KMEW-93)
                    var keyShiftState = keyman.text.KeyboardProcessor.getModifierState(layer);
                    // First check the virtual key, and process shift, control, alt or function keys
                    var Lkc = {
                        Lmodifiers: keyShiftState,
                        Lstates: 0,
                        Lcode: keyName ? keyman.text.Codes.keyCodes[keyName] : 0,
                        LisVirtualKey: true,
                        vkCode: 0,
                        kName: keyName,
                        kLayer: layer,
                        kbdLayer: displayLayer,
                        kNextLayer: this.nextlayer,
                        device: null,
                        isSynthetic: true
                    };
                    if (layout.keyboard) {
                        var keyboard = layout.keyboard;
                        // Include *limited* support for mnemonic keyboards (Sept 2012)
                        // If a touch layout has been defined for a mnemonic keyout, do not perform mnemonic mapping for rules on touch devices.
                        if (keyboard.isMnemonic && !(layout.isDefault && layout.formFactor != 'desktop')) {
                            if (Lkc.Lcode != keyman.text.Codes.keyCodes['K_SPACE']) { // exception required, March 2013
                                // Jan 2019 - interesting that 'K_SPACE' also affects the caps-state check...
                                Lkc.vkCode = Lkc.Lcode;
                                this.isMnemonic = true;
                            }
                        }
                        else {
                            Lkc.vkCode = Lkc.Lcode;
                        }
                        // Support version 1.0 KeymanWeb keyboards that do not define positional vs mnemonic
                        if (!keyboard.definesPositionalOrMnemonic) {
                            // Not the best pattern, but currently safe - we don't look up any properties of any of the
                            // arguments in this use case, and the object's scope is extremely limited.
                            Lkc.Lcode = keyman.KeyMapping._USKeyCodeToCharCode(this.constructKeyEvent(null, null));
                            Lkc.LisVirtualKey = false;
                        }
                    }
                    this.baseKeyEvent = Lkc;
                };
                ActiveKey.prototype.constructKeyEvent = function (keyboardProcessor, device) {
                    // Make a deep copy of our preconstructed key event, filling it out from there.
                    var Lkc = keyman.utils.deepCopy(this.baseKeyEvent);
                    Lkc.device = device;
                    if (this.isMnemonic) {
                        keyman.text.KeyboardProcessor.setMnemonicCode(Lkc, this.layer.indexOf('shift') != -1, keyboardProcessor ? keyboardProcessor.stateKeys['K_CAPS'] : false);
                    }
                    // Performs common pre-analysis for both 'native' and 'embedded' OSK key & subkey input events.
                    // This part depends on the keyboard processor's active state.
                    if (keyboardProcessor) {
                        keyboardProcessor.setSyntheticEventDefaults(Lkc);
                    }
                    return Lkc;
                };
                ActiveKey.prototype.getSubkey = function (coreID) {
                    if (this.sk) {
                        for (var _i = 0, _a = this.sk; _i < _a.length; _i++) {
                            var key = _a[_i];
                            if (key.coreID == coreID) {
                                return key;
                            }
                        }
                    }
                    return null;
                };
                ActiveKey.DEFAULT_PAD = 15; // Padding to left of key, in virtual units
                ActiveKey.DEFAULT_RIGHT_MARGIN = 15; // Padding to right of right-most key, in virtual units
                ActiveKey.DEFAULT_KEY_WIDTH = 100; // Width of a key, if not specified, in virtual units
                // Defines key defaults
                ActiveKey.DEFAULT_KEY = {
                    text: '',
                    width: ActiveKey.DEFAULT_KEY_WIDTH.toString(),
                    sp: '0',
                    pad: ActiveKey.DEFAULT_PAD.toString()
                };
                return ActiveKey;
            }());
            keyboards.ActiveKey = ActiveKey;
            var ActiveRow = /** @class */ (function () {
                function ActiveRow() {
                }
                ActiveRow.polyfill = function (row, layout, displayLayer, totalWidth, proportionalY) {
                    // Apply defaults, setting the width and other undefined properties for each key
                    var keys = row['key'];
                    for (var j = 0; j < keys.length; j++) {
                        var key = keys[j];
                        for (var tp in ActiveKey.DEFAULT_KEY) {
                            if (typeof key[tp] != 'string') {
                                key[tp] = ActiveKey.DEFAULT_KEY[tp];
                            }
                        }
                        // Modify the key type for special keys with non-standard labels
                        // to allow the keyboard font to ovveride the SpecialOSK font.
                        // Blank keys are no longer reclassed - can use before/after CSS to add text
                        switch (key['sp']) {
                            case '1':
                                if (!ActiveRow.SPECIAL_LABEL.test(key['text']) && key['text'] != '') {
                                    key['sp'] = '3';
                                }
                                break;
                            case '2':
                                if (!ActiveRow.SPECIAL_LABEL.test(key['text']) && key['text'] != '') {
                                    key['sp'] = '4';
                                }
                                break;
                        }
                        ActiveKey.polyfill(key, layout, displayLayer);
                    }
                    /* The calculations here are effectively 'virtualized'.  When used with the OSK, the VisualKeyboard
                     * will overwrite these values with their true runtime geometry.
                     *
                     * These calculations approximate those of the actual OSK (without fitting to a specific resolution)
                     * and are intended for use with layout testing (while headless) in the future.
                     */
                    var setProportions = function (key, padPc, keyPc, totalPc) {
                        key.proportionalPad = padPc;
                        key.proportionalWidth = keyPc;
                        key.proportionalX = (totalPc + padPc + (keyPc / 2));
                    };
                    // Calculate percentage-based scalings by summing defined widths and scaling each key to %.
                    // Save each percentage key width as a separate member (do *not* overwrite layout specified width!)
                    var keyPercent, padPercent, totalPercent = 0;
                    for (var j = 0; j < keys.length - 1; j++) {
                        keyPercent = parseInt(keys[j]['width'], 10) / totalWidth;
                        keys[j]['widthpc'] = keyPercent;
                        padPercent = parseInt(keys[j]['pad'], 10) / totalWidth;
                        keys[j]['padpc'] = padPercent;
                        // compute center's default x-coord (used in headless modes)
                        setProportions(keys[j], padPercent, keyPercent, totalPercent);
                        totalPercent += padPercent + keyPercent;
                    }
                    // Allow for right OSK margin (15 layout units)
                    var rightMargin = ActiveKey.DEFAULT_RIGHT_MARGIN / totalWidth;
                    totalPercent += rightMargin;
                    // If a single key, and padding is negative, add padding to right align the key
                    if (keys.length == 1 && parseInt(keys[0]['pad'], 10) < 0) {
                        keyPercent = parseInt(keys[0]['width'], 10) / totalWidth;
                        keys[0]['widthpc'] = keyPercent;
                        totalPercent += keyPercent;
                        keys[0]['padpc'] = 1 - totalPercent;
                        // compute center's default x-coord (used in headless modes)
                        setProportions(keys[0], padPercent, keyPercent, totalPercent);
                    }
                    else if (keys.length > 0) {
                        var j = keys.length - 1;
                        padPercent = parseInt(keys[j]['pad'], 10) / totalWidth;
                        keys[j]['padpc'] = padPercent;
                        totalPercent += padPercent;
                        keys[j]['widthpc'] = keyPercent = 1 - totalPercent;
                        // compute center's default x-coord (used in headless modes)
                        setProportions(keys[j], padPercent, keyPercent, totalPercent);
                    }
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveRow();
                    for (var key in dummy) {
                        if (!row.hasOwnProperty(key)) {
                            row[key] = dummy[key];
                        }
                    }
                    var aRow = row;
                    aRow.proportionalY = proportionalY;
                };
                ActiveRow.prototype.populateKeyMap = function (map) {
                    this.key.forEach(function (key) {
                        if (key.coreID) {
                            map[key.coreID] = key;
                        }
                    });
                };
                // Identify key labels (e.g. *Shift*) that require the special OSK font
                ActiveRow.SPECIAL_LABEL = /\*\w+\*/;
                return ActiveRow;
            }());
            var ActiveLayer = /** @class */ (function () {
                function ActiveLayer() {
                }
                ActiveLayer.polyfill = function (layer, layout) {
                    layer.aligned = false;
                    // Create a DIV for each row of the group
                    var rows = layer['row'];
                    // Calculate the maximum row width (in layout units)
                    var totalWidth = 0;
                    for (var i = 0; i < layer['row'].length; i++) {
                        var width = 0;
                        var row = rows[i];
                        var keys = row['key'];
                        for (var j = 0; j < keys.length; j++) {
                            var key = keys[j];
                            // Test for a trailing comma included in spec, added as null object by IE
                            if (key == null) {
                                keys.length = keys.length - 1;
                            }
                            else {
                                var kw, kp;
                                kw = (typeof key['width'] == 'string' && key['width'] != '') ? parseInt(key['width'], 10) : ActiveKey.DEFAULT_KEY_WIDTH;
                                if (isNaN(kw) || kw == 0)
                                    kw = ActiveKey.DEFAULT_KEY_WIDTH;
                                key['width'] = kw.toString();
                                kp = (typeof key['pad'] == 'string' && key['pad'] != '') ? parseInt(key['pad'], 10) : ActiveKey.DEFAULT_PAD;
                                if (isNaN(kp) || kp == 0)
                                    kp = ActiveKey.DEFAULT_PAD; // KMEW-119
                                key['pad'] = kp.toString();
                                width += kw + kp;
                                //if(typeof key['width'] == 'string' && key['width'] != '') width += parseInt(key['width'],10); else width += DEFAULT_KEY_WIDTH;
                                //if(typeof key['pad'] == 'string' && key['pad'] != '') width += parseInt(key['pad'],10); else width += 5;
                            }
                        }
                        if (width > totalWidth) {
                            totalWidth = width;
                        }
                    }
                    // Add default right margin
                    if (layout.formFactor == 'desktop') {
                        totalWidth += 5; // TODO: resolve difference between touch and desktop; why don't we use ActiveKey.DEFAULT_RIGHT_MARGIN?
                    }
                    else {
                        totalWidth += ActiveKey.DEFAULT_RIGHT_MARGIN;
                    }
                    var rowCount = layer.row.length;
                    for (var i = 0; i < rowCount; i++) {
                        // Calculate proportional y-coord of row.  0 is at top with highest y-coord.
                        var rowProportionalY = (i + 0.5) / rowCount;
                        ActiveRow.polyfill(layer.row[i], layout, layer.id, totalWidth, rowProportionalY);
                    }
                    // Add class functions and properties to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveLayer();
                    for (var key in dummy) {
                        if (!layer.hasOwnProperty(key)) {
                            layer[key] = dummy[key];
                        }
                    }
                    var aLayer = layer;
                    aLayer.totalWidth = totalWidth;
                    aLayer.defaultKeyProportionalWidth = parseInt(ActiveKey.DEFAULT_KEY.width, 10) / totalWidth;
                    aLayer.rowProportionalHeight = 1.0 / rowCount;
                    aLayer.keyMap = aLayer.constructKeyMap();
                };
                ActiveLayer.prototype.constructKeyMap = function () {
                    var map = {};
                    this.row.forEach(function (row) {
                        row.populateKeyMap(map);
                    });
                    return map;
                };
                /**
                 * Builds a sorted-order array of most likely keys to be intended for a given touch.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.getTouchProbabilities = function (touchCoords, kbdScaleRatio) {
                    var distribution = this.simpleTouchDistribution(touchCoords, kbdScaleRatio);
                    var list = [];
                    for (var key in distribution) {
                        list.push({ keyId: key, p: distribution[key] });
                    }
                    return list.sort(function (a, b) {
                        return b.p - a.p; // Largest probability keys should be listed first.
                    });
                };
                /**
                 * Computes a probability distribution regarding the likelihood of a touch command being intended
                 * for each of the layout's keys.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.simpleTouchDistribution = function (touchCoords, kbdScaleRatio) {
                    var keyDists = this.keyTouchDistances(touchCoords, kbdScaleRatio);
                    var keyProbs = {};
                    var totalMass = 0;
                    // Should we wish to allow multiple different transforms for distance -> probability, use a function parameter in place
                    // of the formula in the loop below.
                    for (var key in keyDists) {
                        totalMass += keyProbs[key] = 1 / (keyDists[key] + 1e-6); // Prevent div-by-0 errors.
                    }
                    for (var key in keyProbs) {
                        keyProbs[key] /= totalMass;
                    }
                    return keyProbs;
                };
                /**
                 * Computes a squared 'pseudo-distance' for the touch from each key.  (Not a proper metric.)
                 * Intended for use in generating a probability distribution over the keys based on the touch input.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.keyTouchDistances = function (touchCoords, kbdScaleRatio) {
                    var layer = this;
                    var keyDists = {};
                    // This double-nested loop computes a pseudo-distance for the touch from each key.  Quite useful for
                    // generating a probability distribution.
                    this.row.forEach(function (row) {
                        row.key.forEach(function (key) {
                            // If the key lacks an ID, just skip it.  Sometimes used for padding.
                            if (!key.baseKeyID) {
                                return;
                            }
                            else {
                                // Attempt to filter out known non-output keys.
                                // Results in a more optimized distribution.
                                switch (key.baseKeyID) {
                                    case 'K_SHIFT':
                                    case 'K_LOPT':
                                    case 'K_ROPT':
                                    case 'K_NUMLOCK': // Often used for numeric layers.
                                    case 'K_CAPS':
                                        // As these aren't output keys, they shouldn't be possible fat-finger targets.
                                        return;
                                    default:
                                        // Refer to text/codes.ts - these are Keyman-custom "keycodes" used for
                                        // layer shifting keys.  To be safe, we currently let K_TABBACK and 
                                        // K_TABFWD through, though we might be able to drop them too.
                                        var code = com.keyman.text.Codes[key.baseKeyID];
                                        if (code > 50000 && code < 50011) {
                                            return;
                                        }
                                }
                            }
                            // These represent the within-key distance of the touch from the key's center.
                            // Both should be on the interval [0, 0.5].
                            var dx = Math.abs(touchCoords.x - key.proportionalX);
                            var dy = Math.abs(touchCoords.y - row.proportionalY);
                            // If the touch isn't within the key, these store the out-of-key distance
                            // from the closest point on the key being checked.
                            var distX, distY;
                            if (dx > 0.5 * key.proportionalWidth) {
                                distX = (dx - 0.5 * key.proportionalWidth);
                                dx = 0.5;
                            }
                            else {
                                distX = 0;
                                dx /= key.proportionalWidth;
                            }
                            if (dy > 0.5 * layer.rowProportionalHeight) {
                                distY = (dy - 0.5 * layer.rowProportionalHeight);
                                dy = 0.5;
                            }
                            else {
                                distY = 0;
                                dy /= layer.rowProportionalHeight;
                            }
                            // Now that the differentials are computed, it's time to do distance scaling.
                            //
                            // For out-of-key distance, we scale the X component by the keyboard's aspect ratio
                            // to get the actual out-of-key distance rather than proportional.
                            distX *= kbdScaleRatio;
                            // While the keys are rarely perfect squares, we map all within-key distance
                            // to a square shape.  (ALT/CMD should seem as close to SPACE as a 'B'.)
                            //
                            // For that square, we take the rowHeight as its edge lengths.
                            distX += dx * layer.rowProportionalHeight;
                            distY += dy * layer.rowProportionalHeight;
                            var distance = distX * distX + distY * distY;
                            keyDists[key.coreID] = distance;
                        });
                    });
                    return keyDists;
                };
                ActiveLayer.prototype.getKey = function (keyId) {
                    // Keys usually are specified in a "long form" prefixed with their layer's ID.
                    if (keyId.indexOf(this.id + '-') == 0) {
                        keyId = keyId.replace(this.id + '-', '');
                    }
                    var idComponents = keyId.split('::');
                    if (idComponents.length > 1) {
                        var baseKey = this.keyMap[idComponents[0]];
                        return baseKey.getSubkey(idComponents[1]);
                    }
                    else {
                        return this.keyMap[keyId];
                    }
                };
                return ActiveLayer;
            }());
            keyboards.ActiveLayer = ActiveLayer;
            var ActiveLayout = /** @class */ (function () {
                function ActiveLayout() {
                }
                ActiveLayout.prototype.getLayer = function (layerId) {
                    return this.layerMap[layerId];
                };
                /**
                 *
                 * @param layout
                 * @param formFactor
                 */
                ActiveLayout.polyfill = function (layout, keyboard, formFactor) {
                    if (layout == null) {
                        throw new Error("Cannot build an ActiveLayout for a null specification.");
                    }
                    // Create a separate OSK div for each OSK layer, only one of which will ever be visible
                    var n, i;
                    var layers, layer;
                    var layerMap = {};
                    var rows;
                    layers = layout['layer'];
                    // ***Delete any empty rows at the end added by compiler bug...
                    for (n = 0; n < layers.length; n++) {
                        layer = layers[n];
                        rows = layer['row'];
                        for (i = rows.length; i > 0; i--) {
                            if (rows[i - 1]['key'].length > 0) {
                                break;
                            }
                        }
                        if (i < rows.length) {
                            rows.splice(i - rows.length, rows.length - i);
                        }
                    }
                    // ...remove to here when compiler bug fixed ***
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveLayout();
                    for (var key in dummy) {
                        if (!layout.hasOwnProperty(key)) {
                            layout[key] = dummy[key];
                        }
                    }
                    var aLayout = layout;
                    aLayout.keyboard = keyboard;
                    aLayout.formFactor = formFactor;
                    for (n = 0; n < layers.length; n++) {
                        ActiveLayer.polyfill(layers[n], aLayout);
                        layerMap[layers[n].id] = layers[n];
                    }
                    aLayout.layerMap = layerMap;
                    return aLayout;
                };
                return ActiveLayout;
            }());
            keyboards.ActiveLayout = ActiveLayout;
        })(keyboards = keyman.keyboards || (keyman.keyboards = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            /**
             * Defines common behaviors associated with system stores.
             */
            var SystemStore = /** @class */ (function () {
                function SystemStore(id) {
                    this.id = id;
                }
                SystemStore.prototype.set = function (value) {
                    throw new Error("System store with ID " + this.id + " may not be directly set.");
                };
                return SystemStore;
            }());
            text.SystemStore = SystemStore;
            var MutableSystemStore = /** @class */ (function (_super) {
                __extends(MutableSystemStore, _super);
                function MutableSystemStore(id, defaultValue) {
                    var _this = _super.call(this, id) || this;
                    _this.handler = null;
                    _this._value = defaultValue;
                    return _this;
                }
                Object.defineProperty(MutableSystemStore.prototype, "value", {
                    get: function () {
                        return this._value;
                    },
                    enumerable: true,
                    configurable: true
                });
                MutableSystemStore.prototype.matches = function (value) {
                    return this._value == value;
                };
                MutableSystemStore.prototype.set = function (value) {
                    if (this.handler) {
                        if (this.handler(this, value)) {
                            return;
                        }
                    }
                    this._value = value;
                };
                return MutableSystemStore;
            }(SystemStore));
            text.MutableSystemStore = MutableSystemStore;
            /**
             * Handles checks against the current platform.
             */
            var PlatformSystemStore = /** @class */ (function (_super) {
                __extends(PlatformSystemStore, _super);
                function PlatformSystemStore(keyboardInterface) {
                    var _this = _super.call(this, text.KeyboardInterface.TSS_PLATFORM) || this;
                    _this.kbdInterface = keyboardInterface;
                    return _this;
                }
                PlatformSystemStore.prototype.matches = function (value) {
                    var i, constraint, constraints = value.split(' ');
                    var device = this.kbdInterface.activeDevice;
                    for (i = 0; i < constraints.length; i++) {
                        constraint = constraints[i].toLowerCase();
                        switch (constraint) {
                            case 'touch':
                            case 'hardware':
                                if (device.touchable != (constraint == 'touch')) {
                                    return false;
                                }
                                break;
                            case 'macos':
                            case 'mac':
                                constraint = 'macosx';
                            // fall through
                            case 'macosx':
                            case 'windows':
                            case 'android':
                            case 'ios':
                            case 'linux':
                                if (device.OS != constraint) {
                                    return false;
                                }
                                break;
                            case 'tablet':
                            case 'phone':
                            case 'desktop':
                                if (device.formFactor != constraint) {
                                    return false;
                                }
                                break;
                            case 'web':
                                if (device.browser == 'native') {
                                    return false; // web matches anything other than 'native'
                                }
                                break;
                            case 'native':
                            // This will return true for embedded KeymanWeb
                            case 'ie':
                            case 'chrome':
                            case 'firefox':
                            case 'safari':
                            case 'edge':
                            case 'opera':
                                if (device.browser != constraint) {
                                    return false;
                                }
                                break;
                            default:
                                return false;
                        }
                    }
                    // Everything we checked against was valid and had matches - it's a match!
                    return true;
                };
                return PlatformSystemStore;
            }(SystemStore));
            text.PlatformSystemStore = PlatformSystemStore;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="deadkeys.ts" />
/// <reference path="ruleBehavior.ts" />
// Defines classes for handling system stores
/// <reference path="systemStores.ts" />
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            //#region Helper type definitions
            var KeyInformation = /** @class */ (function () {
                function KeyInformation() {
                }
                return KeyInformation;
            }());
            text.KeyInformation = KeyInformation;
            var RuleDeadkey = /** @class */ (function () {
                function RuleDeadkey() {
                }
                return RuleDeadkey;
            }());
            var ContextAny = /** @class */ (function () {
                function ContextAny() {
                }
                return ContextAny;
            }());
            var RuleIndex = /** @class */ (function () {
                function RuleIndex() {
                }
                return RuleIndex;
            }());
            var ContextEx = /** @class */ (function () {
                function ContextEx() {
                }
                return ContextEx;
            }());
            var ContextNul = /** @class */ (function () {
                function ContextNul() {
                }
                return ContextNul;
            }());
            var StoreBeep = /** @class */ (function () {
                function StoreBeep() {
                }
                return StoreBeep;
            }());
            /**
             * Cache of context storing and retrieving return values from KC
             * Must be reset prior to each keystroke and after any text changes
             * MCD 3/1/14
             **/
            var CachedContext = /** @class */ (function () {
                function CachedContext() {
                }
                CachedContext.prototype.reset = function () {
                    this._cache = [];
                };
                CachedContext.prototype.get = function (n, ln) {
                    // return null; // uncomment this line to disable context caching
                    if (typeof this._cache[n] == 'undefined') {
                        return null;
                    }
                    else if (typeof this._cache[n][ln] == 'undefined') {
                        return null;
                    }
                    return this._cache[n][ln];
                };
                CachedContext.prototype.set = function (n, ln, val) {
                    if (typeof this._cache[n] == 'undefined') {
                        this._cache[n] = [];
                    }
                    this._cache[n][ln] = val;
                };
                return CachedContext;
            }());
            ;
            /**
             * An extended version of cached context storing designed to work with
             * `fullContextMatch` and its helper functions.
             */
            var CachedContextEx = /** @class */ (function () {
                function CachedContextEx() {
                }
                CachedContextEx.prototype.reset = function () {
                    this._cache = [];
                };
                CachedContextEx.prototype.get = function (n, ln) {
                    // return null; // uncomment this line to disable context caching
                    if (typeof this._cache[n] == 'undefined') {
                        return null;
                    }
                    else if (typeof this._cache[n][ln] == 'undefined') {
                        return null;
                    }
                    return this._cache[n][ln];
                };
                CachedContextEx.prototype.set = function (n, ln, val) {
                    if (typeof this._cache[n] == 'undefined') {
                        this._cache[n] = [];
                    }
                    this._cache[n][ln] = val;
                };
                CachedContextEx.prototype.clone = function () {
                    var r = new CachedContextEx();
                    r._cache = this._cache;
                    return r;
                };
                return CachedContextEx;
            }());
            ;
            //#endregion
            var KeyboardInterface = /** @class */ (function () {
                function KeyboardInterface(variableStoreSerializer) {
                    if (variableStoreSerializer === void 0) { variableStoreSerializer = null; }
                    this.cachedContext = new CachedContext();
                    this.cachedContextEx = new CachedContextEx();
                    this._AnyIndices = []; // AnyIndex - array of any/index match indices
                    this.systemStores = {};
                    this.systemStores[KeyboardInterface.TSS_PLATFORM] = new text.PlatformSystemStore(this);
                    this.systemStores[KeyboardInterface.TSS_LAYER] = new text.MutableSystemStore(KeyboardInterface.TSS_LAYER, 'default');
                    this.variableStoreSerializer = variableStoreSerializer;
                }
                /**
                 * Function     KSF
                 * Scope        Public
                 *
                 * Saves the document's current focus settings on behalf of the keyboard.  Often paired with insertText.
                 */
                KeyboardInterface.prototype.saveFocus = function () { };
                /**
                 * Function     registerKeyboard  KR
                 * Scope        Public
                 * @param       {Object}      Pk      Keyboard  object
                 * Description  Registers a keyboard with KeymanWeb once its script has fully loaded.
                 *
                 *              In web-core, this also activates the keyboard; in other modules, this method
                 *              may be replaced with other implementations.
                 */
                KeyboardInterface.prototype.registerKeyboard = function (Pk) {
                    // NOTE:  This implementation is web-core specific and is intentionally replaced, whole-sale,
                    //        by DOM-aware code.
                    var keyboard = new keyman.keyboards.Keyboard(Pk);
                    this.activeKeyboard = keyboard;
                };
                /**
                 * Get *cached or uncached* keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {string}              Context string
                 *
                 * Example     [abcdef|ghi] as INPUT, with the caret position marked by |:
                 *             KC(2,1,Pelem) == "e"
                 *             KC(3,3,Pelem) == "def"
                 *             KC(10,10,Pelem) == "abcdef"  i.e. return as much as possible of the requested string
                 */
                KeyboardInterface.prototype.context = function (n, ln, outputTarget) {
                    var v = this.cachedContext.get(n, ln);
                    if (v !== null) {
                        return v;
                    }
                    var r = this.KC_(n, ln, outputTarget);
                    this.cachedContext.set(n, ln, r);
                    return r;
                };
                /**
                 * Get (uncached) keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {string}              Context string
                 *
                 * Example     [abcdef|ghi] as INPUT, with the caret position marked by |:
                 *             KC(2,1,Pelem) == "e"
                 *             KC(3,3,Pelem) == "def"
                 *             KC(10,10,Pelem) == "XXXXabcdef"  i.e. return as much as possible of the requested string, where X = \uFFFE
                 */
                KeyboardInterface.prototype.KC_ = function (n, ln, outputTarget) {
                    var tempContext = '';
                    tempContext = outputTarget.getTextBeforeCaret();
                    if (tempContext._kmwLength() < n) {
                        tempContext = Array(n - tempContext._kmwLength() + 1).join("\uFFFE") + tempContext;
                    }
                    return tempContext._kmwSubstr(-n)._kmwSubstr(0, ln);
                };
                /**
                 * Function     nul           KN
                 * Scope        Public
                 * @param       {number}      n       Length of context to check
                 * @param       {Object}      Ptarg   Element to work with (must be currently focused element)
                 * @return      {boolean}             True if length of context is less than or equal to n
                 * Description  Test length of context, return true if the length of the context is less than or equal to n
                 *
                 * Example     [abc|def] as INPUT, with the caret position marked by |:
                 *             KN(3,Pelem) == TRUE
                 *             KN(2,Pelem) == FALSE
                 *             KN(4,Pelem) == TRUE
                 */
                KeyboardInterface.prototype.nul = function (n, outputTarget) {
                    var cx = this.context(n + 1, 1, outputTarget);
                    // With #31, the result will be a replacement character if context is empty.
                    return cx === "\uFFFE";
                };
                /**
                 * Function     contextMatch  KCM
                 * Scope        Public
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {Object}      Ptarg   Focused element
                 * @param       {string}      val     String to match
                 * @param       {number}      ln      Number of characters to return
                 * @return      {boolean}             True if selected context matches val
                 * Description  Test keyboard context for match
                 */
                KeyboardInterface.prototype.contextMatch = function (n, outputTarget, val, ln) {
                    var cx = this.context(n, ln, outputTarget);
                    if (cx === val) {
                        return true; // I3318
                    }
                    outputTarget.deadkeys().resetMatched(); // I3318
                    return false;
                };
                /**
                 * Builds the *cached or uncached* keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {Array}               Context array (of strings and numbers)
                 */
                KeyboardInterface.prototype._BuildExtendedContext = function (n, ln, outputTarget) {
                    var cache = this.cachedContextEx.get(n, ln);
                    if (cache !== null) {
                        return cache;
                    }
                    else {
                        // By far the easiest way to correctly build what we want is to start from the right and work to what we need.
                        // We may have done it for a similar cursor position before.
                        cache = this.cachedContextEx.get(n, n);
                        if (cache === null) {
                            // First, let's make sure we have a cloned, sorted copy of the deadkey array.
                            var unmatchedDeadkeys = outputTarget.deadkeys().toSortedArray(); // Is reverse-order sorted for us already.
                            // Time to build from scratch!
                            var index = 0;
                            cache = { valContext: [], deadContext: [] };
                            while (cache.valContext.length < n) {
                                // As adapted from `deadkeyMatch`.
                                var sp = outputTarget.getDeadkeyCaret();
                                var deadPos = sp - index;
                                if (unmatchedDeadkeys.length > 0 && unmatchedDeadkeys[0].p > deadPos) {
                                    // We have deadkeys at the right-hand side of the caret!  They don't belong in the context, so pop 'em off.
                                    unmatchedDeadkeys.splice(0, 1);
                                    continue;
                                }
                                else if (unmatchedDeadkeys.length > 0 && unmatchedDeadkeys[0].p == deadPos) {
                                    // Take the deadkey.
                                    cache.deadContext[n - cache.valContext.length - 1] = unmatchedDeadkeys[0];
                                    cache.valContext = [unmatchedDeadkeys[0].d].concat(cache.valContext);
                                    unmatchedDeadkeys.splice(0, 1);
                                }
                                else {
                                    // Take the character.  We get "\ufffe" if it doesn't exist.
                                    var kc = this.context(++index, 1, outputTarget);
                                    cache.valContext = [kc].concat(cache.valContext);
                                }
                            }
                            this.cachedContextEx.set(n, n, cache);
                        }
                        // Now that we have the cache...
                        var subCache = cache;
                        subCache.valContext = subCache.valContext.slice(0, ln);
                        for (var i = 0; i < subCache.valContext.length; i++) {
                            if (subCache[i] == '\ufffe') {
                                subCache.valContext.splice(0, 1);
                                subCache.deadContext.splice(0, 1);
                            }
                        }
                        if (subCache.valContext.length == 0) {
                            subCache.valContext = ['\ufffe'];
                            subCache.deadContext = [];
                        }
                        this.cachedContextEx.set(n, ln, subCache);
                        return subCache;
                    }
                };
                /**
                 * Function       fullContextMatch    KFCM
                 * Scope          Private
                 * @param         {number}    n       Number of characters to move back from caret
                 * @param         {Object}    Ptarg   Focused element
                 * @param         {Array}     rule    An array of ContextEntries to match.
                 * @return        {boolean}           True if the fully-specified rule context matches the current KMW state.
                 *
                 * A KMW 10+ function designed to bring KMW closer to Keyman Desktop functionality,
                 * near-directly modeling (externally) the compiled form of Desktop rules' context section.
                 */
                KeyboardInterface.prototype.fullContextMatch = function (n, outputTarget, rule) {
                    // Stage one:  build the context index map.
                    var fullContext = this._BuildExtendedContext(n, rule.length, outputTarget);
                    this.ruleContextEx = this.cachedContextEx.clone();
                    var context = fullContext.valContext;
                    var deadContext = fullContext.deadContext;
                    var mismatch = false;
                    // This symbol internally indicates lack of context in a position.  (See KC_)
                    var NUL_CONTEXT = "\uFFFE";
                    var assertNever = function (x) {
                        // Could be accessed by improperly handwritten calls to `fullContextMatch`.
                        throw new Error("Unexpected object in fullContextMatch specification: " + x);
                    };
                    // Stage two:  time to match against the rule specified.
                    for (var i = 0; i < rule.length; i++) {
                        if (typeof rule[i] == 'string') {
                            var str = rule[i];
                            if (str !== context[i]) {
                                mismatch = true;
                                break;
                            }
                        }
                        else {
                            // TypeScript needs a cast to this intermediate type to do its discriminated union magic.
                            var r = rule[i];
                            switch (r.t) {
                                case 'd':
                                    // We still need to set a flag here;
                                    if (r['d'] !== context[i]) {
                                        mismatch = true;
                                    }
                                    else {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'a':
                                    var lookup;
                                    if (typeof context[i] == 'string') {
                                        lookup = context[i];
                                    }
                                    else {
                                        lookup = { 't': 'd', 'd': context[i] };
                                    }
                                    var result = this.any(i, lookup, r.a);
                                    if (!r.n) { // If it's a standard 'any'...
                                        if (!result) {
                                            mismatch = true;
                                        }
                                        else if (deadContext[i] !== undefined) {
                                            // It's a deadkey match, so indicate that.
                                            deadContext[i].set();
                                        }
                                        // 'n' for 'notany'.
                                        // - if `result === true`, `any` would match:  this should thus fail.
                                        // - if `context[i] === NUL_CONTEXT`, `notany` should not match.
                                    }
                                    else if (r.n && (result || context[i] === NUL_CONTEXT)) {
                                        mismatch = true;
                                    }
                                    break;
                                case 'i':
                                    // The context will never hold a 'beep.'
                                    var ch = this._Index(r.i, r.o);
                                    if (ch !== undefined && (typeof (ch) == 'string' ? ch : ch.d) !== context[i]) {
                                        mismatch = true;
                                    }
                                    else if (deadContext[i] !== undefined) {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'c':
                                    if (context[r.c - 1] !== context[i]) {
                                        mismatch = true;
                                    }
                                    else if (deadContext[i] !== undefined) {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'n':
                                    // \uFFFE is the internal 'no context here sentinel'.
                                    if (context[i] != NUL_CONTEXT) {
                                        mismatch = true;
                                    }
                                    break;
                                default:
                                    assertNever(r);
                            }
                        }
                    }
                    if (mismatch) {
                        // Reset the matched 'any' indices, if any.
                        outputTarget.deadkeys().resetMatched();
                        this._AnyIndices = [];
                    }
                    return !mismatch;
                };
                /**
                 * Function     KIK
                 * Scope        Public
                 * @param       {Object}  e   keystroke event
                 * @return      {boolean}     true if keypress event
                 * Description  Test if event as a keypress event
                 */
                KeyboardInterface.prototype.isKeypress = function (e) {
                    if (this.activeKeyboard.isMnemonic) { // I1380 - support KIK for positional layouts
                        return !e.LisVirtualKey; // will now return true for U_xxxx keys, but not for T_xxxx keys
                    }
                    else {
                        return keyman.KeyMapping._USKeyCodeToCharCode(e) ? true : false; // I1380 - support KIK for positional layouts
                    }
                };
                /**
                 * Function     keyMatch      KKM
                 * Scope        Public
                 * @param       {Object}      e           keystroke event
                 * @param       {number}      Lruleshift
                 * @param       {number}      Lrulekey
                 * @return      {boolean}                 True if key matches rule
                 * Description  Test keystroke with modifiers against rule
                 */
                KeyboardInterface.prototype.keyMatch = function (e, Lruleshift, Lrulekey) {
                    var retVal = false; // I3318
                    var keyCode = (e.Lcode == 173 ? 189 : e.Lcode); //I3555 (Firefox hyphen issue)
                    var bitmask = this.activeKeyboard.modifierBitmask;
                    var Codes = com.keyman.text.Codes;
                    var modifierBitmask = bitmask & Codes.modifierBitmasks["ALL"];
                    var stateBitmask = bitmask & Codes.stateBitmasks["ALL"];
                    if (e.vkCode > 255) {
                        keyCode = e.vkCode; // added to support extended (touch-hold) keys for mnemonic layouts
                    }
                    if (e.LisVirtualKey || keyCode > 255) {
                        if ((Lruleshift & 0x4000) == 0x4000 || (keyCode > 255)) { // added keyCode test to support extended keys
                            retVal = ((Lrulekey == keyCode) && ((Lruleshift & modifierBitmask) == e.Lmodifiers)); //I3318, I3555
                            retVal = retVal && this.stateMatch(e, Lruleshift & stateBitmask);
                        }
                    }
                    else if ((Lruleshift & 0x4000) == 0) {
                        retVal = (keyCode == Lrulekey); // I3318, I3555
                    }
                    if (!retVal) {
                        this.activeTargetOutput.deadkeys().resetMatched(); // I3318
                    }
                    return retVal; // I3318
                };
                ;
                /**
                 * Function     stateMatch    KSM
                 * Scope        Public
                 * @param       {Object}      e       keystroke event
                 * @param       {number}      Lstate
                 * Description  Test keystroke against state key rules
                 */
                KeyboardInterface.prototype.stateMatch = function (e, Lstate) {
                    return ((Lstate & e.Lstates) == Lstate);
                };
                /**
                 * Function     keyInformation  KKI
                 * Scope        Public
                 * @param       {Object}      e
                 * @return      {Object}              Object with event's virtual key flag, key code, and modifiers
                 * Description  Get object with extended key event information
                 */
                KeyboardInterface.prototype.keyInformation = function (e) {
                    var ei = new KeyInformation();
                    ei['vk'] = e.LisVirtualKey;
                    ei['code'] = e.Lcode;
                    ei['modifiers'] = e.Lmodifiers;
                    return ei;
                };
                ;
                /**
                 * Function     deadkeyMatch  KDM
                 * Scope        Public
                 * @param       {number}      n       offset from current cursor position
                 * @param       {Object}      Ptarg   target element
                 * @param       {number}      d       deadkey
                 * @return      {boolean}             True if deadkey found selected context matches val
                 * Description  Match deadkey at current cursor position
                 */
                KeyboardInterface.prototype.deadkeyMatch = function (n, outputTarget, d) {
                    return outputTarget.hasDeadkeyMatch(n, d);
                };
                /**
                 * Function     beep          KB
                 * Scope        Public
                 * @param       {Object}      Pelem     element to flash
                 * Description  Flash body as substitute for audible beep; notify embedded device to vibrate
                 */
                KeyboardInterface.prototype.beep = function (outputTarget) {
                    this.resetContextCache();
                    // Denote as part of the matched rule's behavior.
                    this.ruleBehavior.beep = true;
                };
                KeyboardInterface.prototype._ExplodeStore = function (store) {
                    if (typeof (store) == 'string') {
                        var cachedStores = this.activeKeyboard.explodedStores;
                        // Is the result cached?
                        if (cachedStores[store]) {
                            return cachedStores[store];
                        }
                        // Nope, so let's build its cache.
                        var result = [];
                        for (var i = 0; i < store._kmwLength(); i++) {
                            result.push(store._kmwCharAt(i));
                        }
                        // Cache the result for later!
                        cachedStores[store] = result;
                        return result;
                    }
                    else {
                        return store;
                    }
                };
                /**
                 * Function     any           KA
                 * Scope        Public
                 * @param       {number}      n     character position (index)
                 * @param       {string}      ch    character to find in string
                 * @param       {string}      s     'any' string
                 * @return      {boolean}           True if character found in 'any' string, sets index accordingly
                 * Description  Test for character matching
                 */
                KeyboardInterface.prototype.any = function (n, ch, s) {
                    if (ch == '') {
                        return false;
                    }
                    s = this._ExplodeStore(s);
                    var Lix = -1;
                    for (var i = 0; i < s.length; i++) {
                        if (typeof (s[i]) == 'string') {
                            if (s[i] == ch) {
                                Lix = i;
                                break;
                            }
                        }
                        else if (s[i]['d'] === ch['d']) {
                            Lix = i;
                            break;
                        }
                    }
                    this._AnyIndices[n] = Lix;
                    return Lix >= 0;
                };
                /**
                 * Function     _Index
                 * Scope        Public
                 * @param       {string}      Ps      string
                 * @param       {number}      Pn      index
                 * Description  Returns the character from a store string according to the offset in the index array
                 */
                KeyboardInterface.prototype._Index = function (Ps, Pn) {
                    Ps = this._ExplodeStore(Ps);
                    if (this._AnyIndices[Pn - 1] < Ps.length) { //I3319
                        return Ps[this._AnyIndices[Pn - 1]];
                    }
                    else {
                        /* Should not be possible for a compiled keyboard, but may arise
                        * during the development of handwritten keyboards.
                        */
                        console.warn("Unmatched contextual index() statement detected in rule with index " + Pn + "!");
                        return "";
                    }
                };
                /**
                 * Function     indexOutput   KIO
                 * Scope        Public
                 * @param       {number}      Pdn     no of character to overwrite (delete)
                 * @param       {string}      Ps      string
                 * @param       {number}      Pn      index
                 * @param       {Object}      Pelem   element to output to
                 * Description  Output a character selected from the string according to the offset in the index array
                 */
                KeyboardInterface.prototype.indexOutput = function (Pdn, Ps, Pn, outputTarget) {
                    this.resetContextCache();
                    var assertNever = function (x) {
                        // Could be accessed by improperly handwritten calls to `fullContextMatch`.
                        throw new Error("Unexpected object in fullContextMatch specification: " + x);
                    };
                    var indexChar = this._Index(Ps, Pn);
                    if (indexChar !== "") {
                        if (typeof indexChar == 'string') {
                            this.output(Pdn, outputTarget, indexChar); //I3319
                        }
                        else if (indexChar['t']) {
                            var storeEntry = indexChar;
                            switch (storeEntry.t) {
                                case 'b': // Beep commands may appear within stores.
                                    this.beep(outputTarget);
                                    break;
                                case 'd':
                                    this.deadkeyOutput(Pdn, outputTarget, indexChar['d']);
                                    break;
                                default:
                                    assertNever(storeEntry);
                            }
                        }
                        else { // For keyboards developed during 10.0's alpha phase - t:'d' was assumed.
                            this.deadkeyOutput(Pdn, outputTarget, indexChar['d']);
                        }
                    }
                };
                /**
                 * Function     deleteContext KDC
                 * Scope        Public
                 * @param       {number}      dn      number of context entries to overwrite
                 * @param       {Object}      Pelem   element to output to
                 * @param       {string}      s       string to output
                 * Description  Keyboard output
                 */
                KeyboardInterface.prototype.deleteContext = function (dn, outputTarget) {
                    var context;
                    // We want to control exactly which deadkeys get removed.
                    if (dn > 0) {
                        context = this._BuildExtendedContext(dn, dn, outputTarget);
                        var nulCount = 0;
                        for (var i = 0; i < context.valContext.length; i++) {
                            var dk = context.deadContext[i];
                            if (dk) {
                                // Remove deadkey in context.
                                outputTarget.deadkeys().remove(dk);
                                // Reduce our reported context size.
                                dn--;
                            }
                            else if (context.valContext[i] == "\uFFFE") {
                                // Count any `nul` sentinels that would contribute to our deletion count.
                                nulCount++;
                            }
                        }
                        // Prevent attempts to delete nul sentinels, as they don't exist in the actual context.
                        // (Addresses regression from KMW v 12.0 paired with Developer bug through same version)
                        var contextLength = context.valContext.length - nulCount;
                        if (dn > contextLength) {
                            dn = contextLength;
                        }
                    }
                    // If a matched deadkey hasn't been deleted, we don't WANT to delete it.
                    outputTarget.deadkeys().resetMatched();
                    // Why reinvent the wheel?  Delete the remaining characters by 'inserting a blank string'.
                    this.output(dn, outputTarget, '');
                };
                /**
                 * Function     output        KO
                 * Scope        Public
                 * @param       {number}      dn      number of characters to overwrite
                 * @param       {Object}      Pelem   element to output to
                 * @param       {string}      s       string to output
                 * Description  Keyboard output
                 */
                KeyboardInterface.prototype.output = function (dn, outputTarget, s) {
                    this.resetContextCache();
                    outputTarget.saveProperties();
                    outputTarget.clearSelection();
                    outputTarget.deadkeys().deleteMatched(); // I3318
                    if (dn >= 0) {
                        // Automatically manages affected deadkey positions.  Does not delete deadkeys b/c legacy behavior support.
                        outputTarget.deleteCharsBeforeCaret(dn);
                    }
                    // Automatically manages affected deadkey positions.
                    outputTarget.insertTextBeforeCaret(s);
                    outputTarget.restoreProperties();
                };
                /**
                 * `contextExOutput` function emits the character or object at `contextOffset` from the
                 * current matched rule's context. Introduced in Keyman 14.0, in order to resolve a
                 * gap between desktop and web core functionality for context(n) matching on notany().
                 * See #917 for additional detail.
                 * @alias       KCXO
                 * @public
                 * @param       {number}        Pdn            number of characters to delete left of cursor
                 * @param       {OutputTarget}  outputTarget   target to output to
                 * @param       {number}        contextLength  length of current rule context to retrieve
                 * @param       {number}        contextOffset  offset from start of current rule context, 1-based
                 */
                KeyboardInterface.prototype.contextExOutput = function (Pdn, outputTarget, contextLength, contextOffset) {
                    this.resetContextCache();
                    if (Pdn >= 0) {
                        this.output(Pdn, outputTarget, "");
                    }
                    var context = this.ruleContextEx.get(contextLength, contextLength);
                    var dk = context.deadContext[contextOffset - 1], vc = context.valContext[contextOffset - 1];
                    if (dk) {
                        outputTarget.insertDeadkeyBeforeCaret(dk.d);
                    }
                    else if (typeof vc == 'string') {
                        this.output(-1, outputTarget, vc);
                    }
                    else {
                        throw new Error("contextExOutput: should never be a numeric valContext with no corresponding deadContext");
                    }
                };
                /**
                 * Function     deadkeyOutput KDO
                 * Scope        Public
                 * @param       {number}      Pdn     no of character to overwrite (delete)
                 * @param       {Object}      Pelem   element to output to
                 * @param       {number}      Pd      deadkey id
                 * Description  Record a deadkey at current cursor position, deleting Pdn characters first
                 */
                KeyboardInterface.prototype.deadkeyOutput = function (Pdn, outputTarget, Pd) {
                    this.resetContextCache();
                    if (Pdn >= 0) {
                        this.output(Pdn, outputTarget, ""); //I3318 corrected to >=
                    }
                    outputTarget.insertDeadkeyBeforeCaret(Pd);
                    //    _DebugDeadKeys(Pelem, 'KDeadKeyOutput: dn='+Pdn+'; deadKey='+Pd);
                };
                /**
                 * KIFS compares the content of a system store with a string value
                 *
                 * @param       {number}      systemId    ID of the system store to test (only TSS_LAYER currently supported)
                 * @param       {string}      strValue    String value to compare to
                 * @param       {Object}      Pelem       Currently active element (may be needed by future tests)
                 * @return      {boolean}                 True if the test succeeds
                 */
                KeyboardInterface.prototype.ifStore = function (systemId, strValue, outputTarget) {
                    var result = true;
                    var store = this.systemStores[systemId];
                    if (store) {
                        result = store.matches(strValue);
                    }
                    return result; //Moved from previous line, now supports layer selection, Build 350
                };
                /**
                 * KSETS sets the value of a system store to a string
                 *
                 * @param       {number}      systemId    ID of the system store to set (only TSS_LAYER currently supported)
                 * @param       {string}      strValue    String to set as the system store content
                 * @param       {Object}      Pelem       Currently active element (may be needed in future tests)
                 * @return      {boolean}                 True if command succeeds
                 *                                        (i.e. for TSS_LAYER, if the layer is successfully selected)
                 *
                 * Note that option/variable stores are instead set within keyboard script code, as they only
                 * affect keyboard behavior.
                 */
                KeyboardInterface.prototype.setStore = function (systemId, strValue, outputTarget) {
                    this.resetContextCache();
                    if (systemId == KeyboardInterface.TSS_LAYER) {
                        // Denote the changed store as part of the matched rule's behavior.
                        this.ruleBehavior.setStore[systemId] = strValue;
                    }
                    else {
                        return false;
                    }
                };
                /**
                 * Load an option store value from a cookie or default value
                 *
                 * @param       {string}      kbdName     keyboard internal name
                 * @param       {string}      storeName   store (option) name, embedded in cookie name
                 * @param       {string}      dfltValue   default value
                 * @return      {string}                  current or default option value
                 *
                 * This will only ever be called when the keyboard is loaded, as it is used by keyboards
                 * to initialize a store value on the keyboard's script object.
                 */
                KeyboardInterface.prototype.loadStore = function (kbdName, storeName, dfltValue) {
                    this.resetContextCache();
                    if (this.variableStoreSerializer) {
                        var cValue = this.variableStoreSerializer.loadStore(kbdName, storeName);
                        return cValue[storeName] || dfltValue;
                    }
                    else {
                        return dfltValue;
                    }
                };
                /**
                 * Save an option store value to a cookie
                 *
                 * @param       {string}      storeName   store (option) name, embedded in cookie name
                 * @param       {string}      optValue    option value to save
                 * @return      {boolean}                 true if save successful
                 *
                 * Note that a keyboard will freely manipulate the value of its variable stores on the
                 * script object within its own code.  This function's use is merely to _persist_ that
                 * value across sessions, providing a custom user default for later uses of the keyboard.
                 */
                KeyboardInterface.prototype.saveStore = function (storeName, optValue) {
                    this.resetContextCache();
                    var kbd = this.activeKeyboard;
                    if (!kbd || typeof kbd.id == 'undefined' || kbd.id == '') {
                        return false;
                    }
                    // And the lookup under that entry looks for the value under the store name, again.
                    var valueObj = {};
                    valueObj[storeName] = optValue;
                    // Null-check in case of invocation during unit-test
                    if (this.ruleBehavior) {
                        this.ruleBehavior.saveStore[storeName] = valueObj;
                    }
                    else {
                        // We're in a unit-test environment, directly invoking this method from outside of a keyboard.
                        // In this case, we should immediately commit the change.
                        this.variableStoreSerializer.saveStore(this.activeKeyboard.id, storeName, valueObj);
                    }
                    return true;
                };
                KeyboardInterface.prototype.resetContextCache = function () {
                    this.cachedContext.reset();
                    this.cachedContextEx.reset();
                };
                KeyboardInterface.prototype.defaultBackspace = function (outputTarget) {
                    this.output(1, outputTarget, "");
                };
                /**
                 * Function     processKeystroke
                 * Scope        Private
                 * @param       {Object}        element     The page element receiving input
                 * @param       {Object}        keystroke   The input keystroke (with its properties) to be mapped by the keyboard.
                 * Description  Encapsulates calls to keyboard input processing.
                 * @returns     {number}        0 if no match is made, otherwise 1.
                 */
                KeyboardInterface.prototype.processKeystroke = function (outputTarget, keystroke) {
                    // Clear internal state tracking data from prior keystrokes.
                    if (!outputTarget) {
                        throw "No target specified for keyboard output!";
                    }
                    else if (!this.activeKeyboard) {
                        throw "No active keyboard for keystroke processing!";
                    }
                    outputTarget.invalidateSelection();
                    outputTarget.deadkeys().resetMatched(); // I3318
                    this.resetContextCache();
                    // Capture the initial state of the OutputTarget before any rules are matched.
                    var preInput = text.Mock.from(outputTarget);
                    // Establishes the results object, allowing corresponding commands to set values here as appropriate.
                    this.ruleBehavior = new text.RuleBehavior();
                    // Ensure the settings are in place so that KIFS/ifState activates and deactivates
                    // the appropriate rule(s) for the modeled device.
                    this.activeDevice = keystroke.device;
                    // Calls the start-group of the active keyboard.
                    this.activeTargetOutput = outputTarget;
                    var matched = this.activeKeyboard.process(outputTarget, keystroke);
                    this.activeTargetOutput = null;
                    if (!matched) {
                        return null;
                    }
                    // Finalize the rule's results.
                    this.ruleBehavior.transcription = outputTarget.buildTranscriptionFrom(preInput, keystroke);
                    // Clear our result-tracking variable to prevent any possible pollution for future processing.
                    var behavior = this.ruleBehavior;
                    this.ruleBehavior = null;
                    return behavior;
                };
                /**
                 * Publishes the KeyboardInterface's shorthand API names.  As this assigns the current functions
                 * held by the longform versions, note that this should be called after replacing any of them via
                 * JS method extension.
                 *
                 * DOM-aware KeymanWeb should call this after its domKbdInterface.ts code is loaded, as it replaces
                 * a few.  (This is currently done within its kmwapi.ts.)
                 */
                KeyboardInterface.__publishShorthandAPI = function () {
                    // Keyboard callbacks
                    var prototype = this.prototype;
                    var exportKBCallback = function (miniName, longName) {
                        prototype[miniName] = prototype[longName];
                    };
                    exportKBCallback('KSF', 'saveFocus');
                    exportKBCallback('KBR', 'beepReset');
                    exportKBCallback('KT', 'insertText');
                    exportKBCallback('KR', 'registerKeyboard');
                    exportKBCallback('KRS', 'registerStub');
                    exportKBCallback('KC', 'context');
                    exportKBCallback('KN', 'nul');
                    exportKBCallback('KCM', 'contextMatch');
                    exportKBCallback('KFCM', 'fullContextMatch');
                    exportKBCallback('KIK', 'isKeypress');
                    exportKBCallback('KKM', 'keyMatch');
                    exportKBCallback('KSM', 'stateMatch');
                    exportKBCallback('KKI', 'keyInformation');
                    exportKBCallback('KDM', 'deadkeyMatch');
                    exportKBCallback('KB', 'beep');
                    exportKBCallback('KA', 'any');
                    exportKBCallback('KDC', 'deleteContext');
                    exportKBCallback('KO', 'output');
                    exportKBCallback('KDO', 'deadkeyOutput');
                    exportKBCallback('KCXO', 'contextExOutput');
                    exportKBCallback('KIO', 'indexOutput');
                    exportKBCallback('KIFS', 'ifStore');
                    exportKBCallback('KSETS', 'setStore');
                    exportKBCallback('KLOAD', 'loadStore');
                    exportKBCallback('KSAVE', 'saveStore');
                };
                KeyboardInterface.GLOBAL_NAME = 'KeymanWeb';
                KeyboardInterface.TSS_LAYER = 33;
                KeyboardInterface.TSS_PLATFORM = 31;
                return KeyboardInterface;
            }());
            text.KeyboardInterface = KeyboardInterface;
            (function () {
                // This will be the only call within the keyboard-processor module.
                KeyboardInterface.__publishShorthandAPI();
            }());
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="defaultLayouts.ts" />
/// <reference path="activeLayout.ts" />
/// <reference path="../text/kbdInterface.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var keyboards;
        (function (keyboards) {
            /**
             * Stores preprocessed properties of a keyboard for quick retrieval later.
             */
            var CacheTag = /** @class */ (function () {
                function CacheTag() {
                    this.stores = {};
                }
                return CacheTag;
            }());
            var LayoutState;
            (function (LayoutState) {
                LayoutState[LayoutState["NOT_LOADED"] = undefined] = "NOT_LOADED";
                LayoutState[LayoutState["POLYFILLED"] = 1] = "POLYFILLED";
                LayoutState[LayoutState["CALIBRATED"] = 2] = "CALIBRATED";
            })(LayoutState = keyboards.LayoutState || (keyboards.LayoutState = {}));
            /**
             * Acts as a wrapper class for Keyman keyboards compiled to JS, providing type information
             * and keyboard-centered functionality in an object-oriented way without modifying the
             * wrapped keyboard itself.
             */
            var Keyboard = /** @class */ (function () {
                function Keyboard(keyboardScript) {
                    if (keyboardScript) {
                        this.scriptObject = keyboardScript;
                    }
                    else {
                        this.scriptObject = Keyboard.DEFAULT_SCRIPT_OBJECT;
                    }
                    this.layoutStates = {};
                }
                /**
                 * Calls the keyboard's `gs` function, which represents the keyboard source's group(main).
                 */
                Keyboard.prototype.process = function (outputTarget, keystroke) {
                    return this.scriptObject['gs'](outputTarget, keystroke);
                };
                Object.defineProperty(Keyboard.prototype, "isHollow", {
                    get: function () {
                        return this.scriptObject == Keyboard.DEFAULT_SCRIPT_OBJECT;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "id", {
                    get: function () {
                        return this.scriptObject['KI'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "name", {
                    get: function () {
                        return this.scriptObject['KN'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "_legacyLayoutSpec", {
                    // TODO:  Better typing.
                    get: function () {
                        return this.scriptObject['KV']; // used with buildDefaultLayout; layout must be constructed at runtime.
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "_layouts", {
                    // May return null if no layouts exist or have been initialized.
                    get: function () {
                        return this.scriptObject['KVKL']; // This one is compiled by Developer's visual keyboard layout editor.
                    },
                    set: function (value) {
                        this.scriptObject['KVKL'] = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "compilerVersion", {
                    get: function () {
                        return new keyman.utils.Version(this.scriptObject['KVER']);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isMnemonic", {
                    get: function () {
                        return !!this.scriptObject['KM'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "definesPositionalOrMnemonic", {
                    get: function () {
                        return typeof this.scriptObject['KM'] != 'undefined';
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "helpText", {
                    /**
                     * HTML help text which is a one liner intended for the status bar of the desktop OSK originally.
                     *
                     * Reference: https://help.keyman.com/developer/language/reference/kmw_helptext
                     */
                    get: function () {
                        return this.scriptObject['KH'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "hasHelpHTML", {
                    get: function () {
                        return !!this.scriptObject['KHF'];
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Replaces the OSK with custom HTML, which may be interactive (like with sil_euro_latin).
                 *
                 * Reference: https://help.keyman.com/developer/language/reference/kmw_helpfile
                 */
                Keyboard.prototype.insertHelpHTML = function (e) {
                    // e:  Expects the OSKManager's _Box element.  We don't add type info here b/c it would
                    //     reference the DOM.
                    this.scriptObject['KHF'](e);
                };
                Object.defineProperty(Keyboard.prototype, "oskStyling", {
                    get: function () {
                        return this.scriptObject['KCSS'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isCJK", {
                    /**
                     * true if this keyboard uses a (legacy) pick list (Chinese, Japanese, Korean, etc.)
                     *
                     * TODO:  Make a property on keyboards (say, `isPickList` / `KPL`) to signal this when we
                     *        get around to better, generalized picker-list support.
                     */
                    get: function () {
                        var lg;
                        if (typeof (this.scriptObject['KLC']) != 'undefined') {
                            lg = this.scriptObject['KLC'];
                        }
                        else if (typeof (this.scriptObject['LanguageCode']) != 'undefined') {
                            lg = this.scriptObject['LanguageCode'];
                        }
                        // While some of these aren't proper BCP-47 language codes, the CJK keyboards predate our use of BCP-47.
                        // So, we preserve the old ISO 639-3 codes, as that's what the keyboards are matching against.
                        return ((lg == 'cmn') || (lg == 'jpn') || (lg == 'kor'));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isRTL", {
                    get: function () {
                        return !!this.scriptObject['KRTL'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "modifierBitmask", {
                    /**
                     * Obtains the currently-active modifier bitmask for the active keyboard.
                     */
                    get: function () {
                        // NON_CHIRAL is the default bitmask if KMBM is not defined.
                        // We always need a bitmask to compare against, as seen in `isChiral`.
                        return this.scriptObject['KMBM'] || keyman.text.Codes.modifierBitmasks['NON_CHIRAL'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isChiral", {
                    get: function () {
                        return !!(this.modifierBitmask & keyman.text.Codes.modifierBitmasks['IS_CHIRAL']);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "desktopFont", {
                    get: function () {
                        if (this.scriptObject['KV']) {
                            return this.scriptObject['KV']['F'];
                        }
                        else {
                            return null;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "cacheTag", {
                    get: function () {
                        var tag = this.scriptObject['_kmw'];
                        if (!tag) {
                            tag = new CacheTag();
                            this.scriptObject['_kmw'] = tag;
                        }
                        return tag;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "explodedStores", {
                    get: function () {
                        return this.cacheTag.stores;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "emulatesAltGr", {
                    /**
                     * Signifies whether or not a layout or OSK should include AltGr / Right-alt emulation for this keyboard.
                     * @param   {Object=}   keyLabels
                     * @return  {boolean}
                     */
                    get: function () {
                        var modifierCodes = keyman.text.Codes.modifierCodes;
                        // If we're not chiral, we're not emulating.
                        if (!this.isChiral) {
                            return false;
                        }
                        if (this._legacyLayoutSpec == null) {
                            return false;
                        }
                        // Only exists in KMW 10.0+, but before that Web had no chirality support, so... return false.
                        var layers = this._legacyLayoutSpec['KLS'];
                        if (!layers) {
                            return false;
                        }
                        var emulationMask = modifierCodes['LCTRL'] | modifierCodes['LALT'];
                        var unshiftedEmulationLayer = layers[keyboards.Layouts.getLayerId(emulationMask)];
                        var shiftedEmulationLayer = layers[keyboards.Layouts.getLayerId(modifierCodes['SHIFT'] | emulationMask)];
                        // buildDefaultLayout ensures that these are aliased to the original modifier set being emulated.
                        // As a result, we can directly test for reference equality.
                        //
                        // This allows us to still return `true` after creating the layers for emulation; during keyboard
                        // construction, the two layers should be null for AltGr emulation to succeed.
                        if (unshiftedEmulationLayer != null &&
                            unshiftedEmulationLayer != layers[keyboards.Layouts.getLayerId(modifierCodes['RALT'])]) {
                            return false;
                        }
                        if (shiftedEmulationLayer != null &&
                            shiftedEmulationLayer != layers[keyboards.Layouts.getLayerId(modifierCodes['RALT'] | modifierCodes['SHIFT'])]) {
                            return false;
                        }
                        // It's technically possible for the OSK to not specify anything while allowing chiral input.  A last-ditch catch:
                        var bitmask = this.modifierBitmask;
                        if ((bitmask & emulationMask) != emulationMask) {
                            // At least one of the emulation modifiers is never used by the keyboard!  We can confirm everything's safe.
                            return true;
                        }
                        if (unshiftedEmulationLayer == null && shiftedEmulationLayer == null) {
                            // We've run out of things to go on; we can't detect if chiral AltGr emulation is intended or not.
                            // TODO:  handle this again!
                            // if(!osk.altGrWarning) {
                            //   console.warn("Could not detect if AltGr emulation is safe, but defaulting to active emulation!")
                            //   // Avoid spamming the console with warnings on every call of the method.
                            //   osk.altGrWarning = true;
                            // }
                            return true;
                        }
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "usesSupplementaryPlaneChars", {
                    get: function () {
                        var kbd = this.scriptObject;
                        // I3319 - SMP extension, I3363 (Build 301)
                        return kbd && ((kbd['KS'] && kbd['KS'] == 1) || kbd['KN'] == 'Hieroglyphic');
                    },
                    enumerable: true,
                    configurable: true
                });
                Keyboard.prototype.usesDesktopLayoutOnDevice = function (device) {
                    if (this.scriptObject['KVKL']) {
                        // A custom mobile layout is defined... but are we using it?
                        return device.formFactor == keyman.utils.FormFactor.Desktop;
                    }
                    else {
                        return true;
                    }
                };
                /**
                 * @param       {number}    _PCommand     event code (16,17,18) or 0
                 * @param       {Object}    _PTarget      target element
                 * @param       {number}    _PData        1 or 0
                 * Notifies keyboard of keystroke or other event
                 */
                Keyboard.prototype.notify = function (_PCommand, _PTarget, _PData) {
                    // Good example use case - the Japanese CJK-picker keyboard
                    if (typeof (this.scriptObject['KNS']) == 'function') {
                        this.scriptObject['KNS'](_PCommand, _PTarget, _PData);
                    }
                };
                Keyboard.prototype.findOrConstructLayout = function (formFactor) {
                    if (this._layouts) {
                        // Search for viable layouts.  `null` is allowed for desktop form factors when help text is available,
                        // so we check explicitly against `undefined`.
                        if (this._layouts[formFactor] !== undefined) {
                            return this._layouts[formFactor];
                        }
                        else if (formFactor == keyman.utils.FormFactor.Phone && this._layouts[keyman.utils.FormFactor.Tablet]) {
                            return this._layouts[keyman.utils.FormFactor.Phone] = this._layouts[keyman.utils.FormFactor.Tablet];
                        }
                        else if (formFactor == keyman.utils.FormFactor.Tablet && this._layouts[keyman.utils.FormFactor.Phone]) {
                            return this._layouts[keyman.utils.FormFactor.Tablet] = this._layouts[keyman.utils.FormFactor.Phone];
                        }
                    }
                    // No pre-built layout available; time to start constructing it via defaults.
                    // First, if we have non-default keys specified by the ['BK'] array, we've got
                    // enough to work with to build a default layout.
                    var rawSpecifications = null; // TODO:  better typing, same type as this._legacyLayoutSpec.
                    if (this._legacyLayoutSpec != null && this._legacyLayoutSpec['KLS']) { // KLS is only specified whenever there are non-default keys.
                        rawSpecifications = this._legacyLayoutSpec;
                    }
                    else if (this._legacyLayoutSpec != null && this._legacyLayoutSpec['BK'] != null) {
                        var keyCaps = this._legacyLayoutSpec['BK'];
                        for (var i = 0; i < keyCaps.length; i++) {
                            if (keyCaps[i].length > 0) {
                                rawSpecifications = this._legacyLayoutSpec;
                                break;
                            }
                        }
                    }
                    // If we don't have key definitions to use for a layout but also lack help text or are a touch-based layout,
                    // we make a default layout anyway.  We have to show display something usable.
                    if (!rawSpecifications && (this.helpText == '' || formFactor != keyman.utils.FormFactor.Desktop)) {
                        rawSpecifications = { 'F': 'Tahoma', 'BK': keyboards.Layouts.dfltText };
                    }
                    // Regardless of success, we'll want to initialize the field that backs the property; 
                    // may as well cache the default layout we just built, or a 'null' if it shouldn't exist..
                    if (!this._layouts) {
                        this._layouts = {};
                    }
                    // Final check - do we construct a layout, or is this a case where helpText / insertHelpHTML should take over?
                    if (rawSpecifications) {
                        // Now to generate a layout from our raw specifications.
                        var layout = this._layouts[formFactor] = keyboards.Layouts.buildDefaultLayout(rawSpecifications, this, formFactor);
                        layout.isDefault = true;
                        return layout;
                    }
                    else {
                        // The fact that it doesn't exist will indicate that help text/HTML should be inserted instead.
                        this._layouts[formFactor] = null; // provides a cached value for the check at the top of this method.
                        return null;
                    }
                };
                /**
                 * Returns an ActiveLayout object representing the keyboard's layout for this form factor.  May return null if a custom desktop "help" OSK is defined, as with sil_euro_latin.
                 *
                 * In such cases, please use either `helpText` or `insertHelpHTML` instead.
                 * @param formFactor {string} The desired form factor for the layout.
                 */
                Keyboard.prototype.layout = function (formFactor) {
                    var rawLayout = this.findOrConstructLayout(formFactor);
                    if (rawLayout) {
                        // Prevents accidentally reprocessing layouts; it's a simple enough check.
                        if (this.layoutStates[formFactor] == LayoutState.NOT_LOADED) {
                            rawLayout = keyboards.ActiveLayout.polyfill(rawLayout, this, formFactor);
                            this.layoutStates[formFactor] = LayoutState.POLYFILLED;
                        }
                        return rawLayout;
                    }
                    else {
                        return null;
                    }
                };
                Keyboard.prototype.refreshLayouts = function () {
                    var formFactors = [keyman.utils.FormFactor.Desktop, keyman.utils.FormFactor.Phone, keyman.utils.FormFactor.Tablet];
                    var _this = this;
                    formFactors.forEach(function (form) {
                        // Currently doesn't work if we reset it to POLYFILLED, likely due to how 'calibration'
                        // currently works.
                        _this.layoutStates[form] = LayoutState.NOT_LOADED;
                    });
                };
                Keyboard.prototype.markLayoutCalibrated = function (formFactor) {
                    if (this.layoutStates[formFactor] != LayoutState.NOT_LOADED) {
                        this.layoutStates[formFactor] = LayoutState.CALIBRATED;
                    }
                };
                Keyboard.prototype.getLayoutState = function (formFactor) {
                    return this.layoutStates[formFactor];
                };
                Keyboard.DEFAULT_SCRIPT_OBJECT = {
                    'gs': function (outputTarget, keystroke) { return false; },
                    'KI': '',
                    'KN': '',
                    'KV': keyboards.Layouts.DEFAULT_RAW_SPEC,
                    'KM': 0 // May not be the best default, but this matches current behavior when there is no activeKeyboard.
                };
                return Keyboard;
            }());
            keyboards.Keyboard = Keyboard;
        })(keyboards = keyman.keyboards || (keyman.keyboards = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var KeyMap = /** @class */ (function () {
            function KeyMap() {
            }
            return KeyMap;
        }());
        var BrowserKeyMaps = /** @class */ (function () {
            function BrowserKeyMaps() {
                this.FF = new KeyMap();
                this.Safari = new KeyMap();
                this.Opera = new KeyMap();
                // All three have been around since at least May 2014 / FF 29.
                // It'd hard to find precise history, but at least that much has been confirmed.
                // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode, on Feb 26 2021.
                this.FF['k61'] = 187; // =   // FF 2.0
                this.FF['k59'] = 186; // ;
                this.FF['k173'] = 189; // -/_
            }
            return BrowserKeyMaps;
        }());
        var LanguageKeyMaps = /** @class */ (function () {
            // // Here are some old legacy definitions that were no longer referenced but are likely related:
            // static _BaseLayoutEuro: {[code: string]: string} = {
            //   'se': '\u00a71234567890+~~~QWERTYUIOP\u00c5\u00a8\'~~~ASDFGHJKL\u00d6\u00c4~~~~~<ZXCVBNM,.-~~~~~ ',  // Swedish
            //   'uk': '`1234567890-=~~~QWERTYUIOP[]#~~~ASDFGHJKL;\'~~~~~\\ZXCVBNM,./~~~~~ ' // UK
            function LanguageKeyMaps() {
                /* I732 START - 13/03/2007 MCD: Swedish: Start mapping of keystroke to US keyboard #2 */
                // Swedish key map
                this['se'] = new KeyMap();
                this['se']['k220'] = 192; // `
                this['se']['k187'] = 189; // -
                this['se']['k219'] = 187; // =
                this['se']['k221'] = 219; // [
                this['se']['k186'] = 221; // ]
                this['se']['k191'] = 220; // \
                this['se']['k192'] = 186; // ;
                this['se']['k189'] = 191; // /
                this['uk'] = new KeyMap(); // I1299
                this['uk']['k223'] = 192; // // ` U+00AC (logical not) =>  ` ~
                this['uk']['k192'] = 222; // ' @  =>  ' "
                this['uk']['k222'] = 226; // # ~  => K_oE2     // I1504 - UK keyboard mixup #, \
                this['uk']['k220'] = 220; // \ |  => \ |       // I1504 - UK keyboard mixup #, \
            }
            return LanguageKeyMaps;
        }());
        var KeyMapping = /** @class */ (function () {
            function KeyMapping() {
                // Do not construct this class.
            }
            KeyMapping._usCodeInit = function () {
                var s0 = new KeyMap(), s1 = new KeyMap();
                s0['k192'] = 96;
                s0['k49'] = 49;
                s0['k50'] = 50;
                s0['k51'] = 51;
                s0['k52'] = 52;
                s0['k53'] = 53;
                s0['k54'] = 54;
                s0['k55'] = 55;
                s0['k56'] = 56;
                s0['k57'] = 57;
                s0['k48'] = 48;
                s0['k189'] = 45;
                s0['k187'] = 61;
                s0['k81'] = 113;
                s0['k87'] = 119;
                s0['k69'] = 101;
                s0['k82'] = 114;
                s0['k84'] = 116;
                s0['k89'] = 121;
                s0['k85'] = 117;
                s0['k73'] = 105;
                s0['k79'] = 111;
                s0['k80'] = 112;
                s0['k219'] = 91;
                s0['k221'] = 93;
                s0['k220'] = 92;
                s0['k65'] = 97;
                s0['k83'] = 115;
                s0['k68'] = 100;
                s0['k70'] = 102;
                s0['k71'] = 103;
                s0['k72'] = 104;
                s0['k74'] = 106;
                s0['k75'] = 107;
                s0['k76'] = 108;
                s0['k186'] = 59;
                s0['k222'] = 39;
                s0['k90'] = 122;
                s0['k88'] = 120;
                s0['k67'] = 99;
                s0['k86'] = 118;
                s0['k66'] = 98;
                s0['k78'] = 110;
                s0['k77'] = 109;
                s0['k188'] = 44;
                s0['k190'] = 46;
                s0['k191'] = 47;
                s1['k192'] = 126;
                s1['k49'] = 33;
                s1['k50'] = 64;
                s1['k51'] = 35;
                s1['k52'] = 36;
                s1['k53'] = 37;
                s1['k54'] = 94;
                s1['k55'] = 38;
                s1['k56'] = 42;
                s1['k57'] = 40;
                s1['k48'] = 41;
                s1['k189'] = 95;
                s1['k187'] = 43;
                s1['k81'] = 81;
                s1['k87'] = 87;
                s1['k69'] = 69;
                s1['k82'] = 82;
                s1['k84'] = 84;
                s1['k89'] = 89;
                s1['k85'] = 85;
                s1['k73'] = 73;
                s1['k79'] = 79;
                s1['k80'] = 80;
                s1['k219'] = 123;
                s1['k221'] = 125;
                s1['k220'] = 124;
                s1['k65'] = 65;
                s1['k83'] = 83;
                s1['k68'] = 68;
                s1['k70'] = 70;
                s1['k71'] = 71;
                s1['k72'] = 72;
                s1['k74'] = 74;
                s1['k75'] = 75;
                s1['k76'] = 76;
                s1['k186'] = 58;
                s1['k222'] = 34;
                s1['k90'] = 90;
                s1['k88'] = 88;
                s1['k67'] = 67;
                s1['k86'] = 86;
                s1['k66'] = 66;
                s1['k78'] = 78;
                s1['k77'] = 77;
                s1['k188'] = 60;
                s1['k190'] = 62;
                s1['k191'] = 63;
                KeyMapping._usCharCodes = [s0, s1];
            };
            /**
             * Function     _USKeyCodeToCharCode
             * Scope        Private
             * @param       {Event}     Levent      KMW event object
             * @return      {number}                Character code
             * Description Translate keyboard codes to standard US layout codes
             */
            KeyMapping._USKeyCodeToCharCode = function (Levent) {
                return KeyMapping.usCharCodes[Levent.Lmodifiers & 0x10 ? 1 : 0]['k' + Levent.Lcode];
            };
            ;
            Object.defineProperty(KeyMapping, "usCharCodes", {
                get: function () {
                    if (!KeyMapping._usCharCodes) {
                        KeyMapping._usCodeInit();
                    }
                    return KeyMapping._usCharCodes;
                },
                enumerable: true,
                configurable: true
            });
            KeyMapping.browserMap = new BrowserKeyMaps();
            KeyMapping.languageMap = new LanguageKeyMaps();
            return KeyMapping;
        }());
        keyman.KeyMapping = KeyMapping;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Establishes key-code definitions.
/// <reference path="codes.ts" />
// Defines our generalized "KeyEvent" class.
/// <reference path="keyEvent.ts" />
// Defines the RuleBehavior keyboard-processing return object.
/// <reference path="ruleBehavior.ts" />
// Defines default key handling behaviors.
/// <reference path="defaultOutput.ts" />
// Defines the keyboard wrapper object.
/// <reference path="../keyboards/keyboard.ts" />
// Defines built-in keymapping.
/// <reference path="keyMapping.ts" />
// Also relies on @keymanapp/web-utils, which is included via tsconfig.json.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var KeyboardProcessor = /** @class */ (function () {
                function KeyboardProcessor(options) {
                    // Tracks the simulated value for supported state keys, allowing the OSK to mirror a physical keyboard for them.
                    // Using the exact keyCode name from the Codes definitions will allow for certain optimizations elsewhere in the code.
                    this.stateKeys = {
                        "K_CAPS": false,
                        "K_NUMLOCK": false,
                        "K_SCROLL": false
                    };
                    // Tracks the most recent modifier state information in order to quickly detect changes
                    // in keyboard state not otherwise captured by the hosting page in the browser.
                    // Needed for AltGr simulation.
                    this.modStateFlags = 0;
                    if (!options) {
                        options = KeyboardProcessor.DEFAULT_OPTIONS;
                    }
                    this.baseLayout = options.baseLayout || KeyboardProcessor.DEFAULT_OPTIONS.baseLayout;
                    this.keyboardInterface = new text.KeyboardInterface(options.variableStoreSerializer);
                    this.installInterface();
                }
                KeyboardProcessor.prototype.installInterface = function () {
                    // We must ensure that the keyboard can find the API functions at the expected place.
                    var globalThis = keyman.utils.getGlobalObject();
                    globalThis[text.KeyboardInterface.GLOBAL_NAME] = this.keyboardInterface;
                    // Ensure that the active keyboard is set on the keyboard interface object.
                    if (this.activeKeyboard) {
                        this.keyboardInterface.activeKeyboard = this.activeKeyboard;
                    }
                };
                Object.defineProperty(KeyboardProcessor.prototype, "activeKeyboard", {
                    get: function () {
                        return this.keyboardInterface.activeKeyboard;
                    },
                    set: function (keyboard) {
                        this.keyboardInterface.activeKeyboard = keyboard;
                        // All old deadkeys and keyboard-specific cache should immediately be invalidated
                        // on a keyboard change.
                        this.resetContext();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(KeyboardProcessor.prototype, "layerStore", {
                    get: function () {
                        return this.keyboardInterface.systemStores[text.KeyboardInterface.TSS_LAYER];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(KeyboardProcessor.prototype, "layerId", {
                    get: function () {
                        return this.layerStore.value;
                    },
                    // Note:  will trigger an 'event' callback designed to notify the OSK of layer changes.
                    set: function (value) {
                        this.layerStore.set(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Get the default RuleBehavior for the specified key, attempting to mimic standard browser defaults
                 * where and when appropriate.
                 *
                 * @param   {object}  Lkc           The pre-analyzed KeyEvent object
                 * @param   {boolean} outputTarget  The OutputTarget receiving the KeyEvent
                 * @return  {string}
                 */
                KeyboardProcessor.prototype.defaultRuleBehavior = function (Lkc, outputTarget) {
                    var preInput = text.Mock.from(outputTarget);
                    var ruleBehavior = new text.RuleBehavior();
                    var matched = false;
                    var char = '';
                    var special;
                    if (Lkc.isSynthetic || outputTarget.isSynthetic) {
                        matched = true; // All the conditions below result in matches until the final else, which restores the expected default
                        // if no match occurs.
                        if (text.DefaultOutput.isCommand(Lkc)) {
                            // Note this in the rule behavior, return successfully.  We'll consider applying it later.
                            ruleBehavior.triggersDefaultCommand = true;
                            // We'd rather let the browser handle these keys, but we're using emulated keystrokes, forcing KMW
                            // to emulate default behavior here.
                        }
                        else if ((special = text.DefaultOutput.forSpecialEmulation(Lkc)) != null) {
                            switch (special) {
                                case text.EmulationKeystrokes.Backspace:
                                    this.keyboardInterface.defaultBackspace(outputTarget);
                                    break;
                                case text.EmulationKeystrokes.Enter:
                                    outputTarget.handleNewlineAtCaret();
                                    break;
                                // case '\u007f': // K_DEL
                                // // For (possible) future implementation.
                                // // Would recommend (conceptually) equaling K_RIGHT + K_BKSP, the former of which would technically be a 'command'.
                                default:
                                    // In case we extend the allowed set, but forget to implement its handling case above.
                                    ruleBehavior.errorLog = "Unexpected 'special emulation' character (\\u" + special.kmwCharCodeAt(0).toString(16) + ") went unhandled!";
                            }
                        }
                        else {
                            // Back to the standard default, pending normal matching.
                            matched = false;
                        }
                    }
                    var isMnemonic = this.activeKeyboard && this.activeKeyboard.isMnemonic;
                    if (!matched) {
                        if ((char = text.DefaultOutput.forAny(Lkc, isMnemonic)) != null) {
                            special = text.DefaultOutput.forSpecialEmulation(Lkc);
                            if (special == text.EmulationKeystrokes.Backspace) {
                                // A browser's default backspace may fail to delete both parts of an SMP character.
                                this.keyboardInterface.defaultBackspace(outputTarget);
                            }
                            else if (special || text.DefaultOutput.isCommand(Lkc)) { // Filters out 'commands' like TAB.
                                // We only do the "for special emulation" cases under the condition above... aside from backspace
                                // Let the browser handle those.
                                return null;
                            }
                            else {
                                this.keyboardInterface.output(0, outputTarget, char);
                            }
                        }
                        else {
                            // No match, no default RuleBehavior.
                            return null;
                        }
                    }
                    // Shortcut things immediately if there were issues generating this rule behavior.
                    if (ruleBehavior.errorLog) {
                        return ruleBehavior;
                    }
                    var transcription = outputTarget.buildTranscriptionFrom(preInput, Lkc);
                    ruleBehavior.transcription = transcription;
                    return ruleBehavior;
                };
                KeyboardProcessor.prototype.setSyntheticEventDefaults = function (Lkc) {
                    // Set the flags for the state keys.
                    Lkc.Lstates |= this.stateKeys['K_CAPS'] ? text.Codes.modifierCodes['CAPS'] : text.Codes.modifierCodes['NO_CAPS'];
                    Lkc.Lstates |= this.stateKeys['K_NUMLOCK'] ? text.Codes.modifierCodes['NUM_LOCK'] : text.Codes.modifierCodes['NO_NUM_LOCK'];
                    Lkc.Lstates |= this.stateKeys['K_SCROLL'] ? text.Codes.modifierCodes['SCROLL_LOCK'] : text.Codes.modifierCodes['NO_SCROLL_LOCK'];
                    // Set LisVirtualKey to false to ensure that nomatch rule does fire for U_xxxx keys
                    if (Lkc.kName && Lkc.kName.substr(0, 2) == 'U_') {
                        Lkc.LisVirtualKey = false;
                    }
                    // Get code for non-physical keys (T_KOKAI, U_05AB etc)
                    if (typeof Lkc.Lcode == 'undefined') {
                        Lkc.Lcode = this.getVKDictionaryCode(Lkc.kName); // Updated for Build 347
                        if (!Lkc.Lcode) {
                            // Special case for U_xxxx keys. This vk code will never be used
                            // in a keyboard, so we use this to ensure that keystroke processing
                            // occurs for the key.
                            Lkc.Lcode = 1;
                        }
                    }
                    // Handles modifier states when the OSK is emulating rightalt through the leftctrl-leftalt layer.
                    if ((Lkc.Lmodifiers & text.Codes.modifierBitmasks['ALT_GR_SIM']) == text.Codes.modifierBitmasks['ALT_GR_SIM'] && this.activeKeyboard.emulatesAltGr) {
                        Lkc.Lmodifiers &= ~text.Codes.modifierBitmasks['ALT_GR_SIM'];
                        Lkc.Lmodifiers |= text.Codes.modifierCodes['RALT'];
                    }
                };
                KeyboardProcessor.prototype.processKeystroke = function (keyEvent, outputTarget) {
                    var matchBehavior;
                    // Pass this key code and state to the keyboard program
                    if (this.activeKeyboard && keyEvent.Lcode != 0) {
                        /*
                         * The `this.installInterface()` call is insurance against something I've seen in unit tests when things break a bit.
                         *
                         * Currently, when a KMW shutdown doesn't go through properly or completely, sometimes we end up with parallel
                         * versions of KMW running, and an old, partially-shutdown one will "snipe" a command meant for the most-recent
                         * one's test. So, installing here ensures that the active Processor has its matching KeyboardInterface ready,
                         * even should that occur.
                         */
                        this.installInterface();
                        matchBehavior = this.keyboardInterface.processKeystroke(outputTarget, keyEvent);
                    }
                    if (!matchBehavior) {
                        // Restore the virtual key code if a mnemonic keyboard is being used
                        // If no vkCode value was stored, maintain the original Lcode value.
                        keyEvent.Lcode = keyEvent.vkCode || keyEvent.Lcode;
                        // Handle unmapped keys, including special keys
                        // The following is physical layout dependent, so should be avoided if possible.  All keys should be mapped.
                        this.keyboardInterface.activeTargetOutput = outputTarget;
                        // Match against the 'default keyboard' - rules to mimic the default string output when typing in a browser.
                        // Many keyboards rely upon these 'implied rules'.
                        matchBehavior = this.defaultRuleBehavior(keyEvent, outputTarget);
                        this.keyboardInterface.activeTargetOutput = null;
                    }
                    return matchBehavior;
                };
                // FIXME:  makes some bad assumptions.
                KeyboardProcessor.setMnemonicCode = function (Lkc, shifted, capsActive) {
                    // K_SPACE is not handled by defaultKeyOutput for physical keystrokes unless using touch-aliased elements.
                    // It's also a "exception required, March 2013" for clickKey, so at least they both have this requirement.
                    if (Lkc.Lcode != text.Codes.keyCodes['K_SPACE']) {
                        // So long as the key name isn't prefixed with 'U_', we'll get a default mapping based on the Lcode value.
                        // We need to determine the mnemonic base character - for example, SHIFT + K_PERIOD needs to map to '>'.
                        var mappingEvent = new text.KeyEvent();
                        for (var key in Lkc) {
                            mappingEvent[key] = Lkc[key];
                        }
                        // To facilitate storing relevant commands, we should probably reverse-lookup
                        // the actual keyname instead.
                        mappingEvent.kName = 'K_xxxx';
                        mappingEvent.Lmodifiers = (shifted ? 0x10 : 0); // mnemonic lookups only exist for default & shift layers.
                        var mappedChar = text.DefaultOutput.forAny(mappingEvent, true);
                        /* First, save a backup of the original code.  This one won't needlessly trigger keyboard
                         * rules, but allows us to replicate/emulate commands after rule processing if needed.
                         * (Like backspaces)
                         */
                        Lkc.vkCode = Lkc.Lcode;
                        if (mappedChar) {
                            // Will return 96 for 'a', which is a keycode corresponding to Codes.keyCodes('K_NP1') - a numpad key.
                            // That stated, we're in mnemonic mode - this keyboard's rules are based on the char codes.
                            Lkc.Lcode = mappedChar.charCodeAt(0);
                        }
                        else {
                            // Don't let command-type keys (like K_DEL, which will output '.' otherwise!)
                            // trigger keyboard rules.
                            //
                            // However, DO make sure modifier keys pass through safely.
                            // (https://github.com/keymanapp/keyman/issues/3744)
                            if (!KeyboardProcessor.isModifier(Lkc)) {
                                delete Lkc.Lcode;
                            }
                        }
                    }
                    if (capsActive) {
                        // TODO:  Needs fixing - does not properly mirror physical keystrokes, as Lcode range 96-111 corresponds
                        // to numpad keys!  (Physical keyboard section has its own issues here.)
                        if ((Lkc.Lcode >= 65 && Lkc.Lcode <= 90) /* 'A' - 'Z' */ || (Lkc.Lcode >= 97 && Lkc.Lcode <= 122) /* 'a' - 'z' */) {
                            Lkc.Lmodifiers ^= 0x10; // Flip the 'shifted' bit, so it'll act as the opposite key.
                            Lkc.Lcode ^= 0x20; // Flips the 'upper' vs 'lower' bit for the base 'a'-'z' ASCII alphabetics.
                        }
                    }
                };
                /**
                 * Get modifier key state from layer id
                 *
                 * @param       {string}      layerId       layer id (e.g. ctrlshift)
                 * @return      {number}                    modifier key state (desktop keyboards)
                 */
                KeyboardProcessor.getModifierState = function (layerId) {
                    var modifier = 0;
                    if (layerId.indexOf('shift') >= 0) {
                        modifier |= text.Codes.modifierCodes['SHIFT'];
                    }
                    // The chiral checks must not be directly exclusive due each other to visual OSK feedback.
                    var ctrlMatched = false;
                    if (layerId.indexOf('leftctrl') >= 0) {
                        modifier |= text.Codes.modifierCodes['LCTRL'];
                        ctrlMatched = true;
                    }
                    if (layerId.indexOf('rightctrl') >= 0) {
                        modifier |= text.Codes.modifierCodes['RCTRL'];
                        ctrlMatched = true;
                    }
                    if (layerId.indexOf('ctrl') >= 0 && !ctrlMatched) {
                        modifier |= text.Codes.modifierCodes['CTRL'];
                    }
                    var altMatched = false;
                    if (layerId.indexOf('leftalt') >= 0) {
                        modifier |= text.Codes.modifierCodes['LALT'];
                        altMatched = true;
                    }
                    if (layerId.indexOf('rightalt') >= 0) {
                        modifier |= text.Codes.modifierCodes['RALT'];
                        altMatched = true;
                    }
                    if (layerId.indexOf('alt') >= 0 && !altMatched) {
                        modifier |= text.Codes.modifierCodes['ALT'];
                    }
                    return modifier;
                };
                /**
                 * @summary Look up a custom virtual key code in the virtual key code dictionary KVKD.  On first run, will build the dictionary.
                 *
                 * `VKDictionary` is constructed from the keyboard's `KVKD` member. This list is constructed
                 * at compile-time and is a list of 'additional' virtual key codes, starting at 256 (i.e.
                 * outside the range of standard virtual key codes). These additional codes are both
                 * `[T_xxx]` and `[U_xxxx]` custom key codes from the Keyman keyboard language. However,
                 * `[U_xxxx]` keys only generate an entry in `KVKD` if there is a corresponding rule that
                 * is associated with them in the keyboard rules. If the `[U_xxxx]` key code is only
                 * referenced as the id of a key in the touch layout, then it does not get an entry in
                 * the `KVKD` property.
                 *
                 * @private
                 * @param       {string}      keyName   custom virtual key code to lookup in the dictionary
                 * @return      {number}                key code > 255 on success, or 0 if not found
                 */
                KeyboardProcessor.prototype.getVKDictionaryCode = function (keyName) {
                    var activeKeyboard = this.activeKeyboard;
                    if (!activeKeyboard.scriptObject['VKDictionary']) {
                        var a = [];
                        if (typeof activeKeyboard.scriptObject['KVKD'] == 'string') {
                            // Build the VK dictionary
                            // TODO: Move the dictionary build into the compiler -- so compiler generates code such as following.  
                            // Makes the VKDictionary member unnecessary.
                            //       this.KVKD={"K_ABC":256,"K_DEF":257,...};
                            var s = activeKeyboard.scriptObject['KVKD'].split(' ');
                            for (var i = 0; i < s.length; i++) {
                                a[s[i].toUpperCase()] = i + 256; // We force upper-case since virtual keys should be case-insensitive.
                            }
                        }
                        activeKeyboard.scriptObject['VKDictionary'] = a;
                    }
                    var res = activeKeyboard.scriptObject['VKDictionary'][keyName.toUpperCase()];
                    return res ? res : 0;
                };
                /**
                 * Function     _UpdateVKShift
                 * Scope        Private
                 * @param       {Object}            e     OSK event
                 * @param       {number}            v     keyboard shift state
                 * @param       {(boolean|number)}  d     set (1) or clear(0) shift state bits
                 * @return      {boolean}                 Always true
                 * Description  Updates the current shift state within KMW, updating the OSK's visualization thereof.
                 */
                KeyboardProcessor.prototype._UpdateVKShift = function (e, v, d) {
                    var keyShiftState = 0, lockStates = 0, i;
                    var lockNames = ['CAPS', 'NUM_LOCK', 'SCROLL_LOCK'];
                    var lockKeys = ['K_CAPS', 'K_NUMLOCK', 'K_SCROLL'];
                    if (!this.activeKeyboard) {
                        return true;
                    }
                    if (e) {
                        // read shift states from Pevent
                        keyShiftState = e.Lmodifiers;
                        lockStates = e.Lstates;
                        // Are we simulating AltGr?  If it's a simulation and not real, time to un-simulate for the OSK.
                        if (this.activeKeyboard.isChiral && (this.activeKeyboard.emulatesAltGr) &&
                            (this.modStateFlags & text.Codes.modifierBitmasks['ALT_GR_SIM']) == text.Codes.modifierBitmasks['ALT_GR_SIM']) {
                            keyShiftState |= text.Codes.modifierBitmasks['ALT_GR_SIM'];
                            keyShiftState &= ~text.Codes.modifierCodes['RALT'];
                        }
                        for (i = 0; i < lockNames.length; i++) {
                            if (lockStates & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = lockStates & text.Codes.modifierCodes[lockNames[i]];
                            }
                        }
                    }
                    else if (d) {
                        keyShiftState |= v;
                        for (i = 0; i < lockNames.length; i++) {
                            if (v & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = true;
                            }
                        }
                    }
                    else {
                        keyShiftState &= ~v;
                        for (i = 0; i < lockNames.length; i++) {
                            if (v & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = false;
                            }
                        }
                    }
                    this.layerId = this.getLayerId(keyShiftState);
                    return true;
                };
                KeyboardProcessor.prototype.getLayerId = function (modifier) {
                    return keyman.keyboards.Layouts.getLayerId(modifier);
                };
                /**
                 * Select the OSK's next keyboard layer based upon layer switching keys as a default
                 * The next layer will be determined from the key name unless otherwise specifed
                 *
                 *  @param  {string}                    keyName     key identifier
                 *  @param  {number|string|undefined}   nextLayerIn optional next layer identifier
                 *  @return {boolean}                               return true if keyboard layer changed
                 */
                KeyboardProcessor.prototype.selectLayer = function (keyEvent, fromNameOnly) {
                    if (fromNameOnly === void 0) { fromNameOnly = false; }
                    var keyName = keyEvent.kName;
                    var nextLayer = fromNameOnly ? null : keyEvent.kNextLayer;
                    var isChiral = this.activeKeyboard && this.activeKeyboard.isChiral;
                    // Layer must be identified by name, not number (27/08/2015)
                    if (typeof nextLayer == 'number') {
                        nextLayer = this.getLayerId(nextLayer * 0x10);
                    }
                    // Identify next layer, if required by key
                    if (!nextLayer) {
                        switch (keyName) {
                            case 'K_LSHIFT':
                            case 'K_RSHIFT':
                            case 'K_SHIFT':
                                nextLayer = 'shift';
                                break;
                            case 'K_LCONTROL':
                            case 'K_LCTRL':
                                if (isChiral) {
                                    nextLayer = 'leftctrl';
                                    break;
                                }
                            case 'K_RCONTROL':
                            case 'K_RCTRL':
                                if (isChiral) {
                                    nextLayer = 'rightctrl';
                                    break;
                                }
                            case 'K_CTRL':
                                nextLayer = 'ctrl';
                                break;
                            case 'K_LMENU':
                            case 'K_LALT':
                                if (isChiral) {
                                    nextLayer = 'leftalt';
                                    break;
                                }
                            case 'K_RMENU':
                            case 'K_RALT':
                                if (isChiral) {
                                    nextLayer = 'rightalt';
                                    break;
                                }
                            case 'K_ALT':
                                nextLayer = 'alt';
                                break;
                            case 'K_ALTGR':
                                if (isChiral) {
                                    nextLayer = 'leftctrl-rightalt';
                                }
                                else {
                                    nextLayer = 'ctrl-alt';
                                }
                                break;
                            case 'K_CURRENCIES':
                            case 'K_NUMERALS':
                            case 'K_SHIFTED':
                            case 'K_UPPER':
                            case 'K_LOWER':
                            case 'K_SYMBOLS':
                                nextLayer = 'default';
                                break;
                        }
                    }
                    // If no key corresponding to a layer transition is pressed, maintain the current layer.
                    if (!nextLayer) {
                        return false;
                    }
                    // Change layer and refresh OSK
                    this.updateLayer(keyEvent, nextLayer);
                    return true;
                };
                /**
                 * Sets the new layer id, allowing for toggling shift/ctrl/alt while preserving the remainder
                 * of the modifiers represented by the current layer id (where applicable)
                 *
                 * @param       {string}      id      layer id (e.g. ctrlshift)
                 */
                KeyboardProcessor.prototype.updateLayer = function (keyEvent, id) {
                    var activeLayer = this.layerId;
                    var s = activeLayer;
                    // Do not change layer unless needed (27/08/2015)
                    if (id == activeLayer && keyEvent.device.formFactor != keyman.utils.FormFactor.Desktop) {
                        return false;
                    }
                    var idx = id;
                    var i;
                    if (keyEvent.device.formFactor == keyman.utils.FormFactor.Desktop) {
                        // Need to test if target layer is a standard layer (based on the plain 'default')
                        var replacements = ['leftctrl', 'rightctrl', 'ctrl', 'leftalt', 'rightalt', 'alt', 'shift'];
                        for (i = 0; i < replacements.length; i++) {
                            // Don't forget to remove the kebab-case hyphens!
                            idx = idx.replace(replacements[i] + '-', '');
                            idx = idx.replace(replacements[i], '');
                        }
                        // If we are presently on the default layer, drop the 'default' and go straight to the shifted mode.
                        // If on a common symbolic layer, drop out of symbolic mode and go straight to the shifted mode.
                        if (activeLayer == 'default' || activeLayer == 'numeric' || activeLayer == 'symbol' || activeLayer == 'currency' || idx != '') {
                            s = id;
                        }
                        // Otherwise, we are based upon a layer that accepts modifier variations.
                        // Modify the layer according to the current state and key pressed.
                        //
                        // TODO:  Consider:  should this ever be allowed for a base layer other than 'default'?  If not,
                        // if(idx == '') with accompanying if-else structural shift would be a far better test here.
                        else {
                            // Save our current modifier state.
                            var modifier = KeyboardProcessor.getModifierState(s);
                            // Strip down to the base modifiable layer.
                            for (i = 0; i < replacements.length; i++) {
                                // Don't forget to remove the kebab-case hyphens!
                                s = s.replace(replacements[i] + '-', '');
                                s = s.replace(replacements[i], '');
                            }
                            // Toggle the modifier represented by our input argument.
                            switch (id) {
                                case 'shift':
                                    modifier ^= text.Codes.modifierCodes['SHIFT'];
                                    break;
                                case 'leftctrl':
                                    modifier ^= text.Codes.modifierCodes['LCTRL'];
                                    break;
                                case 'rightctrl':
                                    modifier ^= text.Codes.modifierCodes['RCTRL'];
                                    break;
                                case 'ctrl':
                                    modifier ^= text.Codes.modifierCodes['CTRL'];
                                    break;
                                case 'leftalt':
                                    modifier ^= text.Codes.modifierCodes['LALT'];
                                    break;
                                case 'rightalt':
                                    modifier ^= text.Codes.modifierCodes['RALT'];
                                    break;
                                case 'alt':
                                    modifier ^= text.Codes.modifierCodes['ALT'];
                                    break;
                                default:
                                    s = id;
                            }
                            // Combine our base modifiable layer and attach the new modifier variation info to obtain our destination layer.
                            if (s != 'default') {
                                if (s == '') {
                                    s = this.getLayerId(modifier);
                                }
                                else {
                                    s = this.getLayerId(modifier) + '-' + s;
                                }
                            }
                        }
                        if (s == '') {
                            s = 'default';
                        }
                    }
                    else {
                        // Mobile form-factor.  Either the layout is specified by a keyboard developer with direct layer name references
                        // or all layers are accessed via subkey of a single layer-shifting key - no need for modifier-combining logic.
                        s = id;
                    }
                    var layout = this.activeKeyboard.layout(keyEvent.device.formFactor);
                    if (layout.getLayer(s)) {
                        this.layerId = s;
                    }
                    else {
                        this.layerId = 'default';
                    }
                };
                KeyboardProcessor.isModifier = function (Levent) {
                    switch (Levent.Lcode) {
                        case 16: //"K_SHIFT":16,"K_CONTROL":17,"K_ALT":18
                        case 17:
                        case 18:
                        case 20: //"K_CAPS":20, "K_NUMLOCK":144,"K_SCROLL":145
                        case 144:
                        case 145:
                            return true;
                        default:
                            return false;
                    }
                };
                // Returns true if the key event is a modifier press, allowing keyPress to return selectively
                // in those cases.
                KeyboardProcessor.prototype.doModifierPress = function (Levent, outputTarget, isKeyDown) {
                    if (!this.activeKeyboard) {
                        return false;
                    }
                    if (Levent.Lcode == 8) {
                        // I3318 (always clear deadkeys after backspace)
                        outputTarget.deadkeys().clear();
                    }
                    else if (KeyboardProcessor.isModifier(Levent)) {
                        // For eventual integration - we bypass an OSK update for physical keystrokes when in touch mode.
                        this.activeKeyboard.notify(Levent.Lcode, outputTarget, isKeyDown ? 1 : 0);
                        if (!Levent.device.touchable) {
                            return this._UpdateVKShift(Levent, Levent.Lcode - 15, 1); // I2187
                        }
                        else {
                            return true;
                        }
                    }
                    if (Levent.LmodifierChange) {
                        this.activeKeyboard.notify(0, outputTarget, 1);
                        this._UpdateVKShift(Levent, 0, 1);
                    }
                    // No modifier keypresses detected.
                    return false;
                };
                KeyboardProcessor.prototype.resetContext = function () {
                    this.layerId = 'default';
                    this.keyboardInterface.resetContextCache();
                    this._UpdateVKShift(null, 15, 0);
                };
                ;
                KeyboardProcessor.prototype.setNumericLayer = function (device) {
                    var layout = this.activeKeyboard.layout(device.formFactor);
                    if (layout.getLayer('numeric')) {
                        this.layerId = 'numeric';
                    }
                };
                ;
                KeyboardProcessor.DEFAULT_OPTIONS = {
                    baseLayout: 'us'
                };
                return KeyboardProcessor;
            }());
            text.KeyboardProcessor = KeyboardProcessor;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
(function () {
    var ns = com.keyman.text;
    // Let the Keyboard Processor be available both in the browser and in Node.
    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = ns.KeyboardProcessor;
        //@ts-ignore
        ns.KeyboardProcessor.com = com; // Export the root namespace so that all KeyboardProcessor classes are accessible by unit tests.
    }
}());
///<reference path="index.ts" />
///<reference path="../node_modules/@keymanapp/keyboard-processor/src/text/keyboardProcessor.ts" />
var KMWRecorder;
(function (KMWRecorder) {
    var NodeProctor = /** @class */ (function (_super) {
        __extends(NodeProctor, _super);
        function NodeProctor(keyboard, device, assert) {
            var _this = _super.call(this, device, assert) || this;
            _this.__debug = false;
            _this.keyboard = keyboard;
            return _this;
        }
        NodeProctor.prototype.beforeAll = function () {
            //
        };
        NodeProctor.prototype.before = function () {
            //
        };
        NodeProctor.prototype.compatibleWithSuite = function (testSuite) {
            // Original-version tests did not supply core-compatible KeyEvent data.
            return !testSuite.specVersion.equals(KMWRecorder.KeyboardTest.FALLBACK_VERSION);
        };
        Object.defineProperty(NodeProctor.prototype, "debugMode", {
            get: function () {
                return this.__debug;
            },
            set: function (value) {
                this.__debug = value;
            },
            enumerable: true,
            configurable: true
        });
        NodeProctor.prototype.matchesTestSet = function (testSet) {
            // KeyboardProcessor is abstract enough to run tests aimed at any platform.
            return true;
        };
        NodeProctor.prototype.simulateSequence = function (sequence, target) {
            // Start with an empty OutputTarget and a fresh KeyboardProcessor.
            if (!target) {
                target = new com.keyman.text.Mock();
            }
            // Establish a fresh processor, setting its keyboard appropriately for the test.
            var processor = new com.keyman.text.KeyboardProcessor();
            processor.activeKeyboard = this.keyboard;
            if (sequence instanceof KMWRecorder.RecordedKeystrokeSequence) {
                for (var _i = 0, _a = sequence.inputs; _i < _a.length; _i++) {
                    var keystroke = _a[_i];
                    var keyEvent = void 0;
                    if (keystroke instanceof KMWRecorder.RecordedPhysicalKeystroke) {
                        // Use the keystroke's stored data to reconstruct the KeyEvent.
                        keyEvent = {
                            Lcode: keystroke.keyCode,
                            Lmodifiers: keystroke.modifiers,
                            LmodifierChange: keystroke.modifierChanged,
                            vkCode: keystroke.vkCode,
                            Lstates: keystroke.states,
                            kName: '',
                            device: this.device,
                            isSynthetic: false,
                            LisVirtualKey: this.keyboard.definesPositionalOrMnemonic // Only false for 1.0 keyboards.
                        };
                    }
                    else if (keystroke instanceof KMWRecorder.RecordedSyntheticKeystroke) {
                        var key = this.keyboard.layout(this.device.formFactor).getLayer(keystroke.layer).getKey(keystroke.keyName);
                        keyEvent = key.constructKeyEvent(processor, this.device);
                    }
                    // Fill in the final details of the KeyEvent...
                    keyEvent.device = this.device;
                    // And now, execute the keystroke!
                    // We don't care too much about particularities of per-keystroke behavior yet.
                    // ... we _could_ if we wanted to, though.  The framework is mostly in place; 
                    // it's a matter of actually adding the feature.
                    var ruleBehavior = processor.processKeystroke(keyEvent, target);
                    if (this.debugMode) {
                        console.log(JSON.stringify(target, null, '  '));
                        console.log(JSON.stringify(ruleBehavior, null, '  '));
                    }
                }
            }
            else {
                throw new Error("NodeProctor only supports RecordedKeystrokeSequences for testing at present.");
            }
            return target.getText();
        };
        return NodeProctor;
    }(KMWRecorder.Proctor));
    KMWRecorder.NodeProctor = NodeProctor;
})(KMWRecorder || (KMWRecorder = {}));
// Export the namespace itself, giving access to all contained classes.
module.exports = KMWRecorder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZVByb2N0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvQGtleW1hbmFwcC93ZWItZW52aXJvbm1lbnQvZW52aXJvbm1lbnQuaW5jLnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAvd2ViLXV0aWxzL3NyYy9kZWVwQ29weS50cyIsIi4uL25vZGVfbW9kdWxlcy9Aa2V5bWFuYXBwL3dlYi11dGlscy9zcmMvZ2xvYmFsT2JqZWN0LnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAvd2ViLXV0aWxzL3NyYy92ZXJzaW9uLnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAvd2ViLXV0aWxzL3NyYy9rbXdzdHJpbmcudHMiLCIuLi9ub2RlX21vZHVsZXMvQGtleW1hbmFwcC93ZWItdXRpbHMvc3JjL2RldmljZVNwZWMudHMiLCIuLi9ub2RlX21vZHVsZXMvQGtleW1hbmFwcC93ZWItdXRpbHMvc3JjL2luZGV4LnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAva2V5Ym9hcmQtcHJvY2Vzc29yL3NyYy90ZXh0L2RlYWRrZXlzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAva2V5Ym9hcmQtcHJvY2Vzc29yL3NyYy90ZXh0L291dHB1dFRhcmdldC50cyIsIi4uL25vZGVfbW9kdWxlcy9Aa2V5bWFuYXBwL2tleWJvYXJkLXByb2Nlc3Nvci9zcmMvdGV4dC9rZXlFdmVudC50cyIsIi4uL3NyYy9wcm9jdG9yLnRzIiwiLi4vc3JjL2luZGV4LnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAva2V5Ym9hcmQtcHJvY2Vzc29yL3NyYy90ZXh0L2NvZGVzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAva2V5Ym9hcmQtcHJvY2Vzc29yL3NyYy90ZXh0L3J1bGVCZWhhdmlvci50cyIsIi4uL25vZGVfbW9kdWxlcy9Aa2V5bWFuYXBwL2tleWJvYXJkLXByb2Nlc3Nvci9zcmMvdGV4dC9kZWZhdWx0T3V0cHV0LnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAva2V5Ym9hcmQtcHJvY2Vzc29yL3NyYy9rZXlib2FyZHMvZGVmYXVsdExheW91dHMudHMiLCIuLi9ub2RlX21vZHVsZXMvQGtleW1hbmFwcC9rZXlib2FyZC1wcm9jZXNzb3Ivc3JjL2tleWJvYXJkcy9hY3RpdmVMYXlvdXQudHMiLCIuLi9ub2RlX21vZHVsZXMvQGtleW1hbmFwcC9rZXlib2FyZC1wcm9jZXNzb3Ivc3JjL3RleHQvc3lzdGVtU3RvcmVzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAva2V5Ym9hcmQtcHJvY2Vzc29yL3NyYy90ZXh0L2tiZEludGVyZmFjZS50cyIsIi4uL25vZGVfbW9kdWxlcy9Aa2V5bWFuYXBwL2tleWJvYXJkLXByb2Nlc3Nvci9zcmMva2V5Ym9hcmRzL2tleWJvYXJkLnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAva2V5Ym9hcmQtcHJvY2Vzc29yL3NyYy90ZXh0L2tleU1hcHBpbmcudHMiLCIuLi9ub2RlX21vZHVsZXMvQGtleW1hbmFwcC9rZXlib2FyZC1wcm9jZXNzb3Ivc3JjL3RleHQva2V5Ym9hcmRQcm9jZXNzb3IudHMiLCIuLi9zcmMvbm9kZVByb2N0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscUNBQXFDO0FBQ3JDLElBQVUsR0FBRyxDQUtaO0FBTEQsV0FBVSxHQUFHO0lBQUMsSUFBQSxNQUFNLENBS25CO0lBTGEsV0FBQSxNQUFNO1FBQUMsSUFBQSxXQUFXLENBSy9CO1FBTG9CLFdBQUEsV0FBVztZQUNuQixtQkFBTyxHQUFHLE1BQU0sQ0FBQztZQUNqQixpQkFBSyxHQUFHLEVBQUUsQ0FBQztZQUNYLHVCQUFXLEdBQUcsT0FBTyxDQUFDO1lBQ3RCLDBCQUFjLEdBQUcsNkJBQTZCLENBQUM7UUFDNUQsQ0FBQyxFQUxvQixXQUFXLEdBQVgsa0JBQVcsS0FBWCxrQkFBVyxRQUsvQjtJQUFELENBQUMsRUFMYSxNQUFNLEdB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RUFBQyxFQUFFO29CQUNuQyxRQUFRLEVBQUMsRUFBRSxFQUFDLE9BQU8sRUFBQyxFQUFFLEVBQUMsUUFBUSxFQUFDLEVBQUUsRUFBQyxRQUFRLEVBQUMsRUFBRSxFQUFDLE1BQU0sRUFBQyxFQUFFO29CQUN4RCxTQUFTLEVBQUMsRUFBRSxFQUFDLFFBQVEsRUFBQyxFQUFFLEVBQUMsT0FBTyxFQUFDLEVBQUUsRUFBQyxTQUFTLEVBQUMsRUFBRSxFQUFDLFFBQVEsRUFBQyxFQUFFO29CQUM1RCxPQUFPLEVBQUMsRUFBRSxFQUFDLE9BQU8sRUFBQyxFQUFFLEVBQUMsUUFBUSxFQUFDLEVBQUUsRUFBQyxLQUFLLEVBQUMsRUFBRTtvQkFDMUMsS0FBSyxFQUFDLEVBQUUsRUFBQyxLQUFLLEVBQUMsRUFBRSxFQUFDLEtBQUssRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFDLEVBQUUsRUFBQyxLQUFLLEVBQUMsRUFBRSxFQUFDLEtBQUssRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFDLEVBQUU7b0JBQzlELEtBQUssRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFDLEVBQUUsRUFBQyxLQUFLLEVBQUMsRUFBRSxFQUFDLEtBQUssRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFDLEVBQUUsRUFBQyxLQUFLLEVBQUMsRUFBRSxFQUFDLEtBQUssRUFBQyxFQUFFO29CQUM5RCxLQUFLLEVBQUMsRUFBRSxFQUFDLEtBQUssRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFDLEVBQUUsRUFBQyxLQUFLLEVBQUMsRUFBRSxFQUFDLEtBQUssRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFDLEVBQUUsRUFBQyxLQUFLLEVBQUMsRUFBRTtvQkFDOUQsS0FBSyxFQUFDLEVBQUUsRUFBQyxLQUFLLEVBQUMsRUFBRSxFQUFDLEtBQUssRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFDLEVBQUUsRUFBQyxLQUFLLEVBQUMsRUFBRSxFQUFDLEtBQUssRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFDLEVBQUU7b0JBQzlELEtBQUssRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFD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SUFBSSxFQUFFLEtBQUssRUFBRTs0Q0FDZixFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7NENBQ2YsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFOzRDQUNmLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRTs0Q0FDZixFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7NENBQ2YsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFOzRDQUNmLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRTs0Q0FDZixFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7NENBQ2YsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFOzRDQUNmLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTs0Q0FDbkIsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFOzRDQUNuQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRTt5Q0FDL0I7cUNBQ0o7b0NBQ0Q7d0NBQ0ksSUFBSSxFQUFFLEdBQUc7d0NBQ1QsS0FBSyxFQUFFOzRDQUNILEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFOzRDQUM1QixFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7NENBQ2YsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFOzRDQUNmLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRTs0Q0FDZixFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7NENBQ2YsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFOzRDQUNmLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRTs0Q0FDZixFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7NENBQ2YsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFOzRDQUNmLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTs0Q0FDbkIsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFOzRDQUNuQixFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRTt5Q0FDdkM7cUNBQ0o7b0NBQ0Q7d0NBQ0ksSUFBSSxFQUFFLEdBQUc7d0NBQ1Qs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RUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUNoQixFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNoQixFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNmLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUM7Z0JBQ2hCLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2YsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDaEIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFFaEIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDakIsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNmLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2YsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNmLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2YsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNmLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2YsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZixFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNoQixFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNmLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2YsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNmLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2YsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNmLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2YsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNmLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUM7Z0JBQ2pCLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUM7Z0JBQ2pCLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUM7Z0JBQ2pCLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2YsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNmLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2YsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNm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b0JBQzlFLDhFQUE4RTtvQkFDOUUsZ0RBQWdEO29CQUNoRCxJQUFJLFlBQVksR0FBRyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO29CQUVoRSxJQUFHLElBQUksQ0FBQyxTQUFTLEVBQUU7d0JBQ2pCLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7d0JBQ2hELE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7cUJBQ3ZEO2lCQUNGO2FBQ0Y7aUJBQU07Z0JBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyw4RUFBOEUsQ0FBQyxDQUFDO2FBQ2pHO1lBQ0QsT0FBTyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDMUIsQ0FBQztRQUVILGtCQUFDO0lBQUQsQ0FBQyxBQXZGRCxDQUFpQyxZQUFBLE9BQU8sR0F1RnZDO0lBdkZZLHVCQUFXLGNBdUZ2QixDQUFBO0FBQ0gsQ0FBQyxFQXpGUyxXQUFXLEtBQVgsV0FBVyxRQXlGcEI7QUFFRCx1RUFBdUU7QUFDdkUsTUFBTSxDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvL0F1dG9nZW5lcmF0ZWQgZmlsZSAtIGRvIG5vdCBtb2RpZnkhXG5uYW1lc3BhY2UgY29tLmtleW1hbi5lbnZpcm9ubWVudCB7XG4gIGV4cG9ydCB2YXIgVkVSU0lPTiA9IFwiMTUuMFwiO1xuICBleHBvcnQgdmFyIEJVSUxEID0gODY7XG4gIGV4cG9ydCB2YXIgRU5WSVJPTk1FTlQgPSBcImxvY2FsXCI7XG4gIGV4cG9ydCB2YXIgU0VOVFJZX1JFTEVBU0UgPSBcInJlbGVhc2UtMTUuMC44Ni1hbHBoYS1sb2NhbFwiO1xufVxuXG4iLCJuYW1lc3BhY2UgY29tLmtleW1hbi51dGlscyB7XHJcbiAgLyoqXHJcbiAgICogRnVuY3Rpb24gICAgIGRlZXBDb3B5XHJcbiAgICogU2NvcGUgICAgICAgIFByaXZhdGVcclxuICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gICAgICBwICAgICAgICAgICBvYmplY3QgdG8gY29weVxyXG4gICAqIEBwYXJhbSAgICAgICB7QXJyYXk9fSAgICAgIGMwICAgICAgICAgIGFycmF5IG1lbWJlciBiZWluZyBjb3BpZWRcclxuICAgKiBAcmV0dXJuICAgICAge09iamVjdH0gICAgICAgICAgICAgICAgICBjbG9uZSAoJ2RlZXAgY29weScpIG9mIG9iamVjdFxyXG4gICAqIERlc2NyaXB0aW9uICBNYWtlcyBhbiBhY3R1YWwgY29weSAobm90IGEgcmVmZXJlbmNlKSBvZiBhbiBvYmplY3QsIGNvcHlpbmcgc2ltcGxlIG1lbWJlcnMsXHJcbiAgICogICAgICAgICAgICAgIGFycmF5cyBhbmQgbWVtYmVyIG9iamVjdHMgYnV0IG5vdCBmdW5jdGlvbnMsIHNvIHVzZSB3aXRoIGNhcmUhXHJcbiAgICovXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5PFQ+KHA6VCwgYzA/KTogVCB7XHJcbiAgICB2YXIgYyA9IGMwIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgaSBpbiBwKSB7XHJcbiAgICAgIGlmKHR5cGVvZiBwW2ldID09PSAnb2JqZWN0JyAmJiBwW2ldICE9IG51bGwpIHtcclxuICAgICAgICBjW2ldID0gKHBbaV0uY29uc3RydWN0b3IgPT09IEFycmF5ICkgPyBbXSA6IHt9O1xyXG4gICAgICAgIGRlZXBDb3B5KHBbaV0sY1tpXSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY1tpXSA9IHBbaV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYztcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgY29tLmtleW1hbi51dGlscyB7XHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgYmFzZSBnbG9iYWwgb2JqZWN0IGF2YWlsYWJsZSB0byB0aGUgY3VycmVudCBKUyBwbGF0Zm9ybS5cclxuICAgKiAtIEluIGJyb3dzZXJzLCByZXR1cm5zIGB3aW5kb3dgLlxyXG4gICAqIC0gSW4gV2ViV29ya2VycywgcmV0dXJucyBgc2VsZmAuXHJcbiAgICogLSBJbiBOb2RlLCByZXR1cm5zIGBnbG9iYWxgLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRHbG9iYWxPYmplY3QoKTogdHlwZW9mIGdsb2JhbFRoaXMge1xyXG4gICAgLy8gRXZlcmdyZWVuIGJyb3dzZXJzIGhhdmUgc3RhcnRlZCBkZWZpbmluZyAnZ2xvYmFsVGhpcycuICBcclxuICAgIC8vIFJlZmVyIHRvIGh0dHBzOi8vZGV2YmxvZ3MubWljcm9zb2Z0LmNvbS90eXBlc2NyaXB0L2Fubm91bmNpbmctdHlwZXNjcmlwdC0zLTQvI3R5cGUtY2hlY2tpbmctZm9yLWdsb2JhbHRoaXNcclxuICAgIC8vIGFuZCBpdHMgcmVmZXJlbmNlZCBwb2x5ZmlsbC4gIFNhaWQgcG9seWZpbGwgaXMgdmVyeSBjb21wbGV4LCBzbyB3ZSBvcHQgZm9yIHRoaXMgZmFyIGxlYW5lciB2YXJpYW50LlxyXG4gICAgaWYodHlwZW9mIGdsb2JhbFRoaXMgIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7ICAvLyBOb3QgYXZhaWxhYmxlIGluIElFIG9yIG9sZGVyIEVkZ2UgdmVyc2lvbnNcclxuICAgICAgLy8gQHRzLWlnbm9yZSAoVFMgd2lsbCB0aHJvdyBlcnJvcnMgZm9yIHdoYXRldmVyIHBsYXRmb3JtIHdlJ3JlIG5vdCBjb21waWxpbmcgZm9yLilcclxuICAgIH0gZWxzZSBpZih0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgcmV0dXJuIHdpbmRvdzsgLy8gVGhlIGJyb3dzZXItYmFzZWQgY2xhc3NpY1xyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICB9IGVsc2UgaWYodHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICByZXR1cm4gc2VsZjsgLy8gV2ViV29ya2VyIGdsb2JhbFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQXNzdW1wdGlvbiAtIGlmIG5laXRoZXIgb2YgdGhlIGFib3ZlIGV4aXN0LCB3ZSdyZSBpbiBOb2RlLCBmb3IgdW5pdC10ZXN0aW5nLlxyXG4gICAgICAvLyBOb2RlIGRvZXNuJ3QgaGF2ZSBhcyBtYW55IG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgYXMgdGhlIG90aGVyIHR3bywgYnV0IHdoYXQgXHJcbiAgICAgIC8vIG1hdHRlcnMgZm9yIHVzIGlzIHRoYXQgaXQncyB0aGUgYmFzZSBnbG9iYWwuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFNvbWUgb3RoZXIgaGVhZGxlc3MgSlMgc29sdXRpb25zIHVzZSAndGhpcycgaW5zdGVhZCwgYnV0IE5vZGUncyBlbm91Z2ggZm9yIG91ciBuZWVkcy5cclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICByZXR1cm4gKGdsb2JhbCBhcyBhbnkpIGFzIHR5cGVvZiBnbG9iYWxUaGlzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIEVuc3VyZSB0aGF0IHRoaXMgY2xhc3MgY29udGFpbnMgbm8gcmVmZXJlbmNlIGludG8gY29yZSBLTVcgY29kZSAtIGl0IGlzIHJlZmVyZW5jZWRcclxuLy8gYnkgY29tcG9uZW50cyBpbnRlbmRlZCB0byBiZSBtb2R1bGFyIGFuZCBwb3NzaWJsZSB0byBzZXBhcmF0ZSBmcm9tIGNvcmUgS01XLlxyXG5cclxubmFtZXNwYWNlIGNvbS5rZXltYW4udXRpbHMge1xyXG4gIC8vIERvdHRlZC1kZWNpbWFsIHZlcnNpb25cclxuICBleHBvcnQgY2xhc3MgVmVyc2lvbiB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENVUlJFTlQgPSBuZXcgVmVyc2lvbihjb20ua2V5bWFuLmVudmlyb25tZW50LlZFUlNJT04pO1xyXG5cclxuICAgIC8vIFJlcHJlc2VudHMgYSBkZWZhdWx0IHZlcnNpb24gdmFsdWUgZm9yIGtleWJvYXJkcyBjb21waWxlZCBiZWZvcmUgdGhpcyB3YXMgY29tcGlsZWQgaW50byBrZXlib2FyZHMuXHJcbiAgICAvLyBUaGUgZXhhY3QgdmVyc2lvbiBpcyB1bmtub3duIGF0IHRoaXMgcG9pbnQsIGJ1dCB0aGUgdmFsdWUgaXMgXCJnb29kIGVub3VnaFwiIGZvciB3aGF0IHdlIG5lZWQuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFVkVMT1BFUl9WRVJTSU9OX0ZBTExCQUNLID0gbmV3IFZlcnNpb24oWzksIDAsIDBdKTtcclxuXHJcbiAgICAvLyBGb3IgMTIuMCwgdGhlIG9sZCBkZWZhdWx0IGJlaGF2aW9yIG9mIGFkZGluZyBtaXNzaW5nIGtleWNhcHMgdG8gdGhlIGRlZmF1bHQgbGF5ZXJzIHdhcyByZW1vdmVkLFxyXG4gICAgLy8gYXMgaXQgcmVzdWx0cyBpbiB1bmV4cGVjdGVkLCBidWctbGlrZSBiZWhhdmlvciBmb3Iga2V5Ym9hcmQgZGVzaWduZXJzIHdoZW4gaXQgaXMgdW53YW50ZWQuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE5PX0RFRkFVTFRfS0VZQ0FQUyA9IG5ldyBWZXJzaW9uKFsxMiwgMF0pO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTUFDX1BPU1NJQkxFX0lQQURfQUxJQVMgPSBuZXcgVmVyc2lvbihbMTAsIDE1XSk7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb21wb25lbnRzOiBudW1iZXJbXVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHZlcnNpb24gaW5mb3JtYXRpb24sIHByZXBhcmluZyBpdCBmb3IgdXNlIGluIGNvbXBhcmlzb25zLlxyXG4gICAgICogQHBhcmFtIHRleHQgRWl0aGVyIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIHZlcnNpb24gbnVtYmVyIChleDogXCI5LjAuMFwiKSBvciBhbiBhcnJheSByZXByZXNlbnRpbmdcclxuICAgICAqICAgICAgICAgICAgIGl0cyBjb21wb25lbnRzIChleDogWzksIDAsIDBdKS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodGV4dDogU3RyaW5nIHwgbnVtYmVyW10pIHtcclxuICAgICAgLy8gSWYgYSBrZXlib2FyZCBkb2Vzbid0IHNwZWNpZnkgYSB2ZXJzaW9uLCB1c2UgdGhlIERFVkVMT1BFUl9WRVJTSU9OX0ZBTExCQUNLIHZhbHVlcy5cclxuICAgICAgaWYodGV4dCA9PT0gdW5kZWZpbmVkIHx8IHRleHQgPT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBbXS5jb25jYXQoVmVyc2lvbi5ERVZFTE9QRVJfVkVSU0lPTl9GQUxMQkFDSy5jb21wb25lbnRzKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKEFycmF5LmlzQXJyYXkodGV4dCkpIHtcclxuICAgICAgICBsZXQgY29tcG9uZW50cyA9IHRleHQgYXMgbnVtYmVyW107XHJcbiAgICAgICAgaWYoY29tcG9uZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWZXJzaW9uIHN0cmluZyBtdXN0IGhhdmUgYXQgbGVhc3QgYSBtYWpvciBhbmQgbWlub3IgY29tcG9uZW50IVwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5jb21wb25lbnRzID0gW10uY29uY2F0KGNvbXBvbmVudHMpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZWxzZSwgc3RhbmRhcmQgY29uc3RydWN0b3IgcGF0aC5cclxuICAgICAgbGV0IHBhcnRzID0gdGV4dC5zcGxpdCgnLicpO1xyXG4gICAgICBsZXQgY29tcG9uZW50QXJyYXk6IG51bWJlcltdID0gW107XHJcblxyXG4gICAgICBpZihwYXJ0cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBzdHJpbmcgbXVzdCBoYXZlIGF0IGxlYXN0IGEgbWFqb3IgYW5kIG1pbm9yIGNvbXBvbmVudCFcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvcihsZXQgaT0wOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUludChwYXJ0c1tpXSwgMTApO1xyXG4gICAgICAgIGlmKGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBzdHJpbmcgY29tcG9uZW50cyBtdXN0IGJlIG51bWVyaWNhbCFcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb21wb25lbnRBcnJheS5wdXNoKHZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50QXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG1ham9yKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG1pbm9yKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHNbMV07XHJcbiAgICB9XHJcblxyXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5qb2luKCcuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdG9KU09OKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZXF1YWxzKG90aGVyOiBWZXJzaW9uKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwcmVjZWRlcyhvdGhlcjogVmVyc2lvbik6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpIDwgMDtcclxuICAgIH1cclxuXHJcbiAgICBjb21wYXJlVG8ob3RoZXI6IFZlcnNpb24pOiBudW1iZXIge1xyXG4gICAgICAvLyBJZiB0aGUgdmVyc2lvbiBpbmZvIGRlcHRoIGRpZmZlcnMsIHdlIG5lZWQgYSBmbGFnIHRvIGluZGljYXRlIHdoaWNoIGluc3RhbmNlIGlzIHNob3J0ZXIuXHJcbiAgICAgIHZhciBpc1Nob3J0ZXI6IGJvb2xlYW4gPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoIDwgb3RoZXIuY29tcG9uZW50cy5sZW5ndGg7XHJcbiAgICAgIHZhciBtYXhEZXB0aDogbnVtYmVyID0gKHRoaXMuY29tcG9uZW50cy5sZW5ndGggPCBvdGhlci5jb21wb25lbnRzLmxlbmd0aCkgPyB0aGlzLmNvbXBvbmVudHMubGVuZ3RoIDogb3RoZXIuY29tcG9uZW50cy5sZW5ndGg7XHJcblxyXG4gICAgICB2YXIgaTogbnVtYmVyO1xyXG4gICAgICBmb3IoaSA9IDA7IGkgPCBtYXhEZXB0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gdGhpcy5jb21wb25lbnRzW2ldIC0gb3RoZXIuY29tcG9uZW50c1tpXTtcclxuICAgICAgICBpZihkZWx0YSAhPSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbG9uZ0xpc3QgPSBpc1Nob3J0ZXIgPyBvdGhlci5jb21wb25lbnRzIDogdGhpcy5jb21wb25lbnRzO1xyXG4gICAgICBkbyB7XHJcbiAgICAgICAgaWYobG9uZ0xpc3RbaV0gPiAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gaXNTaG9ydGVyID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpKys7XHJcbiAgICAgIH0gd2hpbGUgKGkgPCBsb25nTGlzdC5sZW5ndGgpO1xyXG5cclxuICAgICAgLy8gRXF1YWwuXHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8qKipcclxuICAgS2V5bWFuV2ViIDE0LjBcclxuICAgQ29weXJpZ2h0IDIwMjAgU0lMIEludGVybmF0aW9uYWxcclxuKioqL1xyXG5cclxuLypcclxuICogVE9ETzogIFJlbW92ZSB0aGlzIGZpbGUgYXMgcGFydCBvZiBhZGRyZXNzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9rZXltYW5hcHAva2V5bWFuL2lzc3Vlcy8yNDkyLlxyXG4gKi9cclxuXHJcbmludGVyZmFjZSBTdHJpbmdDb25zdHJ1Y3RvciB7XHJcbiAga213RnJvbUNoYXJDb2RlKGNwMDogbnVtYmVyKTogc3RyaW5nLFxyXG4gIF9rbXdGcm9tQ2hhckNvZGUoY3AwOiBudW1iZXIpOiBzdHJpbmcsXHJcbiAga213RW5hYmxlU3VwcGxlbWVudGFyeVBsYW5lKGJFbmFibGU6IGJvb2xlYW4pXHJcbn1cclxuXHJcbmludGVyZmFjZSBTdHJpbmcge1xyXG4gIGttd0NoYXJDb2RlQXQoY29kZVBvaW50SW5kZXg6IG51bWJlcik6IG51bWJlcixcclxuICBrbXdDaGFyQXQoY29kZVBvaW50SW5kZXg6IG51bWJlcikgOiBzdHJpbmcsXHJcbiAga213SW5kZXhPZihzZWFyY2hWYWx1ZTogc3RyaW5nLCBmcm9tSW5kZXg/OiBudW1iZXIpIDogbnVtYmVyLFxyXG4gIGttd0xhc3RJbmRleE9mKHNlYXJjaFZhbHVlOiBzdHJpbmcsIGZyb21JbmRleD86IG51bWJlcikgOiBudW1iZXIsXHJcbiAga213U2xpY2UoYmVnaW5TbGljZTogbnVtYmVyLCBlbmRTbGljZTogbnVtYmVyKSA6IHN0cmluZyxcclxuICBrbXdTdWJzdHJpbmcoc3RhcnQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpIDogc3RyaW5nLFxyXG4gIGttd1N1YnN0cihzdGFydDogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpIDogc3RyaW5nLFxyXG4gIGttd0JNUFN1YnN0cihzdGFydDogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpIDogc3RyaW5nLFxyXG4gIGttd0xlbmd0aCgpOiBudW1iZXIsXHJcbiAga213Qk1QTGVuZ3RoKCk6IG51bWJlcixcclxuICBrbXdOZXh0Q2hhcihjb2RlVW5pdEluZGV4OiBudW1iZXIpOiBudW1iZXIsXHJcbiAga213Qk1QTmV4dENoYXIoY29kZVVuaXRJbmRleDogbnVtYmVyKTogbnVtYmVyLFxyXG4gIGttd1ByZXZDaGFyKGNvZGVVbml0SW5kZXg6IG51bWJlcik6IG51bWJlcixcclxuICBrbXdCTVBQcmV2Q2hhcihjb2RlVW5pdEluZGV4OiBudW1iZXIpOiBudW1iZXIsXHJcbiAga213Q29kZVBvaW50VG9Db2RlVW5pdChjb2RlUG9pbnRJbmRleDogbnVtYmVyKSA6IG51bWJlcixcclxuICBrbXdCTVBDb2RlUG9pbnRUb0NvZGVVbml0KGNvZGVQb2ludEluZGV4OiBudW1iZXIpIDogbnVtYmVyLFxyXG4gIGttd0NvZGVVbml0VG9Db2RlUG9pbnQoY29kZVVuaXRJbmRleDogbnVtYmVyKSA6IG51bWJlcixcclxuICBrbXdCTVBDb2RlVW5pdFRvQ29kZVBvaW50KGNvZGVVbml0SW5kZXg6IG51bWJlcikgOiBudW1iZXIsXHJcbiAgX2ttd0NoYXJDb2RlQXQoY29kZVBvaW50SW5kZXg6IG51bWJlcik6IG51bWJlcixcclxuICBfa213Q2hhckF0KGNvZGVQb2ludEluZGV4OiBudW1iZXIpIDogc3RyaW5nLFxyXG4gIF9rbXdJbmRleE9mKHNlYXJjaFZhbHVlOiBzdHJpbmcsIGZyb21JbmRleD86IG51bWJlcikgOiBudW1iZXIsXHJcbiAgX2ttd0xhc3RJbmRleE9mKHNlYXJjaFZhbHVlOiBzdHJpbmcsIGZyb21JbmRleD86IG51bWJlcikgOiBudW1iZXIsXHJcbiAgX2ttd1NsaWNlKGJlZ2luU2xpY2U6IG51bWJlciwgZW5kU2xpY2U6IG51bWJlcikgOiBzdHJpbmcsXHJcbiAgX2ttd1N1YnN0cmluZyhzdGFydDogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpIDogc3RyaW5nLFxyXG4gIF9rbXdTdWJzdHIoc3RhcnQ6IG51bWJlciwgbGVuZ3RoPzogbnVtYmVyKSA6IHN0cmluZyxcclxuICBfa213TGVuZ3RoKCk6IG51bWJlcixcclxuICBfa213TmV4dENoYXIoY29kZVVuaXRJbmRleDogbnVtYmVyKTogbnVtYmVyLFxyXG4gIF9rbXdQcmV2Q2hhcihjb2RlVW5pdEluZGV4OiBudW1iZXIpOiBudW1iZXIsXHJcbiAgX2ttd0NvZGVQb2ludFRvQ29kZVVuaXQoY29kZVBvaW50SW5kZXg6IG51bWJlcikgOiBudW1iZXIsXHJcbiAgX2ttd0NvZGVVbml0VG9Db2RlUG9pbnQoY29kZVVuaXRJbmRleDogbnVtYmVyKSA6IG51bWJlcixcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBzdHJpbmcgZnJvbSBvbmUgb3IgbW9yZSBVbmljb2RlIGNoYXJhY3RlciBjb2RlcG9pbnQgdmFsdWVzIFxyXG4gKiBwYXNzZWQgYXMgaW50ZWdlciBwYXJhbWV0ZXJzLlxyXG4gKiBcclxuICogQHBhcmFtICB7bnVtYmVyfSBjcDAsLi4uICAgMSBvciBtb3JlIFVuaWNvZGUgY29kZXBvaW50cywgZS5nLiAweDAwNjUsIDB4MTAwMDBcclxuICogQHJldHVybiB7c3RyaW5nfG51bGx9ICAgICAgVGhlIG5ldyBTdHJpbmcgb2JqZWN0LlxyXG4gKi9cclxuU3RyaW5nLmttd0Zyb21DaGFyQ29kZSA9IGZ1bmN0aW9uKGNwMCkge1xyXG4gIHZhciBjaGFycyA9IFtdLCBpO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBjID0gTnVtYmVyKGFyZ3VtZW50c1tpXSk7XHJcbiAgICBpZiAoIWlzRmluaXRlKGMpIHx8IGMgPCAwIHx8IGMgPiAweDEwRkZGRiB8fCBNYXRoLmZsb29yKGMpICE9PSBjKSB7XHJcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50IFwiICsgYyk7XHJcbiAgICB9XHJcbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcclxuICAgICAgY2hhcnMucHVzaChjKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGMgLT0gMHgxMDAwMDtcclxuICAgICAgY2hhcnMucHVzaCgoYyA+PiAxMCkgKyAweEQ4MDApO1xyXG4gICAgICBjaGFycy5wdXNoKChjICUgMHg0MDApICsgMHhEQzAwKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkodW5kZWZpbmVkLCBjaGFycyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbnVtYmVyIGluZGljYXRpbmcgdGhlIFVuaWNvZGUgdmFsdWUgb2YgdGhlIGNoYXJhY3RlciBhdCB0aGUgZ2l2ZW4gXHJcbiAqIGNvZGUgcG9pbnQgaW5kZXgsIHdpdGggc3VwcG9ydCBmb3Igc3VwcGxlbWVudGFyeSBwbGFuZSBjaGFyYWN0ZXJzLlxyXG4gKiBcclxuICogQHBhcmFtICB7bnVtYmVyfSAgY29kZVBvaW50SW5kZXggIFRoZSBjb2RlIHBvaW50IGluZGV4IGludG8gdGhlIHN0cmluZyAobm90IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGNvZGUgdW5pdCBpbmRleCkgdG8gcmV0dXJuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgICBUaGUgVW5pY29kZSBjaGFyYWN0ZXIgdmFsdWVcclxuICovXHJcblN0cmluZy5wcm90b3R5cGUua213Q2hhckNvZGVBdCA9IGZ1bmN0aW9uKGNvZGVQb2ludEluZGV4KSB7XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuICB2YXIgY29kZVVuaXRJbmRleCA9IDA7XHJcbiAgXHJcbiAgaWYgKGNvZGVQb2ludEluZGV4IDwgMCB8fCBjb2RlUG9pbnRJbmRleCAgPj0gc3RyLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIE5hTjtcclxuICB9XHJcblxyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjb2RlUG9pbnRJbmRleDsgaSsrKSB7XHJcbiAgICBjb2RlVW5pdEluZGV4ID0gc3RyLmttd05leHRDaGFyKGNvZGVVbml0SW5kZXgpO1xyXG4gICAgaWYoY29kZVVuaXRJbmRleCA9PT0gbnVsbCkgcmV0dXJuIE5hTjtcclxuICB9XHJcbiAgXHJcbiAgdmFyIGZpcnN0ID0gc3RyLmNoYXJDb2RlQXQoY29kZVVuaXRJbmRleCk7XHJcbiAgaWYgKGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYgJiYgc3RyLmxlbmd0aCA+IGNvZGVVbml0SW5kZXggKyAxKSB7XHJcbiAgICB2YXIgc2Vjb25kID0gc3RyLmNoYXJDb2RlQXQoY29kZVVuaXRJbmRleCArIDEpO1xyXG4gICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xyXG4gICAgICByZXR1cm4gKChmaXJzdCAtIDB4RDgwMCkgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmlyc3Q7ICBcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNvZGUgcG9pbnQgaW5kZXggd2l0aGluIHRoZSBjYWxsaW5nIFN0cmluZyBvYmplY3Qgb2YgdGhlIGZpcnN0IG9jY3VycmVuY2VcclxuICogb2YgdGhlIHNwZWNpZmllZCB2YWx1ZSwgb3IgLTEgaWYgbm90IGZvdW5kLlxyXG4gKiBcclxuICogQHBhcmFtICB7c3RyaW5nfSAgc2VhcmNoVmFsdWUgICAgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3JcclxuICogQHBhcmFtICB7bnVtYmVyfSAgW2Zyb21JbmRleF0gICAgT3B0aW9uYWwgY29kZSBwb2ludCBpbmRleCB0byBzdGFydCBzZWFyY2hpbmcgZnJvbVxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICAgICBUaGUgY29kZSBwb2ludCBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIHNlYXJjaCB2YWx1ZVxyXG4gKi9cclxuU3RyaW5nLnByb3RvdHlwZS5rbXdJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUsIGZyb21JbmRleCkge1xyXG4gIHZhciBzdHIgPSBTdHJpbmcodGhpcyk7XHJcbiAgdmFyIGNvZGVVbml0SW5kZXggPSBzdHIuaW5kZXhPZihzZWFyY2hWYWx1ZSwgZnJvbUluZGV4KTtcclxuICBcclxuICBpZihjb2RlVW5pdEluZGV4IDwgMCkge1xyXG4gICAgcmV0dXJuIGNvZGVVbml0SW5kZXg7XHJcbiAgfVxyXG4gIFxyXG4gIHZhciBjb2RlUG9pbnRJbmRleCA9IDA7XHJcbiAgZm9yKHZhciBpID0gMDsgaSAhPT0gbnVsbCAmJiBpIDwgY29kZVVuaXRJbmRleDsgaSA9IHN0ci5rbXdOZXh0Q2hhcihpKSkgY29kZVBvaW50SW5kZXgrKztcclxuICByZXR1cm4gY29kZVBvaW50SW5kZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb2RlIHBvaW50IGluZGV4IHdpdGhpbiB0aGUgY2FsbGluZyBTdHJpbmcgb2JqZWN0IG9mIHRoZSBsYXN0IG9jY3VycmVuY2UgXHJcbiAqIG9mIHRoZSBzcGVjaWZpZWQgdmFsdWUsIG9yIC0xIGlmIG5vdCBmb3VuZC5cclxuICogXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gIHNlYXJjaFZhbHVlICAgIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yXHJcbiAqIEBwYXJhbSAge251bWJlcn0gIGZyb21JbmRleCAgICAgIE9wdGlvbmFsIGNvZGUgcG9pbnQgaW5kZXggdG8gc3RhcnQgc2VhcmNoaW5nIGZyb21cclxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgICAgVGhlIGNvZGUgcG9pbnQgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBzZWFyY2ggdmFsdWVcclxuICovXHJcblN0cmluZy5wcm90b3R5cGUua213TGFzdEluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSwgZnJvbUluZGV4KVxyXG57XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuICB2YXIgY29kZVVuaXRJbmRleCA9IHN0ci5sYXN0SW5kZXhPZihzZWFyY2hWYWx1ZSwgZnJvbUluZGV4KTtcclxuICBcclxuICBpZihjb2RlVW5pdEluZGV4IDwgMCkge1xyXG4gICAgcmV0dXJuIGNvZGVVbml0SW5kZXg7XHJcbiAgfVxyXG4gIFxyXG4gIHZhciBjb2RlUG9pbnRJbmRleCA9IDA7XHJcbiAgZm9yKHZhciBpID0gMDsgaSAhPT0gbnVsbCAmJiBpIDwgY29kZVVuaXRJbmRleDsgaSA9IHN0ci5rbXdOZXh0Q2hhcihpKSkgY29kZVBvaW50SW5kZXgrKztcclxuICByZXR1cm4gY29kZVBvaW50SW5kZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBpbiBjb2RlIHBvaW50cywgYXMgb3Bwb3NlZCB0byBjb2RlIHVuaXRzLlxyXG4gKiBcclxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgICAgVGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGluIGNvZGUgcG9pbnRzXHJcbiAqL1xyXG5TdHJpbmcucHJvdG90eXBlLmttd0xlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBzdHIgPSBTdHJpbmcodGhpcyk7XHJcbiAgXHJcbiAgaWYoc3RyLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcclxuICBcclxuICBmb3IodmFyIGkgPSAwLCBjb2RlVW5pdEluZGV4ID0gMDsgY29kZVVuaXRJbmRleCAhPT0gbnVsbDsgaSsrKSBcclxuICAgIGNvZGVVbml0SW5kZXggPSBzdHIua213TmV4dENoYXIoY29kZVVuaXRJbmRleCk7XHJcbiAgcmV0dXJuIGk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBhIHNlY3Rpb24gb2YgYSBzdHJpbmcgYW5kIHJldHVybnMgYSBuZXcgc3RyaW5nLlxyXG4gKiBcclxuICogQHBhcmFtICB7bnVtYmVyfSAgYmVnaW5TbGljZSAgICBUaGUgc3RhcnQgY29kZSBwb2ludCBpbmRleCBpbiB0aGUgc3RyaW5nIHRvIFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3QgZnJvbVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRTbGljZSAgICAgIE9wdGlvbmFsIGVuZCBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmdcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBleHRyYWN0IHRvXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICAgICAgVGhlIHN1YnN0cmluZyBhcyBzZWxlY3RlZCBieSBiZWdpblNsaWNlIGFuZFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFNsaWNlXHJcbiAqL1xyXG5TdHJpbmcucHJvdG90eXBlLmttd1NsaWNlID0gZnVuY3Rpb24oYmVnaW5TbGljZSwgZW5kU2xpY2UpIHtcclxuICB2YXIgc3RyID0gU3RyaW5nKHRoaXMpO1xyXG4gIHZhciBiZWdpblNsaWNlQ29kZVVuaXQgPSBzdHIua213Q29kZVBvaW50VG9Db2RlVW5pdChiZWdpblNsaWNlKTtcclxuICB2YXIgZW5kU2xpY2VDb2RlVW5pdCA9IHN0ci5rbXdDb2RlUG9pbnRUb0NvZGVVbml0KGVuZFNsaWNlKTtcclxuICBpZihiZWdpblNsaWNlQ29kZVVuaXQgPT09IG51bGwgfHwgZW5kU2xpY2VDb2RlVW5pdCA9PT0gbnVsbCkgXHJcbiAgICByZXR1cm4gJyc7XHJcbiAgZWxzZVxyXG4gICAgcmV0dXJuIHN0ci5zbGljZShiZWdpblNsaWNlQ29kZVVuaXQsIGVuZFNsaWNlQ29kZVVuaXQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY2hhcmFjdGVycyBpbiBhIHN0cmluZyBiZWdpbm5pbmcgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbiB0aHJvdWdoXHJcbiAqIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXHJcbiAqIFxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydCAgICAgICAgIFRoZSBzdGFydCBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmcgdG8gXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdCBmcm9tXHJcbiAqIEBwYXJhbSAge251bWJlcj19ICBsZW5ndGggICAgICAgIE9wdGlvbmFsIGxlbmd0aCB0byBleHRyYWN0XHJcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICAgICAgVGhlIHN1YnN0cmluZyBhcyBzZWxlY3RlZCBieSBzdGFydCBhbmQgbGVuZ3RoXHJcbiAqL1xyXG5TdHJpbmcucHJvdG90eXBlLmttd1N1YnN0ciA9IGZ1bmN0aW9uKHN0YXJ0LCBsZW5ndGg/KVxyXG57XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuICBpZihzdGFydCA8IDApIFxyXG4gIHtcclxuICAgIHN0YXJ0ID0gc3RyLmttd0xlbmd0aCgpICsgc3RhcnQ7XHJcbiAgfVxyXG5cdGlmKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xyXG4gIHZhciBzdGFydENvZGVVbml0ID0gc3RyLmttd0NvZGVQb2ludFRvQ29kZVVuaXQoc3RhcnQpO1xyXG4gIHZhciBlbmRDb2RlVW5pdCA9IHN0YXJ0Q29kZVVuaXQ7XHJcbiAgXHJcbiAgaWYoc3RhcnRDb2RlVW5pdCA9PT0gbnVsbCkgcmV0dXJuICcnO1xyXG4gIFxyXG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICBlbmRDb2RlVW5pdCA9IHN0ci5sZW5ndGg7XHJcbiAgfSBlbHNlIHtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgZW5kQ29kZVVuaXQgPSBzdHIua213TmV4dENoYXIoZW5kQ29kZVVuaXQpO1xyXG4gIH1cclxuICBpZihlbmRDb2RlVW5pdCA9PT0gbnVsbClcclxuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0Q29kZVVuaXQpO1xyXG4gIGVsc2VcclxuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0Q29kZVVuaXQsIGVuZENvZGVVbml0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNoYXJhY3RlcnMgaW4gYSBzdHJpbmcgYmV0d2VlbiB0d28gaW5kZXhlcyBpbnRvIHRoZSBzdHJpbmcuXHJcbiAqIFxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBpbmRleEEgICAgICAgIFRoZSBzdGFydCBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmcgdG8gXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdCBmcm9tXHJcbiAqIEBwYXJhbSAge251bWJlcn0gIGluZGV4QiAgICAgICAgVGhlIGVuZCBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmcgdG8gXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdCB0b1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgICAgIFRoZSBzdWJzdHJpbmcgYXMgc2VsZWN0ZWQgYnkgaW5kZXhBIGFuZCBpbmRleEJcclxuICovXHJcblN0cmluZy5wcm90b3R5cGUua213U3Vic3RyaW5nID0gZnVuY3Rpb24oaW5kZXhBLCBpbmRleEIpXHJcbntcclxuICB2YXIgc3RyID0gU3RyaW5nKHRoaXMpLGluZGV4QUNvZGVVbml0LGluZGV4QkNvZGVVbml0O1xyXG4gIFxyXG4gIGlmKHR5cGVvZihpbmRleEIpID09ICd1bmRlZmluZWQnKSBcclxuICB7XHJcbiAgICBpbmRleEFDb2RlVW5pdCA9IHN0ci5rbXdDb2RlUG9pbnRUb0NvZGVVbml0KGluZGV4QSk7XHJcbiAgICBpbmRleEJDb2RlVW5pdCA9ICBzdHIubGVuZ3RoOyAgICBcclxuICB9IFxyXG4gIGVsc2VcclxuICB7XHJcbiAgICBpZihpbmRleEEgPiBpbmRleEIpIHsgdmFyIGMgPSBpbmRleEE7IGluZGV4QSA9IGluZGV4QjsgaW5kZXhCID0gYzsgfVxyXG4gIFxyXG4gICAgaW5kZXhBQ29kZVVuaXQgPSBzdHIua213Q29kZVBvaW50VG9Db2RlVW5pdChpbmRleEEpO1xyXG4gICAgaW5kZXhCQ29kZVVuaXQgPSBzdHIua213Q29kZVBvaW50VG9Db2RlVW5pdChpbmRleEIpO1xyXG4gIH1cclxuICBpZihpc05hTihpbmRleEFDb2RlVW5pdCkgfHwgaW5kZXhBQ29kZVVuaXQgPT09IG51bGwpIGluZGV4QUNvZGVVbml0ID0gMDtcclxuICBpZihpc05hTihpbmRleEJDb2RlVW5pdCkgfHwgaW5kZXhCQ29kZVVuaXQgPT09IG51bGwpIGluZGV4QkNvZGVVbml0ID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoaW5kZXhBQ29kZVVuaXQsIGluZGV4QkNvZGVVbml0KTtcclxufVxyXG5cclxuLypcclxuICBIZWxwZXIgZnVuY3Rpb25zXHJcbiovXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29kZSB1bml0IGluZGV4IGZvciB0aGUgbmV4dCBjb2RlIHBvaW50IGluIHRoZSBzdHJpbmcsIGFjY291bnRpbmcgZm9yXHJcbiAqIHN1cHBsZW1lbnRhcnkgcGFpcnMgXHJcbiAqXHJcbiAqIEBwYXJhbSAge251bWJlcnxudWxsfSAgY29kZVVuaXRJbmRleCAgVGhlIGNvZGUgdW5pdCBwb3NpdGlvbiB0byBpbmNyZW1lbnRcclxuICogQHJldHVybiB7bnVtYmVyfG51bGx9ICAgICAgICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIG5leHQgY29kZSBwb2ludCBpbiB0aGUgc3RyaW5nLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIGNvZGUgdW5pdHNcclxuICovXHJcblN0cmluZy5wcm90b3R5cGUua213TmV4dENoYXIgPSBmdW5jdGlvbihjb2RlVW5pdEluZGV4KSB7XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuXHJcbiAgaWYoY29kZVVuaXRJbmRleCA9PT0gbnVsbCB8fCBjb2RlVW5pdEluZGV4IDwgMCB8fCBjb2RlVW5pdEluZGV4ID49IHN0ci5sZW5ndGggLSAxKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgXHJcbiAgdmFyIGZpcnN0ID0gc3RyLmNoYXJDb2RlQXQoY29kZVVuaXRJbmRleCk7XHJcbiAgaWYgKGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYgJiYgc3RyLmxlbmd0aCA+IGNvZGVVbml0SW5kZXggKyAxKSB7XHJcbiAgICB2YXIgc2Vjb25kID0gc3RyLmNoYXJDb2RlQXQoY29kZVVuaXRJbmRleCArIDEpO1xyXG4gICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xyXG4gICAgICBpZihjb2RlVW5pdEluZGV4ID09IHN0ci5sZW5ndGggLSAyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvZGVVbml0SW5kZXggKyAyO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY29kZVVuaXRJbmRleCArIDE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgaW5kZXggZm9yIHRoZSBwcmV2aW91cyBjb2RlIHBvaW50IGluIHRoZSBzdHJpbmcsIGFjY291bnRpbmdcclxuICogZm9yIHN1cHBsZW1lbnRhcnkgcGFpcnMgXHJcbiAqXHJcbiAqIEBwYXJhbSAge251bWJlcnxudWxsfSAgY29kZVVuaXRJbmRleCAgVGhlIGNvZGUgdW5pdCBwb3NpdGlvbiB0byBkZWNyZW1lbnRcclxuICogQHJldHVybiB7bnVtYmVyfG51bGx9ICAgICAgICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHByZXZpb3VzIGNvZGUgcG9pbnQgaW4gdGhlXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nLCBpbiBjb2RlIHVuaXRzXHJcbiovXHJcblN0cmluZy5wcm90b3R5cGUua213UHJldkNoYXIgPSBmdW5jdGlvbihjb2RlVW5pdEluZGV4KSB7XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuXHJcbiAgaWYoY29kZVVuaXRJbmRleCA9PSBudWxsIHx8IGNvZGVVbml0SW5kZXggPD0gMCB8fCBjb2RlVW5pdEluZGV4ID4gc3RyLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIFxyXG4gIHZhciBzZWNvbmQgPSBzdHIuY2hhckNvZGVBdChjb2RlVW5pdEluZGV4IC0gMSk7XHJcbiAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRiAmJiBjb2RlVW5pdEluZGV4ID4gMSkge1xyXG4gICAgdmFyIGZpcnN0ID0gc3RyLmNoYXJDb2RlQXQoY29kZVVuaXRJbmRleCAtIDIpO1xyXG4gICAgaWYoZmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRikge1xyXG4gICAgICByZXR1cm4gY29kZVVuaXRJbmRleCAtIDI7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjb2RlVW5pdEluZGV4IC0gMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgY29kZSB1bml0IGluZGV4IHRvIHRoZSBjb2RlIHBvaW50IGluZGV4IHBhc3NlZFxyXG4gKlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ8bnVsbH0gY29kZVBvaW50SW5kZXggIEEgY29kZSBwb2ludCBpbmRleCBpbiB0aGUgc3RyaW5nXHJcbiAqIEByZXR1cm4ge251bWJlcnxudWxsfSAgICAgICAgICAgICAgICAgVGhlIGNvcnJlc3BvbmRpbmcgY29kZSB1bml0IGluZGV4XHJcbiAqL1xyXG5TdHJpbmcucHJvdG90eXBlLmttd0NvZGVQb2ludFRvQ29kZVVuaXQgPSBmdW5jdGlvbihjb2RlUG9pbnRJbmRleCkge1xyXG4gIFxyXG4gIGlmKGNvZGVQb2ludEluZGV4ID09PSBudWxsKSByZXR1cm4gbnVsbDtcclxuICBcclxuICB2YXIgc3RyID0gU3RyaW5nKHRoaXMpO1xyXG4gIHZhciBjb2RlVW5pdEluZGV4ID0gMDtcclxuICBcclxuICBpZihjb2RlUG9pbnRJbmRleCA8IDApIHtcclxuICAgIGNvZGVVbml0SW5kZXggPSBzdHIubGVuZ3RoO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA+IGNvZGVQb2ludEluZGV4OyBpLS0pIFxyXG4gICAgICBjb2RlVW5pdEluZGV4ID0gc3RyLmttd1ByZXZDaGFyKGNvZGVVbml0SW5kZXgpO1x0XHJcbiAgICByZXR1cm4gY29kZVVuaXRJbmRleDtcclxuICB9XHJcbiAgXHJcbiAgaWYoY29kZVBvaW50SW5kZXggPT0gc3RyLmttd0xlbmd0aCgpKSByZXR1cm4gc3RyLmxlbmd0aDtcclxuICBcclxuICBmb3IodmFyIGkgPSAwOyBpIDwgY29kZVBvaW50SW5kZXg7IGkrKylcclxuICAgIGNvZGVVbml0SW5kZXggPSBzdHIua213TmV4dENoYXIoY29kZVVuaXRJbmRleCk7XHJcbiAgcmV0dXJuIGNvZGVVbml0SW5kZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGNvZGUgcG9pbnQgaW5kZXggdG8gdGhlIGNvZGUgdW5pdCBpbmRleCBwYXNzZWRcclxuICpcclxuICogQHBhcmFtICB7bnVtYmVyfG51bGx9ICBjb2RlVW5pdEluZGV4ICBBIGNvZGUgdW5pdCBpbmRleCBpbiB0aGUgc3RyaW5nXHJcbiAqIEByZXR1cm4ge251bWJlcnxudWxsfSAgICAgICAgICAgICAgICAgVGhlIGNvcnJlc3BvbmRpbmcgY29kZSBwb2ludCBpbmRleFxyXG4gKi9cclxuU3RyaW5nLnByb3RvdHlwZS5rbXdDb2RlVW5pdFRvQ29kZVBvaW50ID0gZnVuY3Rpb24oY29kZVVuaXRJbmRleCkge1xyXG4gIHZhciBzdHIgPSBTdHJpbmcodGhpcyk7XHJcbiAgXHJcbiAgaWYoY29kZVVuaXRJbmRleCA9PT0gbnVsbClcclxuICAgIHJldHVybiBudWxsO1xyXG4gIGVsc2UgaWYoY29kZVVuaXRJbmRleCA9PSAwKVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgZWxzZSBpZihjb2RlVW5pdEluZGV4IDwgMCkgICAgIFxyXG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoY29kZVVuaXRJbmRleCkua213TGVuZ3RoKCk7XHJcbiAgZWxzZVxyXG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCxjb2RlVW5pdEluZGV4KS5rbXdMZW5ndGgoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNoYXJhY3RlciBhdCBhIHRoZSBjb2RlIHBvaW50IGluZGV4IHBhc3NlZFxyXG4gKlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBjb2RlUG9pbnRJbmRleCAgQSBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmdcclxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFRoZSBjb3JyZXNwb25kaW5nIGNoYXJhY3RlclxyXG4gKi9cclxuU3RyaW5nLnByb3RvdHlwZS5rbXdDaGFyQXQgPSBmdW5jdGlvbihjb2RlUG9pbnRJbmRleCkge1xyXG4gIHZhciBzdHIgPSBTdHJpbmcodGhpcyk7XHJcbiAgXHJcbiAgaWYoY29kZVBvaW50SW5kZXggPj0gMCkgcmV0dXJuIHN0ci5rbXdTdWJzdHIoY29kZVBvaW50SW5kZXgsMSk7IGVsc2UgcmV0dXJuICcnO1xyXG59XHJcblxyXG4vKipcclxuICogU3RyaW5nIHByb3RvdHlwZSBsaWJyYXJ5IGV4dGVuc2lvbnMgZm9yIGJhc2ljIHBsYW5lIGNoYXJhY3RlcnMsIFxyXG4gKiB0byBzaW1wbGlmeSBlbmFibGluZyBvciBkaXNhYmxpbmcgc3VwcGxlbWVudGFyeSBwbGFuZSBmdW5jdGlvbmFsaXR5IChJMzMxOSlcclxuICovXHJcbiBcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNvZGUgdW5pdCBpbmRleCBmb3IgdGhlIG5leHQgY29kZSBwb2ludCBpbiB0aGUgc3RyaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSAge251bWJlcn0gIGNvZGVVbml0SW5kZXggICAgQSBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmdcclxuICogQHJldHVybiB7bnVtYmVyfG51bGx9ICAgICAgICAgICAgICAgICAgIFRoZSBjb3JyZXNwb25kaW5nIGNoYXJhY3RlclxyXG4gKi8gXHJcblN0cmluZy5wcm90b3R5cGUua213Qk1QTmV4dENoYXIgPSBmdW5jdGlvbihjb2RlVW5pdEluZGV4KVxyXG57XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuICBpZihjb2RlVW5pdEluZGV4IDwgMCB8fCBjb2RlVW5pdEluZGV4ID49IHN0ci5sZW5ndGggLSAxKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIGNvZGVVbml0SW5kZXggKyAxO1xyXG59ICBcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgaW5kZXggZm9yIHRoZSBwcmV2aW91cyBjb2RlIHBvaW50IGluIHRoZSBzdHJpbmdcclxuICpcclxuICogQHBhcmFtICB7bnVtYmVyfSAgY29kZVVuaXRJbmRleCAgICBBIGNvZGUgdW5pdCBpbmRleCBpbiB0aGUgc3RyaW5nXHJcbiAqIEByZXR1cm4ge251bWJlcnxudWxsfSAgICAgICAgICAgICAgICAgICBUaGUgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJcclxuICovIFxyXG5TdHJpbmcucHJvdG90eXBlLmttd0JNUFByZXZDaGFyID0gZnVuY3Rpb24oY29kZVVuaXRJbmRleClcclxue1xyXG4gIHZhciBzdHIgPSBTdHJpbmcodGhpcyk7XHJcblxyXG4gIGlmKGNvZGVVbml0SW5kZXggPD0gMCB8fCBjb2RlVW5pdEluZGV4ID4gc3RyLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBjb2RlVW5pdEluZGV4IC0gMTtcclxufSAgXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29kZSB1bml0IGluZGV4IGZvciBhIGNvZGUgcG9pbnQgaW5kZXhcclxuICpcclxuICogQHBhcmFtICB7bnVtYmVyfSAgY29kZVBvaW50SW5kZXggICBBIGNvZGUgcG9pbnQgaW5kZXggaW4gdGhlIHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgIFRoZSBjb3JyZXNwb25kaW5nIGNoYXJhY3RlclxyXG4gKi8gXHJcblN0cmluZy5wcm90b3R5cGUua213Qk1QQ29kZVBvaW50VG9Db2RlVW5pdCA9IGZ1bmN0aW9uKGNvZGVQb2ludEluZGV4KVxyXG57XHJcbiAgcmV0dXJuIGNvZGVQb2ludEluZGV4O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29kZSBwb2ludCBpbmRleCBmb3IgYSBjb2RlIHVuaXQgaW5kZXhcclxuICpcclxuICogQHBhcmFtICB7bnVtYmVyfSAgY29kZVVuaXRJbmRleCAgICBBIGNvZGUgcG9pbnQgaW5kZXggaW4gdGhlIHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgIFRoZSBjb3JyZXNwb25kaW5nIGNoYXJhY3RlclxyXG4gKi8gXHJcblN0cmluZy5wcm90b3R5cGUua213Qk1QQ29kZVVuaXRUb0NvZGVQb2ludCA9IGZ1bmN0aW9uKGNvZGVVbml0SW5kZXgpXHJcbntcclxuICByZXR1cm4gY29kZVVuaXRJbmRleDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiBhIEJNUCBzdHJpbmdcclxuICpcclxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICBUaGUgbGVuZ3RoIGluIGNvZGUgcG9pbnRzXHJcbiAqLyBcclxuU3RyaW5nLnByb3RvdHlwZS5rbXdCTVBMZW5ndGggPSBmdW5jdGlvbigpXHJcbntcclxuICB2YXIgc3RyID0gU3RyaW5nKHRoaXMpO1xyXG4gIHJldHVybiBzdHIubGVuZ3RoO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzdWJzdHJpbmcgXHJcbiAqXHJcbiAqIEBwYXJhbSAge251bWJlcn0gIG5cclxuICogQHBhcmFtICB7bnVtYmVyPX0gIGxuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgXHJcbiAqLyBcclxuU3RyaW5nLnByb3RvdHlwZS5rbXdCTVBTdWJzdHIgPSBmdW5jdGlvbihuLGxuPylcclxue1xyXG4gIHZhciBzdHI9U3RyaW5nKHRoaXMpO1xyXG4gIGlmKG4gPiAtMSkgXHJcbiAgICByZXR1cm4gc3RyLnN1YnN0cihuLGxuKTtcclxuICBlbHNlXHJcbiAgICByZXR1cm4gc3RyLnN1YnN0cihzdHIubGVuZ3RoK24sLW4pOyAgXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBzdXBwbGVtZW50YXJ5IHBsYW5lIHN0cmluZyBoYW5kbGluZ1xyXG4gKlxyXG4gKiBAcGFyYW0gIHtib29sZWFufSAgYkVuYWJsZVxyXG4gKi8gXHJcblN0cmluZy5rbXdFbmFibGVTdXBwbGVtZW50YXJ5UGxhbmUgPSBmdW5jdGlvbihiRW5hYmxlKVxyXG57XHJcbiAgdmFyIHA9U3RyaW5nLnByb3RvdHlwZTtcclxuICBTdHJpbmcuX2ttd0Zyb21DaGFyQ29kZSA9IGJFbmFibGUgPyBTdHJpbmcua213RnJvbUNoYXJDb2RlIDogU3RyaW5nLmZyb21DaGFyQ29kZTtcclxuICBwLl9rbXdDaGFyQXQgPSBiRW5hYmxlID8gcC5rbXdDaGFyQXQgOiBwLmNoYXJBdDtcclxuICBwLl9rbXdDaGFyQ29kZUF0ID0gYkVuYWJsZSA/IHAua213Q2hhckNvZGVBdCA6IHAuY2hhckNvZGVBdDtcclxuICBwLl9rbXdJbmRleE9mID0gYkVuYWJsZSA/IHAua213SW5kZXhPZiA6cC5pbmRleE9mO1xyXG4gIHAuX2ttd0xhc3RJbmRleE9mID0gYkVuYWJsZSA/IHAua213TGFzdEluZGV4T2YgOiBwLmxhc3RJbmRleE9mIDtcclxuICBwLl9rbXdTbGljZSA9IGJFbmFibGUgPyBwLmttd1NsaWNlIDogcC5zbGljZTtcclxuICBwLl9rbXdTdWJzdHJpbmcgPSBiRW5hYmxlID8gcC5rbXdTdWJzdHJpbmcgOiBwLnN1YnN0cmluZztcclxuICBwLl9rbXdTdWJzdHIgPSBiRW5hYmxlID8gcC5rbXdTdWJzdHIgOiBwLmttd0JNUFN1YnN0cjtcclxuICBwLl9rbXdMZW5ndGggPSBiRW5hYmxlID8gcC5rbXdMZW5ndGggOiBwLmttd0JNUExlbmd0aDtcclxuICBwLl9rbXdOZXh0Q2hhciA9IGJFbmFibGUgPyBwLmttd05leHRDaGFyIDogcC5rbXdCTVBOZXh0Q2hhcjtcclxuICBwLl9rbXdQcmV2Q2hhciA9IGJFbmFibGUgPyBwLmttd1ByZXZDaGFyIDogcC5rbXdCTVBQcmV2Q2hhcjtcclxuICBwLl9rbXdDb2RlUG9pbnRUb0NvZGVVbml0ID0gYkVuYWJsZSA/IHAua213Q29kZVBvaW50VG9Db2RlVW5pdCA6IHAua213Qk1QQ29kZVBvaW50VG9Db2RlVW5pdDtcclxuICBwLl9rbXdDb2RlVW5pdFRvQ29kZVBvaW50ID0gYkVuYWJsZSA/IHAua213Q29kZVVuaXRUb0NvZGVQb2ludCA6IHAua213Qk1QQ29kZVVuaXRUb0NvZGVQb2ludDtcclxufVxyXG5cclxuIiwibmFtZXNwYWNlIGNvbS5rZXltYW4udXRpbHMge1xyXG4gIGV4cG9ydCBlbnVtIEJyb3dzZXIge1xyXG4gICAgQ2hyb21lID0gJ2Nocm9tZScsXHJcbiAgICBFZGdlID0gJ2VkZ2UnLFxyXG4gICAgRmlyZWZveCA9ICdmaXJlZm94JyxcclxuICAgIE5hdGl2ZSA9ICduYXRpdmUnLCAvLyBVc2VkIGJ5IGVtYmVkZGVkIG1vZGVcclxuICAgIE9wZXJhID0gJ29wZXJhJyxcclxuICAgIFNhZmFyaSA9ICdzYWZhcmknLFxyXG4gICAgT3RoZXIgPSAnb3RoZXInXHJcbiAgfVxyXG5cclxuICBleHBvcnQgZW51bSBPcGVyYXRpbmdTeXN0ZW0ge1xyXG4gICAgV2luZG93cyA9ICd3aW5kb3dzJyxcclxuICAgIG1hY09TID0gJ21hY29zeCcsXHJcbiAgICBMaW51eCA9ICdsaW51eCcsXHJcbiAgICBBbmRyb2lkID0gJ2FuZHJvaWQnLFxyXG4gICAgaU9TID0gJ2lvcycsXHJcbiAgICBPdGhlciA9ICdvdGhlcidcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIEZvcm1GYWN0b3Ige1xyXG4gICAgRGVza3RvcCA9ICdkZXNrdG9wJyxcclxuICAgIFBob25lID0gJ3Bob25lJyxcclxuICAgIFRhYmxldCA9ICd0YWJsZXQnXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGFuIGFic3RyYWN0IHZlcnNpb24gb2YgY29tLmtleW1hbi5EZXZpY2UgdGhhdCBpcyBjb3JlLWZyaWVuZGx5LCBcclxuICAgKiBjb250YWluaW5nIG9ubHkgdGhlIGluZm9ybWF0aW9uIG5lZWRlZCBieSB3ZWItY29yZSBmb3IgdGV4dCBwcm9jZXNzaW5nIHVzZSwgZGV2b2lkXHJcbiAgICogb2YgYW55IGRpcmVjdCByZWZlcmVuY2VzIHRvIHRoZSBET00uXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIERldmljZVNwZWMge1xyXG4gICAgcmVhZG9ubHkgYnJvd3NlcjogQnJvd3NlcjtcclxuICAgIHJlYWRvbmx5IGZvcm1GYWN0b3I6IEZvcm1GYWN0b3I7XHJcbiAgICByZWFkb25seSBPUzogT3BlcmF0aW5nU3lzdGVtO1xyXG4gICAgcmVhZG9ubHkgdG91Y2hhYmxlOiBib29sZWFuO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJyb3dzZXI6IHN0cmluZywgZm9ybUZhY3Rvcjogc3RyaW5nLCBPUzogc3RyaW5nLCB0b3VjaGFibGU6IGJvb2xlYW4pIHtcclxuICAgICAgc3dpdGNoKGJyb3dzZXIudG9Mb3dlckNhc2UoKSBhcyBCcm93c2VyKSB7XHJcbiAgICAgICAgY2FzZSBCcm93c2VyLkNocm9tZTpcclxuICAgICAgICBjYXNlIEJyb3dzZXIuRWRnZTpcclxuICAgICAgICBjYXNlIEJyb3dzZXIuRmlyZWZveDpcclxuICAgICAgICBjYXNlIEJyb3dzZXIuTmF0aXZlOlxyXG4gICAgICAgIGNhc2UgQnJvd3Nlci5PcGVyYTpcclxuICAgICAgICBjYXNlIEJyb3dzZXIuU2FmYXJpOlxyXG4gICAgICAgICAgdGhpcy5icm93c2VyID0gYnJvd3Nlci50b0xvd2VyQ2FzZSgpIGFzIEJyb3dzZXI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhpcy5icm93c2VyID0gQnJvd3Nlci5PdGhlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3dpdGNoKGZvcm1GYWN0b3IudG9Mb3dlckNhc2UoKSBhcyBGb3JtRmFjdG9yKSB7XHJcbiAgICAgICAgY2FzZSBGb3JtRmFjdG9yLkRlc2t0b3A6XHJcbiAgICAgICAgY2FzZSBGb3JtRmFjdG9yLlBob25lOlxyXG4gICAgICAgIGNhc2UgRm9ybUZhY3Rvci5UYWJsZXQ6XHJcbiAgICAgICAgICB0aGlzLmZvcm1GYWN0b3IgPSBmb3JtRmFjdG9yLnRvTG93ZXJDYXNlKCkgYXMgRm9ybUZhY3RvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyAoXCJJbnZhbGlkIGZvcm0gZmFjdG9yIHNwZWNpZmllZCBmb3IgZGV2aWNlOiBcIiArIGZvcm1GYWN0b3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzd2l0Y2goT1MudG9Mb3dlckNhc2UoKSBhcyBPcGVyYXRpbmdTeXN0ZW0pIHtcclxuICAgICAgICBjYXNlIE9wZXJhdGluZ1N5c3RlbS5XaW5kb3dzLnRvTG93ZXJDYXNlKCk6XHJcbiAgICAgICAgY2FzZSBPcGVyYXRpbmdTeXN0ZW0ubWFjT1MudG9Mb3dlckNhc2UoKTpcclxuICAgICAgICBjYXNlIE9wZXJhdGluZ1N5c3RlbS5MaW51eC50b0xvd2VyQ2FzZSgpOlxyXG4gICAgICAgIGNhc2UgT3BlcmF0aW5nU3lzdGVtLkFuZHJvaWQudG9Mb3dlckNhc2UoKTpcclxuICAgICAgICBjYXNlIE9wZXJhdGluZ1N5c3RlbS5pT1MudG9Mb3dlckNhc2UoKTpcclxuICAgICAgICAgIHRoaXMuT1MgPSBPUy50b0xvd2VyQ2FzZSgpIGFzIE9wZXJhdGluZ1N5c3RlbTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aGlzLk9TID0gT3BlcmF0aW5nU3lzdGVtLk90aGVyO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLnRvdWNoYWJsZSA9IHRvdWNoYWJsZTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyBSZWZlcmVuY2VzIGFsbCB1dGlsaXR5IGluY2x1ZGVzIGZyb20gYSBzaW5nbGUgZmlsZSwgbWFraW5nIGltcG9ydC9leHBvcnQgc2ltcGxlLlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJkZWVwQ29weS50c1wiIC8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cImdsb2JhbE9iamVjdC50c1wiIC8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cInZlcnNpb24udHNcIiAvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJrbXdzdHJpbmcudHNcIiAvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJkZXZpY2VTcGVjLnRzXCIgLz4iLCJuYW1lc3BhY2UgY29tLmtleW1hbi50ZXh0IHtcclxuICAvLyBEZWZpbmVzIHRoZSBiYXNlIERlYWRrZXktdHJhY2tpbmcgb2JqZWN0LlxyXG4gIFxyXG4gIGV4cG9ydCBjbGFzcyBEZWFka2V5IHtcclxuICAgIHA6IG51bWJlcjsgIC8vIFBvc2l0aW9uIG9mIGRlYWRrZXlcclxuICAgIGQ6IG51bWJlcjsgIC8vIE51bWVyaWNhbCBpZCBvZiB0aGUgZGVhZGtleVxyXG4gICAgbzogbnVtYmVyOyAgLy8gT3JkaW5hbCB2YWx1ZSBvZiB0aGUgZGVhZGtleSAocmVzb2x2ZXMgc2FtZS1wbGFjZSBjb25mbGljdHMpXHJcbiAgICBtYXRjaGVkOiBudW1iZXI7XHJcblxyXG4gICAgc3RhdGljIG9yZGluYWxTZWVkOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBvczogbnVtYmVyLCBpZDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMucCA9IHBvcztcclxuICAgICAgdGhpcy5kID0gaWQ7XHJcbiAgICAgIHRoaXMubyA9IERlYWRrZXkub3JkaW5hbFNlZWQrKztcclxuICAgIH1cclxuXHJcbiAgICBtYXRjaChwOiBudW1iZXIsIGQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICB2YXIgcmVzdWx0OmJvb2xlYW4gPSAodGhpcy5wID09IHAgJiYgdGhpcy5kID09IGQpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubWF0Y2hlZCA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubWF0Y2hlZCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgYmVmb3JlKG90aGVyOiBEZWFka2V5KTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLm8gPCBvdGhlci5vO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb25lKCk6IERlYWRrZXkge1xyXG4gICAgICBsZXQgZGsgPSBuZXcgRGVhZGtleSh0aGlzLnAsIHRoaXMuZCk7XHJcbiAgICAgIGRrLm8gPSB0aGlzLm87XHJcblxyXG4gICAgICByZXR1cm4gZGs7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0cyB0aGUgZGVhZGtleXMgaW4gcmV2ZXJzZSBvcmRlci5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNvcnRGdW5jID0gZnVuY3Rpb24oYTogRGVhZGtleSwgYjogRGVhZGtleSkge1xyXG4gICAgICAvLyBXZSB3YW50IGRlc2NlbmRpbmcgb3JkZXIsIHNvIHdlIHdhbnQgJ2xhdGVyJyBkZWFka2V5cyBmaXJzdC5cclxuICAgICAgaWYoYS5wICE9IGIucCkge1xyXG4gICAgICAgIHJldHVybiBiLnAgLSBhLnA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGIubyAtIGEubztcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIE9iamVjdC1vcmllbnRzIGRlYWRrZXkgbWFuYWdlbWVudC5cclxuICBleHBvcnQgY2xhc3MgRGVhZGtleVRyYWNrZXIge1xyXG4gICAgZGtzOiBEZWFka2V5W10gPSBbXTtcclxuXHJcbiAgICB0b1NvcnRlZEFycmF5KCk6IERlYWRrZXlbXSB7XHJcbiAgICAgIHRoaXMuZGtzID0gdGhpcy5ka3Muc29ydChEZWFka2V5LnNvcnRGdW5jKTtcclxuICAgICAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLmRrcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xvbmUoKTogRGVhZGtleVRyYWNrZXIge1xyXG4gICAgICBsZXQgZGt0ID0gbmV3IERlYWRrZXlUcmFja2VyKCk7XHJcbiAgICAgIGxldCBka3MgPSB0aGlzLnRvU29ydGVkQXJyYXkoKTtcclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSB0byBjbG9uZSB0aGUgZGVhZGtleXMgdGhlbXNlbHZlcyAtIHRoZSBEZWFka2V5IG9iamVjdCBpcyBtdXRhYmxlLlxyXG4gICAgICBka3QuZGtzID0gW107XHJcbiAgICAgIGRrcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlOiBEZWFka2V5KSB7XHJcbiAgICAgICAgZGt0LmRrcy5wdXNoKHZhbHVlLmNsb25lKCkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBka3Q7XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uICAgICBpc01hdGNoICAgICAgXHJcbiAgICAgKiBTY29wZSAgICAgICAgUHVibGljXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBjYXJldFBvcyAgY3VycmVudCBjdXJzb3IgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgIG4gICAgICAgICBleHBlY3RlZCBvZmZzZXQgb2YgZGVhZGtleSBmcm9tIGN1cnNvclxyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgZCAgICAgICAgIGRlYWRrZXlcclxuICAgICAqIEByZXR1cm4gICAgICB7Ym9vbGVhbn0gICAgICAgICAgICAgICBUcnVlIGlmIGRlYWRrZXkgZm91bmQgc2VsZWN0ZWQgY29udGV4dCBtYXRjaGVzIHZhbFxyXG4gICAgICogRGVzY3JpcHRpb24gIE1hdGNoIGRlYWRrZXkgYXQgY3VycmVudCBjdXJzb3IgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgaXNNYXRjaChjYXJldFBvczogbnVtYmVyLCBuOiBudW1iZXIsIGQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICBpZih0aGlzLmRrcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gSTMzMThcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNwPWNhcmV0UG9zO1xyXG4gICAgICBuID0gc3AgLSBuO1xyXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5ka3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyBEb24ndCByZS1tYXRjaCBhbiBhbHJlYWR5LW1hdGNoZWQgZGVhZGtleS4gIEl0J3MgcG9zc2libGUgdG8gaGF2ZSB0d28gaWRlbnRpY2FsIFxyXG4gICAgICAgIC8vIGVudHJpZXMsIGFuZCB0aGV5IHNob3VsZCBiZSBrZXB0IHNlcGFyYXRlbHkuXHJcbiAgICAgICAgaWYodGhpcy5ka3NbaV0ubWF0Y2gobiwgZCkgJiYgIXRoaXMuZGtzW2ldLm1hdGNoZWQpIHtcclxuICAgICAgICAgIHRoaXMuZGtzW2ldLnNldCgpO1xyXG4gICAgICAgICAgLy8gQXNzdW1wdGlvbjogIHNpbmNlIHdlIG1hdGNoIHRoZSBmaXJzdCBwb3NzaWJsZSBlbnRyeSBpbiB0aGUgYXJyYXksIHdlXHJcbiAgICAgICAgICAvLyBtYXRjaCB0aGUgZW50cnkgd2l0aCB0aGUgbG93ZXIgb3JkaW5hbCAtIHRoZSAnZmlyc3QnIGRlYWRrZXkgaW4gdGhlIHBvc2l0aW9uLlxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEkzMzE4XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJlc2V0TWF0Y2hlZCgpOyAvLyBJMzMxOFxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZChkazogRGVhZGtleSkge1xyXG4gICAgICB0aGlzLmRrcyA9IHRoaXMuZGtzLmNvbmNhdChkayk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlKGRrOiBEZWFka2V5KSB7XHJcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZGtzLmluZGV4T2YoZGspO1xyXG4gICAgICB0aGlzLmRrcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICB0aGlzLmRrcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc2V0TWF0Y2hlZCgpIHtcclxuICAgICAgZm9yKGxldCBkayBvZiB0aGlzLmRrcykge1xyXG4gICAgICAgIGRrLnJlc2V0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZGVsZXRlTWF0Y2hlZCgpOiB2b2lkIHtcclxuICAgICAgZm9yKHZhciBMaSA9IDA7IExpIDwgdGhpcy5ka3MubGVuZ3RoOyBMaSsrKSB7XHJcbiAgICAgICAgaWYodGhpcy5ka3NbTGldLm1hdGNoZWQpIHtcclxuICAgICAgICAgIHRoaXMuZGtzLnNwbGljZShMaS0tLCAxKTsgLy8gRG9uJ3QgZm9yZ2V0IHRvIGRlY3JlbWVudCFcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uICAgICBhZGp1c3RQb3NpdGlvbnMgKGZvcm1lcmx5IF9EZWFka2V5QWRqdXN0UG9zKVxyXG4gICAgICogU2NvcGUgICAgICAgIFByaXZhdGVcclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgIExzdGFydCAgICAgIHN0YXJ0IHBvc2l0aW9uIGluIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgIExkZWx0YSAgICAgIGNoYXJhY3RlcnMgdG8gYWRqdXN0IGJ5ICAgXHJcbiAgICAgKiBEZXNjcmlwdGlvbiAgQWRqdXN0IHNhdmVkIHBvc2l0aW9ucyBvZiBkZWFka2V5cyBpbiBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIGFkanVzdFBvc2l0aW9ucyhMc3RhcnQ6IG51bWJlciwgTGRlbHRhOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgaWYoTGRlbHRhID09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGZvcihsZXQgZGsgb2YgdGhpcy5ka3MpIHtcclxuICAgICAgICBpZihkay5wID4gTHN0YXJ0KSB7XHJcbiAgICAgICAgICBkay5wICs9IExkZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb3VudCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5ka3MubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIERlZmluZXMgZGVhZGtleSBtYW5hZ2VtZW50IGluIGEgbWFubmVyIGF0dGFjaGFibGUgdG8gZWFjaCBlbGVtZW50IGludGVyZmFjZS5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vdGV4dC9kZWFka2V5cy50c1wiIC8+XHJcbi8vIERlZmluZXMgdGhlIEtleUV2ZW50IHR5cGUuXHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cImtleUV2ZW50LnRzXCIgLz5cclxuXHJcbi8vIEFsc28gcmVsaWVzIG9uIHN0cmluZy1leHRlbnNpb25zIHByb3ZpZGVkIGJ5IHRoZSB3ZWItdXRpbHMgcGFja2FnZS5cclxuXHJcbm5hbWVzcGFjZSBjb20ua2V5bWFuLnRleHQge1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0VHJhbnNmb3JtIGltcGxlbWVudHMgVHJhbnNmb3JtIHtcclxuICAgIHJlYWRvbmx5IGluc2VydDogc3RyaW5nO1xyXG4gICAgcmVhZG9ubHkgZGVsZXRlTGVmdDogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgZGVsZXRlUmlnaHQ/OiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoaW5zZXJ0OiBzdHJpbmcsIGRlbGV0ZUxlZnQ6IG51bWJlciwgZGVsZXRlUmlnaHQ/OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5pbnNlcnQgPSBpbnNlcnQ7XHJcbiAgICAgIHRoaXMuZGVsZXRlTGVmdCA9IGRlbGV0ZUxlZnQ7XHJcbiAgICAgIHRoaXMuZGVsZXRlUmlnaHQgPSBkZWxldGVSaWdodCB8fCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgbmlsID0gbmV3IFRleHRUcmFuc2Zvcm0oJycsIDAsIDApO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIFRyYW5zY3JpcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgdG9rZW46IG51bWJlcjtcclxuICAgIHJlYWRvbmx5IGtleXN0cm9rZTogS2V5RXZlbnQ7XHJcbiAgICByZWFkb25seSB0cmFuc2Zvcm06IFRyYW5zZm9ybTtcclxuICAgIGFsdGVybmF0ZXM6IEFsdGVybmF0ZVtdOyAvLyBjb25zdHJ1Y3RlZCBhZnRlciB0aGUgcmVzdCBvZiB0aGUgdHJhbnNjcmlwdGlvbi5cclxuICAgIHJlYWRvbmx5IHByZUlucHV0OiBNb2NrO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHRva2VuU2VlZDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihrZXlzdHJva2U6IEtleUV2ZW50LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSwgcHJlSW5wdXQ6IE1vY2ssIGFsdGVybmF0ZXM/OiBBbHRlcm5hdGVbXS8qLCByZW1vdmVkRGtzOiBEZWFka2V5W10sIGluc2VydGVkRGtzOiBEZWFka2V5W10qLykge1xyXG4gICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuID0gVHJhbnNjcmlwdGlvbi50b2tlblNlZWQrKztcclxuXHJcbiAgICAgIHRoaXMua2V5c3Ryb2tlID0ga2V5c3Ryb2tlO1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgICAgdGhpcy5hbHRlcm5hdGVzID0gYWx0ZXJuYXRlcztcclxuICAgICAgdGhpcy5wcmVJbnB1dCA9IHByZUlucHV0O1xyXG5cclxuICAgICAgdGhpcy50cmFuc2Zvcm0uaWQgPSB0aGlzLnRva2VuO1xyXG5cclxuICAgICAgLy8gQXNzaWduIHRoZSBJRCB0byBlYWNoIGFsdGVybmF0ZSwgYXMgd2VsbC5cclxuICAgICAgaWYoYWx0ZXJuYXRlcykge1xyXG4gICAgICAgIGFsdGVybmF0ZXMuZm9yRWFjaChmdW5jdGlvbihhbHQpIHtcclxuICAgICAgICAgIGFsdC5zYW1wbGUuaWQgPSB0b2tlbjtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IHR5cGUgQWx0ZXJuYXRlID0gUHJvYmFiaWxpdHlNYXNzPFRyYW5zZm9ybT47XHJcblxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBPdXRwdXRUYXJnZXQge1xyXG4gICAgcHJpdmF0ZSBfZGtzOiB0ZXh0LkRlYWRrZXlUcmFja2VyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICB0aGlzLl9ka3MgPSBuZXcgdGV4dC5EZWFka2V5VHJhY2tlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmlmaWVzIHRoYXQgdGhpcyBPdXRwdXRUYXJnZXQgaGFzIG5vIGRlZmF1bHQga2V5IHByb2Nlc3NpbmcgYmVoYXZpb3JzLiAgVGhpcyBzaG91bGQgYmUgZmFsc2VcclxuICAgICAqIGZvciBPdXRwdXRUYXJnZXRzIGJhY2tlZCBieSB3ZWIgZWxlbWVudHMgbGlrZSBIVE1MSW5wdXRFbGVtZW50IG9yIEhUTUxUZXh0QXJlYUVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGdldCBpc1N5bnRoZXRpYygpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzZXRDb250ZXh0KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRlYWRrZXlzKCkuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWFka2V5cygpOiB0ZXh0LkRlYWRrZXlUcmFja2VyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2RrcztcclxuICAgIH1cclxuXHJcbiAgICBoYXNEZWFka2V5TWF0Y2gobjogbnVtYmVyLCBkOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGVhZGtleXMoKS5pc01hdGNoKHRoaXMuZ2V0RGVhZGtleUNhcmV0KCksIG4sIGQpO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydERlYWRrZXlCZWZvcmVDYXJldChkOiBudW1iZXIpIHtcclxuICAgICAgdmFyIGRrOiBEZWFka2V5ID0gbmV3IERlYWRrZXkodGhpcy5nZXREZWFka2V5Q2FyZXQoKSwgZCk7XHJcbiAgICAgIHRoaXMuZGVhZGtleXMoKS5hZGQoZGspO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdWxkIGJlIGNhbGxlZCBieSBlYWNoIG91dHB1dCB0YXJnZXQgaW1tZWRpYXRlbHkgYmVmb3JlIHRleHQgbXV0YXRpb24gb3BlcmF0aW9ucyBvY2N1ci5cclxuICAgICAqIFxyXG4gICAgICogTWFpbnRhaW5zIHNvbHV0aW9ucyB0byBvbGQgaXNzdWVzOiAgSTMzMTgsSTMzMTlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSAgVXNlIG5lZ2F0aXZlIHZhbHVlcyBpZiBjaGFyYWN0ZXJzIHdlcmUgZGVsZXRlZCwgcG9zaXRpdmUgaWYgY2hhcmFjdGVycyB3ZXJlIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWRqdXN0RGVhZGtleXMoZGVsdGE6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmRlYWRrZXlzKCkuYWRqdXN0UG9zaXRpb25zKHRoaXMuZ2V0RGVhZGtleUNhcmV0KCksIGRlbHRhKTsgXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWVkZWQgdG8gcHJvcGVybHkgY2xvbmUgZGVhZGtleXMgZm9yIHVzZSB3aXRoIE1vY2sgZWxlbWVudCBpbnRlcmZhY2VzIHRvd2FyZCBwcmVkaWN0aXZlIHRleHQgcHVycG9zZXMuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIGRrcyAgIEFuIGV4aXN0aW5nIHNldCBvZiBkZWFka2V5cyB0byBkZWVwLWNvcHkgZm9yIHVzZSBieSB0aGlzIGVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc2V0RGVhZGtleXMoZGtzOiB0ZXh0LkRlYWRrZXlUcmFja2VyKSB7XHJcbiAgICAgIHRoaXMuX2RrcyA9IGRrcy5jbG9uZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgYmFzaWMgb3BlcmF0aW9ucyBuZWVkZWQgdG8gcmVjb25zdHJ1Y3QgdGhlIGN1cnJlbnQgT3V0cHV0VGFyZ2V0J3MgdGV4dCBmcm9tIHRoZSBwcmlvciBzdGF0ZSBzcGVjaWZpZWRcclxuICAgICAqIGJ5IGFub3RoZXIgT3V0cHV0VGFyZ2V0IGJhc2VkIG9uIHRoZWlyIHRleHQgYW5kIGNhcmV0IHBvc2l0aW9ucy5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBpcyBkZXNpZ25lZCBmb3IgdXNlIGFzIGEgXCJiZWZvcmUgYW5kIGFmdGVyXCIgY29tcGFyaXNvbiB0byBkZXRlcm1pbmUgdGhlIGVmZmVjdCBvZiBhIHNpbmdsZSBrZXlib2FyZCBydWxlIGF0IGEgdGltZS5cclxuICAgICAqIEFzIHN1Y2gsIGl0IGFzc3VtZXMgdGhhdCB0aGUgY2FyZXQgaXMgaW1tZWRpYXRlbHkgYWZ0ZXIgYW55IGluc2VydGVkIHRleHQuXHJcbiAgICAgKiBAcGFyYW0gZnJvbSBBbiBvdXRwdXQgdGFyZ2V0IChwcmVmZXJhYmx5IGEgTW9jaykgcmVwcmVzZW50aW5nIHRoZSBwcmlvciBzdGF0ZSBvZiB0aGUgaW5wdXQvb3V0cHV0IHN5c3RlbS5cclxuICAgICAqL1xyXG4gICAgYnVpbGRUcmFuc2Zvcm1Gcm9tKG9yaWdpbmFsOiBPdXRwdXRUYXJnZXQpOiBUcmFuc2Zvcm0ge1xyXG4gICAgICBsZXQgdG8gPSB0aGlzLmdldFRleHQoKTtcclxuICAgICAgbGV0IGZyb20gPSBvcmlnaW5hbC5nZXRUZXh0KCk7XHJcblxyXG4gICAgICBsZXQgZnJvbUNhcmV0ID0gb3JpZ2luYWwuZ2V0RGVhZGtleUNhcmV0KCk7XHJcbiAgICAgIGxldCB0b0NhcmV0ID0gdGhpcy5nZXREZWFka2V5Q2FyZXQoKTtcclxuXHJcbiAgICAgIC8vIFN0ZXAgMTogIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGxlZnQtZGVsZXRpb25zLlxyXG4gICAgICBsZXQgbWF4U01QTGVmdE1hdGNoID0gZnJvbUNhcmV0IDwgdG9DYXJldCA/IGZyb21DYXJldCA6IHRvQ2FyZXQ7XHJcblxyXG4gICAgICAvLyBXZSBuZWVkIHRoZSBjb3JyZXNwb25kaW5nIG5vbi1TTVAgY2FyZXQgbG9jYXRpb24gaW4gb3JkZXIgdG8gYmluYXJ5LXNlYXJjaCBlZmZpY2llbnRseS5cclxuICAgICAgLy8gKEV4YW1pbmluZyBjb2RlIHVuaXRzIGlzIG11Y2ggbW9yZSBjb21wdXRhdGlvbmFsbHkgZWZmaWNpZW50LilcclxuICAgICAgbGV0IG1heExlZnRNYXRjaCA9IHRvLl9rbXdDb2RlUG9pbnRUb0NvZGVVbml0KG1heFNNUExlZnRNYXRjaCk7XHJcblxyXG4gICAgICAvLyAxLjE6ICB1c2UgYSBub24tU01QLWF3YXJlIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBkaXZlcmdlbmNlIHBvaW50LlxyXG4gICAgICBsZXQgc3RhcnQgPSAwO1xyXG4gICAgICBsZXQgZW5kID0gbWF4TGVmdE1hdGNoOyAgLy8gdGhlIGluZGV4IEFGVEVSIHRoZSBsYXN0IHBvc3NpYmxlIG1hdGNoaW5nIGNoYXIuXHJcblxyXG4gICAgICAvLyBUaGlzIHNlYXJjaCBpcyBPKG1heExlZnRNYXRjaCkuICAxLzIgKyAxLzQgKyAxLzggKyAuLi4gY29udmVyZ2VzIHRvID0gMS5cclxuICAgICAgd2hpbGUoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICBsZXQgbWlkID0gTWF0aC5mbG9vcigoZW5kK3N0YXJ0KzEpIC8gMik7IC8vIHJvdW5kIHVwIChjb21wYXJlIG1vcmUpXHJcbiAgICAgICAgbGV0IGZyb21MZWZ0ID0gZnJvbS5zdWJzdHIoc3RhcnQsIG1pZC1zdGFydCk7XHJcbiAgICAgICAgbGV0IHRvTGVmdCAgID0gdG8uc3Vic3RyKHN0YXJ0LCBtaWQtc3RhcnQpO1xyXG5cclxuICAgICAgICBpZihmcm9tTGVmdCA9PSB0b0xlZnQpIHtcclxuICAgICAgICAgIHN0YXJ0ID0gbWlkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbmQgPSBtaWQgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQXQgdGhlIGxvb3AncyBlbmQ6ICBgZW5kYCBub3cgaG9sZHMgdGhlIG5vbi1TTVAtYXdhcmUgZGl2ZXJnZW5jZSBwb2ludC5cclxuICAgICAgLy8gVGhlICdjYXJldCcgaXMgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2hpbmcgY29kZSB1bml0LlxyXG5cclxuICAgICAgLy8gMS4yOiAgZGV0ZWN0IGEgcG9zc2libGUgc3Vycm9nYXRlLXBhaXIgc3BsaXQgc2NlbmFyaW8sIGNvcnJlY3RpbmcgZm9yIGl0XHJcbiAgICAgIC8vICAgICAgIChieSBtb3ZpbmcgdGhlIHNwbGl0IGJlZm9yZSB0aGUgaGlnaC1zdXJyb2dhdGUpIGlmIGRldGVjdGVkLlxyXG5cclxuICAgICAgLy8gSWYgdGhlIHNwbGl0IGxvY2F0aW9uIGlzIHByZWNpc2VseSBvbiBlaXRoZXIgZW5kIG9mIHRoZSBjb250ZXh0LCB3ZSBjYW4ndFxyXG4gICAgICAvLyBoYXZlIHNwbGl0IGEgc3Vycm9nYXRlIHBhaXIuXHJcbiAgICAgIGlmKGVuZCA+IDAgJiYgZW5kIDwgbWF4TGVmdE1hdGNoKSB7XHJcbiAgICAgICAgbGV0IHBvdGVudGlhbEhpZ2ggICAgPSBmcm9tLmNoYXJDb2RlQXQoZW5kLTEpO1xyXG4gICAgICAgIGxldCBwb3RlbnRpYWxGcm9tTG93ID0gZnJvbS5jaGFyQ29kZUF0KGVuZCk7XHJcbiAgICAgICAgbGV0IHBvdGVudGlhbFRvTG93ICAgPSB0by5jaGFyQ29kZUF0KGVuZCk7XHJcblxyXG4gICAgICAgIC8vIGlmIHBvdGVudGlhbEhpZ2ggaXMgYSBwb3NzaWJsZSBoaWdoIHN1cnJvZ2F0ZS4uLlxyXG4gICAgICAgIGlmKHBvdGVudGlhbEhpZ2ggPj0gMHhEODAwICYmIHBvdGVudGlhbEhpZ2ggPD0gMHhEQkZGKSB7XHJcbiAgICAgICAgICAvLyBhbmQgYXQgbGVhc3Qgb25lIHBvdGVudGlhbCAnbG93JyBpcyBhIHBvc3NpYmxlIGxvdyBzdXJyb2dhdGUuLi5cclxuICAgICAgICAgIGxldCBmbGFnID0gcG90ZW50aWFsRnJvbUxvdyA+PSAweERDMDAgJiYgcG90ZW50aWFsRnJvbUxvdyA8PSAweERGRkY7XHJcbiAgICAgICAgICBmbGFnID0gZmxhZyB8fCAocG90ZW50aWFsVG9Mb3cgPj0gMFhEQzAwICYmIHBvdGVudGlhbFRvTG93IDw9IDB4REZGRik7XHJcblxyXG4gICAgICAgICAgLy8gQ29ycmVjdCB0aGUgc3BsaXQgbG9jYXRpb24sIG1vdmluZyBpdCAnYmVmb3JlJyB0aGUgaGlnaCBzdXJyb2dhdGUuXHJcbiAgICAgICAgICBpZihmbGFnKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGVuZCAtIDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAxLjM6ICB0YWtlIHN1YnN0cmluZyBmcm9tIHN0YXJ0IHRvIHRoZSBzcGxpdCBwb2ludDsgZGV0ZXJtaW5lIFNNUC1hd2FyZSBsZW5ndGguXHJcbiAgICAgIC8vICAgICAgIFRoaXMgeWllbGRzIHRoZSBTTVAtYXdhcmUgZGl2ZXJnZW5jZSBpbmRleCwgd2hpY2ggZ2l2ZXMgdGhlIG51bWJlciBvZiBsZWZ0LWRlbGV0ZXMuXHJcbiAgICAgIGxldCBuZXdDYXJldCA9IGZyb20uX2ttd0NvZGVVbml0VG9Db2RlUG9pbnQoZW5kKTtcclxuICAgICAgbGV0IGRlbGV0ZWRMZWZ0ID0gZnJvbUNhcmV0IC0gbmV3Q2FyZXQ7XHJcblxyXG4gICAgICAvLyBTdGVwIDI6ICBEZXRlcm1pbmUgdGhlIG90aGVyIHByb3BlcnRpZXMuXHJcbiAgICAgIC8vIFNpbmNlIHRoZSAnYWZ0ZXInIE91dHB1dFRhcmdldCdzIGNhcmV0IGluZGljYXRlcyB0aGUgZW5kIG9mIGFueSBpbnNlcnRlZCB0ZXh0LCB3ZVxyXG4gICAgICAvLyBjYW4gZWFzaWx5IGNhbGN1bGF0ZSB0aGUgcmVzdC5cclxuICAgICAgbGV0IGluc2VydGVkTGVuZ3RoID0gdG9DYXJldCAtIG5ld0NhcmV0O1xyXG4gICAgICBsZXQgZGVsdGEgPSB0by5fa213U3Vic3RyKG5ld0NhcmV0LCBpbnNlcnRlZExlbmd0aCk7XHJcblxyXG4gICAgICBsZXQgdW5kZWxldGVkUmlnaHQgPSB0by5fa213TGVuZ3RoKCkgLSB0b0NhcmV0O1xyXG4gICAgICBsZXQgb3JpZ2luYWxSaWdodCA9IGZyb20uX2ttd0xlbmd0aCgpIC0gZnJvbUNhcmV0O1xyXG4gICAgICBsZXQgZGVsZXRlZFJpZ2h0ID0gb3JpZ2luYWxSaWdodCAtIHVuZGVsZXRlZFJpZ2h0O1xyXG5cclxuICAgICAgLy8gTWF5IG9jY3VyIHdoZW4gcmV2ZXJ0aW5nIGEgc3VnZ2VzdGlvbiB0aGF0IGhhZCBiZWVuIGFwcGxpZWQgbWlkLXdvcmQuXHJcbiAgICAgIGlmKGRlbGV0ZWRSaWdodCA8IDApIHtcclxuICAgICAgICAvLyBSZXN0b3JlcyBkZWxldGVSaWdodCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGRlbHRhID0gZGVsdGEgKyB0by5fa213U3Vic3RyKHRvQ2FyZXQsIC1kZWxldGVkUmlnaHQpO1xyXG4gICAgICAgIGRlbGV0ZWRSaWdodCA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuZXcgVGV4dFRyYW5zZm9ybShkZWx0YSwgZGVsZXRlZExlZnQsIGRlbGV0ZWRSaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgYnVpbGRUcmFuc2NyaXB0aW9uRnJvbShvcmlnaW5hbDogT3V0cHV0VGFyZ2V0LCBrZXlFdmVudDogS2V5RXZlbnQsIGFsdGVybmF0ZXM/OiBBbHRlcm5hdGVbXSk6IFRyYW5zY3JpcHRpb24ge1xyXG4gICAgICBsZXQgdHJhbnNmb3JtID0gdGhpcy5idWlsZFRyYW5zZm9ybUZyb20ob3JpZ2luYWwpO1xyXG5cclxuICAgICAgLy8gSWYgd2UgZXZlciBkZWNpZGUgdG8gcmUtYWRkIGRlYWRrZXkgdHJhY2tpbmcsIHRoaXMgaXMgdGhlIHBsYWNlIGZvciBpdC5cclxuXHJcbiAgICAgIHJldHVybiBuZXcgVHJhbnNjcmlwdGlvbihrZXlFdmVudCwgdHJhbnNmb3JtLCBNb2NrLmZyb20ob3JpZ2luYWwpLCBhbHRlcm5hdGVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc3RvcmVzIHRoZSBgT3V0cHV0VGFyZ2V0YCB0byB0aGUgaW5kaWNhdGVkIHN0YXRlLiAgRGVzaWduZWQgZm9yIHVzZSB3aXRoIGBUcmFuc2NyaXB0aW9uLnByZUlucHV0YC5cclxuICAgICAqIEBwYXJhbSBvcmlnaW5hbCBBbiBgT3V0cHV0VGFyZ2V0YCAodXN1YWxseSBhIGBNb2NrYCkuXHJcbiAgICAgKi9cclxuICAgIHJlc3RvcmVUbyhvcmlnaW5hbDogT3V0cHV0VGFyZ2V0KSB7XHJcbiAgICAgIC8vXHJcbiAgICAgIHRoaXMuc2V0VGV4dEJlZm9yZUNhcmV0KG9yaWdpbmFsLmdldFRleHRCZWZvcmVDYXJldCgpKTtcclxuICAgICAgdGhpcy5zZXRUZXh0QWZ0ZXJDYXJldChvcmlnaW5hbC5nZXRUZXh0QWZ0ZXJDYXJldCgpKTtcclxuXHJcbiAgICAgIC8vIEFsc28sIHJlc3RvcmUgdGhlIGRlYWRrZXlzIVxyXG4gICAgICB0aGlzLl9ka3MgPSBvcmlnaW5hbC5fZGtzLmNsb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXBwbHkodHJhbnNmb3JtOiBUcmFuc2Zvcm0pIHtcclxuICAgICAgaWYodHJhbnNmb3JtLmRlbGV0ZVJpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5zZXRUZXh0QWZ0ZXJDYXJldCh0aGlzLmdldFRleHRBZnRlckNhcmV0KCkuX2ttd1N1YnN0cih0cmFuc2Zvcm0uZGVsZXRlUmlnaHQpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYodHJhbnNmb3JtLmRlbGV0ZUxlZnQpIHtcclxuICAgICAgICB0aGlzLmRlbGV0ZUNoYXJzQmVmb3JlQ2FyZXQodHJhbnNmb3JtLmRlbGV0ZUxlZnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZih0cmFuc2Zvcm0uaW5zZXJ0KSB7XHJcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0QmVmb3JlQ2FyZXQodHJhbnNmb3JtLmluc2VydCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGFsbCBkZWFka2V5cyBhcmUgaW52YWxpZGF0ZWQgYWZ0ZXIgYXBwbHlpbmcgYSBUcmFuc2Zvcm0sIHNpbmNlXHJcbiAgICAgIC8vIHByZWRpY3Rpb24gaW1wbGllcyB3ZSdsbCBiZSBjb21wbGV0aW5nIGEgd29yZCwgcG9zdC1kZWFka2V5cy5cclxuICAgICAgdGhpcy5fZGtzLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgdG8gYHJlc3RvcmVUb2AgLSBhbGxvd3MgZGlyZWN0bHkgc2V0dGluZyB0aGUgJ2JlZm9yZScgY29udGV4dCB0byB0aGF0IG9mIGFub3RoZXJcclxuICAgICAqIGBPdXRwdXRUYXJnZXRgLlxyXG4gICAgICogQHBhcmFtIHMgXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzZXRUZXh0QmVmb3JlQ2FyZXQoczogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIC8vIFRoaXMgb25lJ3MgZWFzeSBlbm91Z2ggdG8gcHJvdmlkZSBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yLlxyXG4gICAgICB0aGlzLmRlbGV0ZUNoYXJzQmVmb3JlQ2FyZXQodGhpcy5nZXRUZXh0QmVmb3JlQ2FyZXQoKS5fa213TGVuZ3RoKCkpO1xyXG4gICAgICB0aGlzLmluc2VydFRleHRCZWZvcmVDYXJldChzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciB0byBgcmVzdG9yZVRvYCAtIGFsbG93cyBkaXJlY3RseSBzZXR0aW5nIHRoZSAnYWZ0ZXInIGNvbnRleHQgdG8gdGhhdCBvZiBhbm90aGVyXHJcbiAgICAgKiBgT3V0cHV0VGFyZ2V0YC5cclxuICAgICAqIEBwYXJhbSBzIFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc2V0VGV4dEFmdGVyQ2FyZXQoczogc3RyaW5nKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbnkgc2VsZWN0ZWQgdGV4dCB3aXRoaW4gdGhlIHdyYXBwZXIncyBlbGVtZW50KHMpLlxyXG4gICAgICogU2lsZW50bHkgZG9lcyBub3RoaW5nIGlmIG5vIHN1Y2ggdGV4dCBleGlzdHMuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGNsZWFyU2VsZWN0aW9uKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYW55IGNhY2hlZCBzZWxlY3Rpb24tcmVsYXRlZCBzdGF0ZSB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGludmFsaWRhdGVTZWxlY3Rpb24oKTogdm9pZDtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIHVuZGVybHlpbmcgZWxlbWVudCBoYXMgaXRzIG93biBzZWxlY3Rpb24gKGlucHV0LCB0ZXh0YXJlYSlcclxuICAgICAqIG9yIGlzIHBhcnQgb2YgKG9yIHBvc3Nlc3NlcykgdGhlIERPTSdzIGFjdGl2ZSBzZWxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGhhc1NlbGVjdGlvbigpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpbmRleCBjb3JyZXNwb25kaW5nIHRvIHRoZSBjYXJldCdzIHBvc2l0aW9uIGZvciB1c2Ugd2l0aCBkZWFka2V5cy5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0RGVhZGtleUNhcmV0KCk6IG51bWJlcjtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWxhdGl2ZSB0byB0aGUgY2FyZXQsIGdldHMgdGhlIGN1cnJlbnQgY29udGV4dCB3aXRoaW4gdGhlIHdyYXBwZXIncyBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBnZXRUZXh0QmVmb3JlQ2FyZXQoKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVsYXRpdmUgdG8gdGhlIGNhcmV0IChhbmQvb3IgYWN0aXZlIHNlbGVjdGlvbiksIGdldHMgdGhlIGVsZW1lbnQncyB0ZXh0IGFmdGVyIHRoZSBjYXJldCxcclxuICAgICAqIGV4Y2x1ZGluZyBhbnkgYWN0aXZlbHkgc2VsZWN0ZWQgdGV4dCB0aGF0IHdvdWxkIGJlIGltbWVkaWF0ZWx5IHJlcGxhY2VkIHVwb24gdGV4dCBlbnRyeS5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0VGV4dEFmdGVyQ2FyZXQoKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCdzIGZ1bGwgdGV4dCwgaW5jbHVkaW5nIGFueSB0ZXh0IHRoYXQgaXMgYWN0aXZlbHkgc2VsZWN0ZWQuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldFRleHQoKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgY29udGV4dCBkZWxldGlvbnMgKGZyb20gdGhlIGxlZnQgb2YgdGhlIGNhcmV0KSBhcyBuZWVkZWQgYnkgdGhlIEtleW1hbldlYiBlbmdpbmUgYW5kXHJcbiAgICAgKiBjb3JyZWN0cyB0aGUgbG9jYXRpb24gb2YgYW55IGFmZmVjdGVkIGRlYWRrZXlzLlxyXG4gICAgICogXHJcbiAgICAgKiBEb2VzIG5vdCBkZWxldGUgZGVhZGtleXMgKGIvYyBLTVcgMSAmIDIgYmVoYXZpb3IgbWFpbnRlbmFuY2UpLlxyXG4gICAgICogQHBhcmFtIGRuIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBkZWxldGUuICBJZiBuZWdhdGl2ZSwgY29udGV4dCB3aWxsIGJlIGxlZnQgdW5jaGFuZ2VkLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBkZWxldGVDaGFyc0JlZm9yZUNhcmV0KGRuOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyB0ZXh0IGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY2FyZXQncyBjdXJyZW50IHBvc2l0aW9uLCBtb3ZpbmcgdGhlIGNhcmV0IGFmdGVyIHRoZVxyXG4gICAgICogbmV3bHkgaW5zZXJ0ZWQgdGV4dCBpbiB0aGUgcHJvY2VzcyBhbG9uZyB3aXRoIGFueSBhZmZlY3RlZCBkZWFka2V5cy5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHMgVGV4dCB0byBpbnNlcnQgYmVmb3JlIHRoZSBjYXJldCdzIGN1cnJlbnQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGluc2VydFRleHRCZWZvcmVDYXJldChzOiBzdHJpbmcpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsb3dzIGVsZW1lbnQtc3BlY2lmaWMgaGFuZGxpbmcgZm9yIEVOVEVSIGtleSBpbnB1dHMuICBDb25jZXB0dWFsbHksIHRoaXMgc2hvdWxkIHVzdWFsbHlcclxuICAgICAqIGNvcnJlc3BvbmQgdG8gYGluc2VydFRleHRCZWZvcmVDYXJldCgnXFxuJyksIGJ1dCBhY3R1YWwgaW1wbGVtZW50YXRpb24gd2lsbCB2YXJ5IGdyZWF0bHkgYW1vbmdcclxuICAgICAqIGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBoYW5kbGVOZXdsaW5lQXRDYXJldCgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZXMgZWxlbWVudC1zcGVjaWZpYyBzdGF0ZSBwcm9wZXJ0aWVzIHByb25lIHRvIG11dGF0aW9uLCBlbmFibGluZyByZXN0b3JhdGlvbiBhZnRlclxyXG4gICAgICogdGV4dC1vdXRwdXQgb3BlcmF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgc2F2ZVByb3BlcnRpZXMoKSB7XHJcbiAgICAgIC8vIE1vc3QgZWxlbWVudCBpbnRlcmZhY2VzIHdvbid0IG5lZWQgYW55dGhpbmcgaGVyZS5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc3RvcmVzIHByZXZpb3VzbHktc2F2ZWQgZWxlbWVudC1zcGVjaWZpYyBzdGF0ZSBwcm9wZXJ0aWVzLiAgRGVzaWduZWQgZm9yIHVzZSBhZnRlciB0ZXh0LW91dHB1dFxyXG4gICAgICogb3BzIHRvIGZhY2lsaXRhdGUgbW9yZS1zZWFtbGVzcyB3ZWItZGV2IGFuZCB1c2VyIGludGVyYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgcmVzdG9yZVByb3BlcnRpZXMoKXtcclxuICAgICAgLy8gTW9zdCBlbGVtZW50IGludGVyZmFjZXMgd29uJ3QgbmVlZCBhbnl0aGluZyBoZXJlLiBcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIHN5bnRoZXRpYyBldmVudCBvbiB0aGUgdW5kZXJseWluZyBlbGVtZW50LCBzaWduYWxsaW5nIHRoYXQgaXRzIHZhbHVlIGhhcyBjaGFuZ2VkLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBkb0lucHV0RXZlbnQoKTogdm9pZDtcclxuICB9XHJcblxyXG4gIC8vIER1ZSB0byBzb21lIGludGVyZXN0aW5nIHJlcXVpcmVtZW50cyBvbiBjb21waWxlIG9yZGVyaW5nIGluIFRTLFxyXG4gIC8vIHRoaXMgbmVlZHMgdG8gYmUgaW4gdGhlIHNhbWUgZmlsZSBhcyBPdXRwdXRUYXJnZXQgbm93LlxyXG4gIGV4cG9ydCBjbGFzcyBNb2NrIGV4dGVuZHMgT3V0cHV0VGFyZ2V0IHtcclxuICAgIHRleHQ6IHN0cmluZztcclxuICAgIGNhcmV0SW5kZXg6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0Pzogc3RyaW5nLCBjYXJldFBvcz86IG51bWJlcikge1xyXG4gICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgdGhpcy50ZXh0ID0gdGV4dCA/IHRleHQgOiBcIlwiO1xyXG4gICAgICB2YXIgZGVmYXVsdExlbmd0aCA9IHRoaXMudGV4dC5fa213TGVuZ3RoKCk7XHJcbiAgICAgIC8vIEVuc3VyZXMgdGhhdCBgY2FyZXRQb3MgPT0gMGAgaXMgaGFuZGxlZCBjb3JyZWN0bHkuXHJcbiAgICAgIHRoaXMuY2FyZXRJbmRleCA9IHR5cGVvZiBjYXJldFBvcyA9PSBcIm51bWJlclwiID8gY2FyZXRQb3MgOiBkZWZhdWx0TGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsb25lcyB0aGUgc3RhdGUgb2YgYW4gZXhpc3RpbmcgRWRpdGFibGVFbGVtZW50LCBjcmVhdGluZyBhIE1vY2sgdmVyc2lvbiBvZiBpdHMgc3RhdGUuXHJcbiAgICBzdGF0aWMgZnJvbShvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCkge1xyXG4gICAgICBsZXQgY2xvbmU6IE1vY2s7XHJcblxyXG4gICAgICBpZihvdXRwdXRUYXJnZXQgaW5zdGFuY2VvZiBNb2NrKSB7XHJcbiAgICAgICAgLy8gQXZvaWRzIHRoZSBuZWVkIHRvIHJ1biBleHBlbnNpdmUga213c3RyaW5nLnRzIC8gYF9rbXdMZW5ndGgoKWBcclxuICAgICAgICAvLyBjYWxjdWxhdGlvbnMgd2hlbiBkZWVwLWNvcHlpbmcgTW9jayBpbnN0YW5jZXMuXHJcbiAgICAgICAgbGV0IHByaW9yTW9jayA9IG91dHB1dFRhcmdldCBhcyBNb2NrO1xyXG4gICAgICAgIGNsb25lID0gbmV3IE1vY2socHJpb3JNb2NrLnRleHQsIHByaW9yTW9jay5jYXJldEluZGV4KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJZiB3ZSdyZSAnY2xvbmluZycgYSBkaWZmZXJlbnQgT3V0cHV0VGFyZ2V0IHR5cGUsIHdlIGRvbid0IGhhdmUgYVxyXG4gICAgICAgIC8vIGd1YXJhbnRlZWQgd2F5IHRvIG1vcmUgZWZmaWNpZW50bHkgZ2V0IHRoZXNlIHZhbHVlczsgdGhlc2UgYXJlIHRoZVxyXG4gICAgICAgIC8vIGJlc3QgbWV0aG9kcyBzcGVjaWZpZWQgYnkgdGhlIGFic3RyYWN0aW9uLlxyXG4gICAgICAgIGxldCBwcmVUZXh0ID0gb3V0cHV0VGFyZ2V0LmdldFRleHRCZWZvcmVDYXJldCgpO1xyXG4gICAgICAgIGxldCBjYXJldEluZGV4ID0gcHJlVGV4dC5fa213TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgIC8vIFdlIGNob29zZSB0byBpZ25vcmUgKHJhdGhlciwgcHJlLWVtcHRpdmVseSByZW1vdmUpIGFueSBhY3RpdmVseS1zZWxlY3RlZCB0ZXh0LFxyXG4gICAgICAgIC8vIGFzIHNpbmNlIGl0J3MgYWx3YXlzIHJlbW92ZWQgaW5zdGFudGx5IGR1cmluZyBhbnkgdGV4dCBtdXRhdGlvbiBvcGVyYXRpb25zLlxyXG4gICAgICAgIGNsb25lID0gbmV3IE1vY2socHJlVGV4dCArIG91dHB1dFRhcmdldC5nZXRUZXh0QWZ0ZXJDYXJldCgpLCBjYXJldEluZGV4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWxzbyBkdXBsaWNhdGUgZGVhZGtleSBzdGF0ZSEgIChOZWVkZWQgZm9yIGZhdC1maW5nZXIgb3BzLilcclxuICAgICAgY2xvbmUuc2V0RGVhZGtleXMob3V0cHV0VGFyZ2V0LmRlYWRrZXlzKCkpO1xyXG5cclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjbGVhclNlbGVjdGlvbigpOiB2b2lkIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGludmFsaWRhdGVTZWxlY3Rpb24oKTogdm9pZCB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBoYXNTZWxlY3Rpb24oKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERlYWRrZXlDYXJldCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5jYXJldEluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIHNldERlYWRrZXlDYXJldChpbmRleDogbnVtYmVyKSB7XHJcbiAgICAgIGlmKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMudGV4dC5fa213TGVuZ3RoKCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlZCBjYXJldCBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY2FyZXRJbmRleCA9IGluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRleHRCZWZvcmVDYXJldCgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy50ZXh0Lmttd1N1YnN0cigwLCB0aGlzLmNhcmV0SW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRleHRBZnRlckNhcmV0KCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRleHQua213U3Vic3RyKHRoaXMuY2FyZXRJbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGV4dCgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy50ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZUNoYXJzQmVmb3JlQ2FyZXQoZG46IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBpZihkbiA+PSAwKSB7XHJcbiAgICAgICAgaWYoZG4gPiB0aGlzLmNhcmV0SW5kZXgpIHtcclxuICAgICAgICAgIGRuID0gdGhpcy5jYXJldEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQua213U3Vic3RyKDAsIHRoaXMuY2FyZXRJbmRleCAtIGRuKSArIHRoaXMuZ2V0VGV4dEFmdGVyQ2FyZXQoKTtcclxuICAgICAgICB0aGlzLmNhcmV0SW5kZXggLT0gZG47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRUZXh0QmVmb3JlQ2FyZXQoczogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudGV4dCA9IHRoaXMuZ2V0VGV4dEJlZm9yZUNhcmV0KCkgKyBzICsgdGhpcy5nZXRUZXh0QWZ0ZXJDYXJldCgpO1xyXG4gICAgICB0aGlzLmNhcmV0SW5kZXggKz0gcy5rbXdMZW5ndGgoKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVOZXdsaW5lQXRDYXJldCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5pbnNlcnRUZXh0QmVmb3JlQ2FyZXQoJ1xcbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzZXRUZXh0QWZ0ZXJDYXJldChzOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5nZXRUZXh0QmVmb3JlQ2FyZXQoKSArIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZG9JbnB1dEV2ZW50KCkge1xyXG4gICAgICAvLyBNb2NrIGlzbid0IGJhY2tlZCBieSBhbiBlbGVtZW50LCBzbyBpdCB3b24ndCBoYXZlIGFueSBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIm91dHB1dFRhcmdldC50c1wiIC8+XHJcblxyXG5uYW1lc3BhY2UgY29tLmtleW1hbi50ZXh0IHtcclxuICAvLyBSZXByZXNlbnRzIGEgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIG92ZXIgYSBrZXlib2FyZCdzIGtleXMuXHJcbiAgLy8gRGVmaW5lZCBoZXJlIHRvIGF2b2lkIGNvbXBpbGF0aW9uIGlzc3Vlcy5cclxuICBleHBvcnQgdHlwZSBLZXlEaXN0cmlidXRpb24gPSB7a2V5SWQ6IHN0cmluZywgcDogbnVtYmVyfVtdO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGNsYXNzIGlzIGRlZmluZWQgd2l0aGluIGl0cyBvd24gZmlsZSBzbyB0aGF0IGl0IGNhbiBiZSBsb2FkZWQgYnkgY29kZSBvdXRzaWRlIG9mIEtNVyB3aXRob3V0XHJcbiAgICogaGF2aW5nIHRvIGFjdHVhbGx5IGxvYWQgdGhlIGVudGlyZXR5IG9mIEtNVy5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgS2V5RXZlbnQge1xyXG4gICAgTGNvZGU6IG51bWJlcjtcclxuICAgIExzdGF0ZXM6IG51bWJlcjtcclxuICAgIExtb2RpZmllckNoYW5nZT86IGJvb2xlYW47XHJcbiAgICBMbW9kaWZpZXJzOiBudW1iZXI7XHJcbiAgICBMaXNWaXJ0dWFsS2V5OiBib29sZWFuO1xyXG4gICAgdmtDb2RlOiBudW1iZXI7XHJcbiAgICBrTmFtZTogc3RyaW5nO1xyXG4gICAga0xheWVyPzogc3RyaW5nOyAgIC8vIFRoZSBrZXkncyBsYXllciBwcm9wZXJ0eVxyXG4gICAga2JkTGF5ZXI/OiBzdHJpbmc7IC8vIFRoZSB2aXJ0dWFsIGtleWJvYXJkJ3MgYWN0aXZlIGxheWVyXHJcbiAgICBrTmV4dExheWVyPzogc3RyaW5nO1xyXG4gICAgXHJcbiAgICAvLyBIb2xkcyByZWxldmFudCBldmVudCBwcm9wZXJ0aWVzIGxlYWRpbmcgdG8gY29uc3RydWN0aW9uIG9mIHRoaXMgS2V5RXZlbnQuXHJcbiAgICBzb3VyY2U/OiBhbnk7IC8vIFRlY2huaWNhbGx5LCBLZXlFdmVudHxNb3VzZUV2ZW50fFRvdWNoIC0gYnV0IHRob3NlIGFyZSBET00gdHlwZXMgdGhhdCBtdXN0IGJlIGtlcHQgb3V0IG9mIGhlYWRsZXNzIG1vZGUuXHJcbiAgICAvLyBIb2xkcyBhIGdlbmVyYXRlZCBmYXQtZmluZ2VyIGRpc3RyaWJ1dGlvbiAod2hlbiBhcHByb3ByaWF0ZSlcclxuICAgIGtleURpc3RyaWJ1dGlvbj86IEtleURpc3RyaWJ1dGlvbjtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGV2aWNlIG1vZGVsIGZvciB3ZWItY29yZSB0byBmb2xsb3cgd2hlbiBwcm9jZXNzaW5nIHRoZSBrZXlzdHJva2UuXHJcbiAgICAgKi9cclxuICAgIGRldmljZTogdXRpbHMuRGV2aWNlU3BlYztcclxuXHJcbiAgICAvKipcclxuICAgICAqIGB0cnVlYCBpZiB0aGlzIGV2ZW50IHdhcyBwcm9kdWNlZCBieSBzb3VyY2VzIG90aGVyIHRoYW4gYSBET00tYmFzZWQgS2V5Ym9hcmRFdmVudC5cclxuICAgICAqL1xyXG4gICAgaXNTeW50aGV0aWM6IGJvb2xlYW4gPSB0cnVlO1xyXG4gIH07XHJcbn0iLCJuYW1lc3BhY2UgS01XUmVjb3JkZXIge1xyXG4gIGV4cG9ydCB0eXBlIEFzc2VydENhbGxiYWNrID0gKHMxOiBhbnksIHMyOiBhbnksIG1zZz86IHN0cmluZykgPT4gdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogRmFjaWxpdGF0ZXMgcnVubmluZyBSZWNvcmRlci1nZW5lcmF0ZWQgdGVzdHMgb24gdmFyaW91cyBwbGF0Zm9ybXMuXHJcbiAgICogXHJcbiAgICogTm90ZSB0aGF0IERPTS1hd2FyZSBLZXltYW5XZWIgd2lsbCBpbXBsZW1lbnQgYSBCcm93c2VyLWJhc2VkIHZlcnNpb24sIHdoaWxlXHJcbiAgICoga2V5Ym9hcmQtcHJvY2Vzc29yIGFuZCBpbnB1dC1wcm9jZXNzb3Igd2lsbCB1c2UgYSBOb2RlLWJhc2VkIHZlcnNpb24gaW5zdGVhZC5cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUHJvY3RvciB7XHJcbiAgICBkZXZpY2U6IGNvbS5rZXltYW4udXRpbHMuRGV2aWNlU3BlYztcclxuXHJcbiAgICBfYXNzZXJ0OiBBc3NlcnRDYWxsYmFjaztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihkZXZpY2U6IGNvbS5rZXltYW4udXRpbHMuRGV2aWNlU3BlYywgYXNzZXJ0OiBBc3NlcnRDYWxsYmFjaykge1xyXG4gICAgICB0aGlzLmRldmljZSA9IGRldmljZTtcclxuXHJcbiAgICAgIHRoaXMuX2Fzc2VydCA9IGFzc2VydDtcclxuICAgIH1cclxuXHJcbiAgICBhc3NlcnRFcXVhbHMoczE6IHVua25vd24sIHMyOiB1bmtub3duLCBtc2c/OiBzdHJpbmcpIHtcclxuICAgICAgaWYodGhpcy5fYXNzZXJ0KSB7XHJcbiAgICAgICAgdGhpcy5fYXNzZXJ0KHMxLCBzMiwgbXNnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFBlcmZvcm1zIGdsb2JhbCB0ZXN0IHByZXAuXHJcbiAgICBhYnN0cmFjdCBiZWZvcmVBbGwoKTtcclxuXHJcbiAgICAvLyBQZXJmb3JtcyBwZXItdGVzdCBzZXR1cFxyXG4gICAgYWJzdHJhY3QgYmVmb3JlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvd3MgdGhlIHByb2N0b3IgdG8gaW5kaWNhdGUgaWYgaXMgY2FwYWJsZSBvZiBleGVjdXRpbmcgYSBzdWl0ZSBvZiB0ZXN0cyBvciBub3QuXHJcbiAgICAgKiBAcGFyYW0gdGVzdFN1aXRlIFxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBjb21wYXRpYmxlV2l0aFN1aXRlKHRlc3RTdWl0ZTogS2V5Ym9hcmRUZXN0KTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGlzIFByb2N0b3IgaXMgY2FwYWJsZSBvZiBydW5uaW5nIHRoZSBzcGVjaWZpZWQgc2V0IG9mIHRlc3RzLiBcclxuICAgICAqLyBcclxuICAgIGFic3RyYWN0IG1hdGNoZXNUZXN0U2V0KHRlc3RTZXQ6IFRlc3RTZXQ8YW55Pik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW11bGF0ZXMgdGhlIHNwZWNpZmllZCB0ZXN0IHNlcXVlbmNlIGZvciB1c2UgaW4gdGVzdGluZy5cclxuICAgICAqIEBwYXJhbSBzZXF1ZW5jZSBUaGUgcmVjb3JkZWQgc2VxdWVuY2UsIGdlbmVyYWxseSBwcm92aWRlZCBieSBhIHRlc3Qgc2V0LlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzaW11bGF0ZVNlcXVlbmNlKHNlcXVlbmNlOiBUZXN0U2VxdWVuY2U8YW55PiwgdGFyZ2V0PzogY29tLmtleW1hbi50ZXh0Lk91dHB1dFRhcmdldCk7XHJcbiAgfVxyXG59IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL25vZGVfbW9kdWxlcy9Aa2V5bWFuYXBwL2tleWJvYXJkLXByb2Nlc3Nvci9zcmMvdGV4dC9rZXlFdmVudC50c1wiIC8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJwcm9jdG9yLnRzXCIgLz5cclxuXHJcbm5hbWVzcGFjZSBLTVdSZWNvcmRlciB7XHJcbiAgLy8jcmVnaW9uIERlZmluZXMgdGhlIElucHV0RXZlbnRTcGVjIHNldCwgdXNlZCB0byByZWNvbnN0cnVjdCBET00tYmFzZWQgZXZlbnRzIGZvciBicm93c2VyLWJhc2VkIHNpbXVsYXRpb25cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5wdXRFdmVudFNwZWMge1xyXG4gICAgdHlwZTogXCJrZXlcIiB8IFwib3NrXCI7XHJcbiAgICBzdGF0aWMgZnJvbUpTT05PYmplY3Qob2JqOiBhbnkpOiBJbnB1dEV2ZW50U3BlYyB7XHJcbiAgICAgIGlmKG9iaiAmJiBvYmoudHlwZSkge1xyXG4gICAgICAgIGlmKG9iai50eXBlID09IFwia2V5XCIpIHtcclxuICAgICAgICAgIHJldHVybiBuZXcgUGh5c2ljYWxJbnB1dEV2ZW50U3BlYyhvYmopO1xyXG4gICAgICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PSBcIm9za1wiKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IE9TS0lucHV0RXZlbnRTcGVjKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkVycm9yIGluIEpTT04gZm9ybWF0IGNvcnJlc3BvbmRpbmcgdG8gYW4gSW5wdXRFdmVudFNwZWMhXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdG9QcmV0dHlKU09OKCk6IHN0cmluZyB7XHJcbiAgICAgIC8vIFdlIHdhbnQgdGhlIGRlZmF1bHQsIG5vbi1zcGFjZWQgSlNPTiBmb3IgdGhpcyBjbGFzcywgZXZlbiB3aGVuIG90aGVyd2lzZSBhZGRpbmcgd2hpdGVzcGFjZS5cclxuICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KHRoaXMpO1xyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY2FsSW5wdXRFdmVudFNwZWMgZXh0ZW5kcyBJbnB1dEV2ZW50U3BlYyB7XHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgbW9kaWZpZXJDb2RlczogeyBbbW9kOnN0cmluZ106IG51bWJlciB9ID0ge1xyXG4gICAgICBcIlNoaWZ0XCI6MHgwMDAxLFxyXG4gICAgICBcIkNvbnRyb2xcIjoweDAwMDIsXHJcbiAgICAgIFwiQWx0XCI6MHgwMDA0LFxyXG4gICAgICBcIk1ldGFcIjoweDAwMDgsXHJcbiAgICAgIFwiQ2Fwc0xvY2tcIjoweDAwMTAsXHJcbiAgICAgIFwiTnVtTG9ja1wiOjB4MDAyMCxcclxuICAgICAgXCJTY3JvbGxMb2NrXCI6MHgwMDQwXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEtleWJvYXJkRXZlbnQgcHJvcGVydGllc1xyXG4gICAgdHlwZTogXCJrZXlcIiA9IFwia2V5XCI7XHJcbiAgICBrZXk6IHN0cmluZztcclxuICAgIGNvZGU6IHN0cmluZztcclxuICAgIGtleUNvZGU6IG51bWJlcjtcclxuICAgIG1vZGlmaWVyU2V0OiBudW1iZXI7XHJcbiAgICBsb2NhdGlvbjogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGU/OiBQaHlzaWNhbElucHV0RXZlbnRTcGVjKSB7IC8vIHBhcmFtZXRlciBpcyB1c2VkIHRvIHJlY29uc3RydWN0IGZyb20gSlNPTi5cclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIGlmKGUpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGUua2V5O1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGUuY29kZTtcclxuICAgICAgICB0aGlzLmtleUNvZGUgPSBlLmtleUNvZGU7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllclNldCA9IGUubW9kaWZpZXJTZXQ7XHJcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGUubG9jYXRpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRNb2RpZmllclN0YXRlKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAoUGh5c2ljYWxJbnB1dEV2ZW50U3BlYy5tb2RpZmllckNvZGVzW2tleV0gJiB0aGlzLm1vZGlmaWVyU2V0KSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGdlbmVyYXRlTW9kaWZpZXJTdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgdmFyIGxpc3Q6IHN0cmluZyA9IFwiXCI7XHJcblxyXG4gICAgICBmb3IodmFyIGtleSBpbiBQaHlzaWNhbElucHV0RXZlbnRTcGVjLm1vZGlmaWVyQ29kZXMpIHtcclxuICAgICAgICBpZih0aGlzLmdldE1vZGlmaWVyU3RhdGUoa2V5KSkge1xyXG4gICAgICAgICAgbGlzdCArPSAoKGxpc3QgIT0gXCJcIiA/IFwiIFwiIDogXCJcIikgKyBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgT1NLSW5wdXRFdmVudFNwZWMgZXh0ZW5kcyBJbnB1dEV2ZW50U3BlYyB7XHJcbiAgICB0eXBlOiBcIm9za1wiID0gXCJvc2tcIjtcclxuICAgIGtleUlEOiBzdHJpbmc7XHJcblxyXG4gICAgLy8gVGhlIHBhcmFtZXRlciBtYXkgYmUgdXNlZCB0byByZWNvbnN0cnVjdCB0aGUgaXRlbSBmcm9tIHJhdyBKU09OLlxyXG4gICAgY29uc3RydWN0b3IoZT86IE9TS0lucHV0RXZlbnRTcGVjKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIGlmKGUpIHtcclxuICAgICAgICB0aGlzLmtleUlEID0gZS5rZXlJRDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxuXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlY29yZGVkS2V5c3Ryb2tlIHtcclxuICAgIHR5cGU6IFwia2V5XCIgfCBcIm9za1wiO1xyXG5cclxuICAgIHN0YXRpYyBmcm9tSlNPTk9iamVjdChvYmo6IGFueSk6IFJlY29yZGVkS2V5c3Ryb2tlIHtcclxuICAgICAgaWYob2JqICYmIG9iai50eXBlKSB7XHJcbiAgICAgICAgaWYob2JqLnR5cGUgPT0gXCJrZXlcIikge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWNvcmRlZFBoeXNpY2FsS2V5c3Ryb2tlKG9iaiBhcyBSZWNvcmRlZFBoeXNpY2FsS2V5c3Ryb2tlKTsgXHJcbiAgICAgICAgfSBlbHNlIGlmKG9iaiAmJiBvYmoudHlwZSkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWNvcmRlZFN5bnRoZXRpY0tleXN0cm9rZShvYmogYXMgUmVjb3JkZWRTeW50aGV0aWNLZXlzdHJva2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJFcnJvciBpbiBKU09OIGZvcm1hdCBjb3JyZXNwb25kaW5nIHRvIGEgUmVjb3JkZWRLZXlzdHJva2UhXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdG9QcmV0dHlKU09OKCk6IHN0cmluZyB7XHJcbiAgICAgIC8vIFdlIHdhbnQgdGhlIGRlZmF1bHQsIG5vbi1zcGFjZWQgSlNPTiBmb3IgdGhpcyBjbGFzcywgZXZlbiB3aGVuIG90aGVyd2lzZSBhZGRpbmcgd2hpdGVzcGFjZS5cclxuICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KHRoaXMpO1xyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBJbnB1dEV2ZW50U3BlYyB0aGF0IG1heSBiZSB1c2VkIHRvIHNpbXVsYXRlIHRoZSBrZXlzdHJva2Ugd2l0aGluIGEgYnJvd3Nlci1iYXNlZCBlbnZpcm9ubWVudC5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0IGlucHV0RXZlbnRTcGVjKCk6IElucHV0RXZlbnRTcGVjO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIFJlY29yZGVkUGh5c2ljYWxLZXlzdHJva2UgZXh0ZW5kcyBSZWNvcmRlZEtleXN0cm9rZSB7XHJcbiAgICAvLyBLZXlib2FyZEV2ZW50IHByb3BlcnRpZXNcclxuICAgIHR5cGU6IFwia2V5XCIgPSBcImtleVwiO1xyXG5cclxuICAgIGtleUNvZGU6IG51bWJlcjsgIC8vIG1heSBiZSBkaWZmZXJlbnQgZnJvbSBldmVudFNwZWMncyB2YWx1ZSBiL2Mga2V5bWFwcGluZ1xyXG4gICAgc3RhdGVzOiBudW1iZXI7XHJcbiAgICBtb2RpZmllcnM6IG51bWJlcjtcclxuICAgIG1vZGlmaWVyQ2hhbmdlZDogYm9vbGVhbjtcclxuICAgIGlzVmlydHVhbEtleTogYm9vbGVhbjtcclxuICAgIHZrQ29kZTogbnVtYmVyOyAgLy8gbWF5IGJlIHBvc3NpYmxlIHRvIGVsaW1pbmF0ZTsgZGlmZmVyZW5jZXMgYXJpc2UgZnJvbSBtbmVtb25pY3MuXHJcblxyXG4gICAgZXZlbnRTcGVjOiBQaHlzaWNhbElucHV0RXZlbnRTcGVjO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGtleXN0cm9rZTogUmVjb3JkZWRQaHlzaWNhbEtleXN0cm9rZSlcclxuICAgIGNvbnN0cnVjdG9yKGtleXN0cm9rZTogY29tLmtleW1hbi50ZXh0LktleUV2ZW50LCBldmVudFNwZWM6IFBoeXNpY2FsSW5wdXRFdmVudFNwZWMpXHJcbiAgICBjb25zdHJ1Y3RvcihrZXlzdHJva2U6IFJlY29yZGVkUGh5c2ljYWxLZXlzdHJva2V8Y29tLmtleW1hbi50ZXh0LktleUV2ZW50LCBldmVudFNwZWM/OiBQaHlzaWNhbElucHV0RXZlbnRTcGVjKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICBpZihrZXlzdHJva2UgaW5zdGFuY2VvZiBjb20ua2V5bWFuLnRleHQuS2V5RXZlbnQgfHwgdHlwZW9mIGtleXN0cm9rZS50eXBlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIFN0b3JlIHdoYXQgaXMgbmVjZXNzYXJ5IGZvciBoZWFkbGVzcyBldmVudCByZWNvbnN0cnVjdGlvbi5cclxuICAgICAgICBrZXlzdHJva2UgPSBrZXlzdHJva2UgYXMgY29tLmtleW1hbi50ZXh0LktleUV2ZW50O1xyXG4gICAgICAgIHRoaXMua2V5Q29kZSA9IGtleXN0cm9rZS5MY29kZTtcclxuICAgICAgICB0aGlzLnN0YXRlcyA9IGtleXN0cm9rZS5Mc3RhdGVzO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZXJzID0ga2V5c3Ryb2tlLkxtb2RpZmllcnM7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllckNoYW5nZWQgPSAhIWtleXN0cm9rZS5MbW9kaWZpZXJDaGFuZ2U7XHJcbiAgICAgICAgdGhpcy5pc1ZpcnR1YWxLZXkgPSBrZXlzdHJva2UuTGlzVmlydHVhbEtleTtcclxuICAgICAgICB0aGlzLnZrQ29kZSA9IGtleXN0cm9rZS52a0NvZGU7XHJcblxyXG4gICAgICAgIC8vIEFsc28gc3RvcmUgdGhlIERPTS1iYXNlZCBldmVudCBzcGVjIGZvciB1c2UgaW4gaW50ZWdyYXRlZCB0ZXN0aW5nLlxyXG4gICAgICAgIHRoaXMuZXZlbnRTcGVjID0gZXZlbnRTcGVjO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEl0IG1pZ2h0IGJlIGEgcmF3IG9iamVjdCwgZnJvbSBKU09OLlxyXG4gICAgICAgIHRoaXMua2V5Q29kZSA9IGtleXN0cm9rZS5rZXlDb2RlO1xyXG4gICAgICAgIHRoaXMuc3RhdGVzID0ga2V5c3Ryb2tlLnN0YXRlcztcclxuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IGtleXN0cm9rZS5tb2RpZmllcnM7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllckNoYW5nZWQgPSBrZXlzdHJva2UubW9kaWZpZXJDaGFuZ2VkO1xyXG4gICAgICAgIHRoaXMuaXNWaXJ0dWFsS2V5ID0ga2V5c3Ryb2tlLmlzVmlydHVhbEtleTtcclxuICAgICAgICB0aGlzLnZrQ29kZSA9IGtleXN0cm9rZS52a0NvZGU7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRTcGVjID0gbmV3IFBoeXNpY2FsSW5wdXRFdmVudFNwZWMoa2V5c3Ryb2tlLmV2ZW50U3BlYyk7IC8vIG11c3QgYWxzbyBiZSByZWNvbnN0cnVjdGVkLlxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGlucHV0RXZlbnRTcGVjKCk6IElucHV0RXZlbnRTcGVjIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRTcGVjO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIFJlY29yZGVkU3ludGhldGljS2V5c3Ryb2tlIGV4dGVuZHMgUmVjb3JkZWRLZXlzdHJva2Uge1xyXG4gICAgLy8gS2V5Ym9hcmRFdmVudCBwcm9wZXJ0aWVzXHJcbiAgICB0eXBlOiBcIm9za1wiID0gXCJvc2tcIjtcclxuXHJcbiAgICBrZXlOYW1lOiBzdHJpbmc7XHJcbiAgICBsYXllcjogc3RyaW5nO1xyXG5cclxuICAgIGtleURpc3RyaWJ1dGlvbj86IGNvbS5rZXltYW4udGV4dC5LZXlEaXN0cmlidXRpb247XHJcblxyXG4gICAgY29uc3RydWN0b3Ioa2V5c3Ryb2tlOiBSZWNvcmRlZFN5bnRoZXRpY0tleXN0cm9rZSlcclxuICAgIGNvbnN0cnVjdG9yKGtleXN0cm9rZTogY29tLmtleW1hbi50ZXh0LktleUV2ZW50KVxyXG4gICAgY29uc3RydWN0b3Ioa2V5c3Ryb2tlOiBSZWNvcmRlZFN5bnRoZXRpY0tleXN0cm9rZXxjb20ua2V5bWFuLnRleHQuS2V5RXZlbnQpIHtcclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIGlmKGtleXN0cm9rZSBpbnN0YW5jZW9mIGNvbS5rZXltYW4udGV4dC5LZXlFdmVudCB8fCB0eXBlb2Yga2V5c3Ryb2tlLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAga2V5c3Ryb2tlID0ga2V5c3Ryb2tlIGFzIGNvbS5rZXltYW4udGV4dC5LZXlFdmVudDtcclxuICAgICAgICAvLyBTdG9yZSB3aGF0IGlzIG5lY2Vzc2FyeSBmb3IgaGVhZGxlc3MgZXZlbnQgcmVjb25zdHJ1Y3Rpb24uXHJcblxyXG4gICAgICAgIC8vIEFsc28gc3RvcmUgdGhlIERPTS1iYXNlZCBldmVudCBzcGVjIGZvciB1c2UgaW4gaW50ZWdyYXRlZCB0ZXN0aW5nLlxyXG4gICAgICAgIHRoaXMubGF5ZXIgPSBrZXlzdHJva2Uua2JkTGF5ZXI7XHJcbiAgICAgICAgdGhpcy5rZXlOYW1lID0ga2V5c3Ryb2tlLmtOYW1lO1xyXG4gICAgICAgIHRoaXMua2V5RGlzdHJpYnV0aW9uID0ga2V5c3Ryb2tlLmtleURpc3RyaWJ1dGlvbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJdCBtaWdodCBiZSBhIHJhdyBvYmplY3QsIGZyb20gSlNPTi5cclxuICAgICAgICB0aGlzLmxheWVyID0ga2V5c3Ryb2tlLmxheWVyO1xyXG4gICAgICAgIHRoaXMua2V5TmFtZSA9IGtleXN0cm9rZS5rZXlOYW1lO1xyXG4gICAgICAgIHRoaXMua2V5RGlzdHJpYnV0aW9uID0ga2V5c3Ryb2tlLmtleURpc3RyaWJ1dGlvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldCBpbnB1dEV2ZW50U3BlYygpOiBJbnB1dEV2ZW50U3BlYyB7XHJcbiAgICAgIGxldCBldmVudFNwZWMgPSBuZXcgT1NLSW5wdXRFdmVudFNwZWMoKTtcclxuICAgICAgZXZlbnRTcGVjLmtleUlEID0gdGhpcy5sYXllciArICctJyArIHRoaXMua2V5TmFtZTtcclxuXHJcbiAgICAgIHJldHVybiBldmVudFNwZWM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgVGVzdFNlcXVlbmNlPEtleVJlY29yZCBleHRlbmRzIFJlY29yZGVkS2V5c3Ryb2tlIHwgSW5wdXRFdmVudFNwZWM+IHtcclxuICAgIGlucHV0czogS2V5UmVjb3JkW107XHJcbiAgICBvdXRwdXQ6IHN0cmluZztcclxuICAgIG1zZz86IHN0cmluZztcclxuXHJcbiAgICBhYnN0cmFjdCBoYXNPU0tJbnRlcmFjdGlvbigpOiBib29sZWFuO1xyXG5cclxuICAgIHRlc3QocHJvY3RvcjogUHJvY3RvciwgdGFyZ2V0PzogY29tLmtleW1hbi50ZXh0Lk91dHB1dFRhcmdldCk6IHtzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ6IHN0cmluZ30ge1xyXG4gICAgICAvLyBTdGFydCB3aXRoIGFuIGVtcHR5IE91dHB1dFRhcmdldCBhbmQgYSBmcmVzaCBLZXlib2FyZFByb2Nlc3Nvci5cclxuICAgICAgaWYoIXRhcmdldCkge1xyXG4gICAgICAgIHRhcmdldCA9IG5ldyBjb20ua2V5bWFuLnRleHQuTW9jaygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcm9jdG9yLmJlZm9yZSgpO1xyXG5cclxuICAgICAgbGV0IHJlc3VsdCA9IHByb2N0b3Iuc2ltdWxhdGVTZXF1ZW5jZSh0aGlzLCB0YXJnZXQpO1xyXG4gICAgICBwcm9jdG9yLmFzc2VydEVxdWFscyhyZXN1bHQsIHRoaXMub3V0cHV0LCB0aGlzLm1zZyk7XHJcblxyXG4gICAgICByZXR1cm4ge3N1Y2Nlc3M6IChyZXN1bHQgPT0gdGhpcy5vdXRwdXQpLCByZXN1bHQ6IHJlc3VsdH07XHJcbiAgICB9XHJcblxyXG4gICAgdG9QcmV0dHlKU09OKCk6IHN0cmluZyB7XHJcbiAgICAgIHZhciBzdHIgPSBcInsgXCI7XHJcbiAgICAgIGlmKHRoaXMub3V0cHV0KSB7XHJcbiAgICAgICAgc3RyICs9IFwiXFxcIm91dHB1dFxcXCI6IFxcXCJcIiArIHRoaXMub3V0cHV0ICsgXCJcXFwiLCBcIjtcclxuICAgICAgfVxyXG4gICAgICBzdHIgKz0gXCJcXFwiaW5wdXRzXFxcIjogW1xcblwiO1xyXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzdHIgKz0gXCIgIFwiICsgdGhpcy5pbnB1dHNbaV0udG9QcmV0dHlKU09OKCkgKyAoKGkgPT0gdGhpcy5pbnB1dHMubGVuZ3RoLTEpID8gXCJcXG5cIiA6IFwiLFxcblwiKTtcclxuICAgICAgfVxyXG4gICAgICBpZih0aGlzLm1zZykge1xyXG4gICAgICAgIHN0ciArPSBcIl0sIFxcXCJtZXNzYWdlXFxcIjogXFxcIlwiICsgdGhpcy5tc2cgKyBcIlxcXCIgfVwiO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0ciArPSBcIl19XCI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBJbnB1dEV2ZW50U3BlY1NlcXVlbmNlIGV4dGVuZHMgVGVzdFNlcXVlbmNlPElucHV0RXZlbnRTcGVjPiB7XHJcbiAgICBpbnB1dHM6IElucHV0RXZlbnRTcGVjW107XHJcbiAgICBvdXRwdXQ6IHN0cmluZztcclxuICAgIG1zZz86IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpbnM/OiBJbnB1dEV2ZW50U3BlY1tdIHwgSW5wdXRFdmVudFNwZWNTZXF1ZW5jZSwgb3V0cz86IHN0cmluZywgbXNnPzogc3RyaW5nKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICBpZihpbnMpIHtcclxuICAgICAgICBpZihpbnMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSBbXS5jb25jYXQoaW5zKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gV2UncmUgY29uc3RydWN0aW5nIGZyb20gZXhpc3RpbmcgSlNPTi5cclxuICAgICAgICAgIHRoaXMuaW5wdXRzID0gW107XHJcblxyXG4gICAgICAgICAgZm9yKHZhciBpZT0wOyBpZSA8IGlucy5pbnB1dHMubGVuZ3RoOyBpZSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzLnB1c2goSW5wdXRFdmVudFNwZWMuZnJvbUpTT05PYmplY3QoaW5zLmlucHV0c1tpZV0pKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLm91dHB1dCA9IGlucy5vdXRwdXQ7XHJcbiAgICAgICAgICB0aGlzLm1zZyA9IGlucy5tc2c7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaW5wdXRzID0gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKG91dHMpIHtcclxuICAgICAgICB0aGlzLm91dHB1dCA9IG91dHM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKG1zZykge1xyXG4gICAgICAgIHRoaXMubXNnID0gbXNnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkSW5wdXQoZXZlbnQ6IElucHV0RXZlbnRTcGVjLCBvdXRwdXQ6IHN0cmluZykge1xyXG4gICAgICB0aGlzLmlucHV0cy5wdXNoKGV2ZW50KTtcclxuICAgICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaGFzT1NLSW50ZXJhY3Rpb24oKTogYm9vbGVhbiB7XHJcbiAgICAgIGZvcih2YXIgaT0wOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZih0aGlzLmlucHV0c1tpXSBpbnN0YW5jZW9mIE9TS0lucHV0RXZlbnRTcGVjKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBSZWNvcmRlZEtleXN0cm9rZVNlcXVlbmNlIGV4dGVuZHMgVGVzdFNlcXVlbmNlPFJlY29yZGVkS2V5c3Ryb2tlPiB7XHJcbiAgICBpbnB1dHM6IFJlY29yZGVkS2V5c3Ryb2tlW107XHJcbiAgICBvdXRwdXQ6IHN0cmluZztcclxuICAgIG1zZz86IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpbnM/OiBSZWNvcmRlZEtleXN0cm9rZVtdLCBvdXRzPzogc3RyaW5nLCBtc2c/OiBzdHJpbmcpXHJcbiAgICBjb25zdHJ1Y3RvcihzZXF1ZW5jZTogUmVjb3JkZWRLZXlzdHJva2VTZXF1ZW5jZSlcclxuICAgIGNvbnN0cnVjdG9yKGlucz86IFJlY29yZGVkS2V5c3Ryb2tlW10gfCBSZWNvcmRlZEtleXN0cm9rZVNlcXVlbmNlLCBvdXRzPzogc3RyaW5nLCBtc2c/OiBzdHJpbmcpIHtcclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIGlmKGlucykge1xyXG4gICAgICAgIGlmKGlucyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICB0aGlzLmlucHV0cyA9IFtdLmNvbmNhdChpbnMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBXZSdyZSBjb25zdHJ1Y3RpbmcgZnJvbSBleGlzdGluZyBKU09OLlxyXG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSBbXTtcclxuXHJcbiAgICAgICAgICBmb3IodmFyIGllPTA7IGllIDwgaW5zLmlucHV0cy5sZW5ndGg7IGllKyspIHtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dHMucHVzaChSZWNvcmRlZEtleXN0cm9rZS5mcm9tSlNPTk9iamVjdChpbnMuaW5wdXRzW2llXSkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMub3V0cHV0ID0gaW5zLm91dHB1dDtcclxuICAgICAgICAgIHRoaXMubXNnID0gaW5zLm1zZztcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYob3V0cykge1xyXG4gICAgICAgIHRoaXMub3V0cHV0ID0gb3V0cztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYobXNnKSB7XHJcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRJbnB1dChldmVudDogUmVjb3JkZWRLZXlzdHJva2UsIG91dHB1dDogc3RyaW5nKSB7XHJcbiAgICAgIHRoaXMuaW5wdXRzLnB1c2goZXZlbnQpO1xyXG4gICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcclxuICAgIH1cclxuXHJcbiAgICBoYXNPU0tJbnRlcmFjdGlvbigpOiBib29sZWFuIHtcclxuICAgICAgZm9yKHZhciBpPTA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmKHRoaXMuaW5wdXRzW2ldIGluc3RhbmNlb2YgUmVjb3JkZWRTeW50aGV0aWNLZXlzdHJva2UpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2xhc3MgRm9udFN0dWJGb3JMYW5ndWFnZSB7XHJcbiAgICBmYW1pbHk6IHN0cmluZztcclxuICAgIHNvdXJjZTogc3RyaW5nW107XHJcblxyXG4gICAgY29uc3RydWN0b3IoYWN0aXZlU3R1YkVudHJ5OiBhbnkpIHtcclxuICAgICAgdGhpcy5mYW1pbHkgPSBhY3RpdmVTdHViRW50cnkuZmFtaWx5O1xyXG5cclxuICAgICAgdmFyIHNyYyA9IGFjdGl2ZVN0dWJFbnRyeS5maWxlcztcclxuICAgICAgaWYoIShzcmMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICBzcmMgPSBbIHNyYyBdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnNvdXJjZSA9IFtdO1xyXG4gICAgICBmb3IodmFyIGk9MDsgaSA8IHNyYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuc291cmNlLnB1c2goYWN0aXZlU3R1YkVudHJ5LnBhdGggKyBzcmNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgTGFuZ3VhZ2VTdHViRm9yS2V5Ym9hcmQge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHJlZ2lvbjogc3RyaW5nO1xyXG4gICAgZm9udD86IEZvbnRTdHViRm9yTGFuZ3VhZ2U7XHJcbiAgICBvc2tGb250PzogRm9udFN0dWJGb3JMYW5ndWFnZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmVTdHViOiBhbnkpIHtcclxuICAgICAgaWYoYWN0aXZlU3R1Yi5LTEMpIHtcclxuICAgICAgICB0aGlzLmlkID0gYWN0aXZlU3R1Yi5LTEM7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gYWN0aXZlU3R1Yi5LTDtcclxuICAgICAgICB0aGlzLnJlZ2lvbiA9IGFjdGl2ZVN0dWIuS1I7XHJcbiAgXHJcbiAgICAgICAgLy8gRm9udHMuXHJcbiAgICAgICAgaWYoYWN0aXZlU3R1Yi5LRm9udCkge1xyXG4gICAgICAgICAgdGhpcy5mb250ID0gbmV3IEZvbnRTdHViRm9yTGFuZ3VhZ2UoYWN0aXZlU3R1Yi5LRm9udCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFjdGl2ZVN0dWIuS09za0ZvbnQpIHtcclxuICAgICAgICAgIHRoaXMub3NrRm9udCA9IG5ldyBGb250U3R1YkZvckxhbmd1YWdlKGFjdGl2ZVN0dWIuS09za0ZvbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmlkID0gYWN0aXZlU3R1Yi5pZDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBhY3RpdmVTdHViLm5hbWU7XHJcbiAgICAgICAgdGhpcy5yZWdpb24gPSBhY3RpdmVTdHViLnJlZ2lvbjtcclxuXHJcbiAgICAgICAgLy8gSWYgd2UgZW5kIHVwIGFkZGluZyBmdW5jdGlvbmFsaXR5IHRvIEZvbnRTdHViRm9yTGFuZ3VhZ2UsIHdlJ2xsIG5lZWQgdG8gcHJvcGVybHkgcmVjb25zdHJ1Y3QgdGhlc2UuXHJcbiAgICAgICAgdGhpcy5mb250ID0gYWN0aXZlU3R1Yi5mb250O1xyXG4gICAgICAgIHRoaXMub3NrRm9udCA9IGFjdGl2ZVN0dWIub3NrRm9udDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIEtleWJvYXJkU3R1YiB7XHJcbiAgICBpZDogc3RyaW5nO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgZmlsZW5hbWU6IHN0cmluZztcclxuICAgIGxhbmd1YWdlczogTGFuZ3VhZ2VTdHViRm9yS2V5Ym9hcmQgfCBMYW5ndWFnZVN0dWJGb3JLZXlib2FyZFtdO1xyXG5cclxuICAgIC8vIENvbnN0cnVjdHMgYSBzdHViIHVzYWJsZSB3aXRoIEtleW1hbldlYidzIGFkZEtleWJvYXJkcygpIEFQSSBmdW5jdGlvbiBmcm9tXHJcbiAgICAvLyB0aGUgaW50ZXJuYWxseS10cmFja2VkIEFjdGl2ZVN0dWIgdmFsdWUgZm9yIHRoYXQga2V5Ym9hcmQuXHJcbiAgICBjb25zdHJ1Y3Rvcihqc29uPzogS2V5Ym9hcmRTdHViKSB7XHJcbiAgICAgIGlmKGpzb24pIHtcclxuICAgICAgICB0aGlzLmlkID0ganNvbi5pZDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBqc29uLm5hbWU7XHJcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGpzb24uZmlsZW5hbWU7XHJcblxyXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KGpzb24ubGFuZ3VhZ2VzKSkge1xyXG4gICAgICAgICAgdGhpcy5sYW5ndWFnZXMgPSBuZXcgTGFuZ3VhZ2VTdHViRm9yS2V5Ym9hcmQoanNvbi5sYW5ndWFnZXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmxhbmd1YWdlcyA9IFtdO1xyXG4gICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBqc29uLmxhbmd1YWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmxhbmd1YWdlcy5wdXNoKG5ldyBMYW5ndWFnZVN0dWJGb3JLZXlib2FyZChqc29uLmxhbmd1YWdlc1tpXSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldEZpcnN0TGFuZ3VhZ2UoKSB7XHJcbiAgICAgIGlmKHRoaXMubGFuZ3VhZ2VzIGluc3RhbmNlb2YgTGFuZ3VhZ2VTdHViRm9yS2V5Ym9hcmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZXMuaWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFuZ3VhZ2VzWzBdLmlkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0eXBlIFRBUkdFVCA9ICdoYXJkd2FyZSd8J2Rlc2t0b3AnfCdwaG9uZSd8J3RhYmxldCc7XHJcbiAgdHlwZSBPUyA9ICd3aW5kb3dzJ3wnYW5kcm9pZCd8J2lvcyd8J21hY29zeCd8J2xpbnV4JztcclxuICB0eXBlIEJST1dTRVIgPSAnaWUnfCdjaHJvbWUnfCdmaXJlZm94J3wnc2FmYXJpJ3wnb3BlcmEnOyAgLy8gISBubyAnZWRnZScgZGV0ZWN0aW9uIGluIEtNVyFcclxuXHJcbiAgZXhwb3J0IGNsYXNzIENvbnN0cmFpbnQge1xyXG4gICAgdGFyZ2V0OiBUQVJHRVQ7XHJcbiAgICB2YWxpZE9TTGlzdD86IE9TW107XHJcbiAgICB2YWxpZEJyb3dzZXJzPzogQlJPV1NFUltdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldDogVEFSR0VUfENvbnN0cmFpbnQsIHZhbGlkT1NMaXN0PzogT1NbXSwgdmFsaWRCcm93c2Vycz86IEJST1dTRVJbXSkge1xyXG4gICAgICBpZih0eXBlb2YodGFyZ2V0KSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMudmFsaWRPU0xpc3QgPSB2YWxpZE9TTGlzdDtcclxuICAgICAgICB0aGlzLnZhbGlkQnJvd3NlcnMgPSB2YWxpZEJyb3dzZXJzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBqc29uID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0ganNvbi50YXJnZXQ7XHJcbiAgICAgICAgdGhpcy52YWxpZE9TTGlzdCA9IGpzb24udmFsaWRPU0xpc3Q7XHJcbiAgICAgICAgdGhpcy52YWxpZEJyb3dzZXJzID0ganNvbi52YWxpZEJyb3dzZXJzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbWF0Y2hlc0NsaWVudChkZXZpY2U6IGNvbS5rZXltYW4udXRpbHMuRGV2aWNlU3BlYywgdXNpbmdPU0s/OiBib29sZWFuKSB7XHJcbiAgICAgIC8vICMxOiAgUGxhdGZvcm0gY2hlY2suXHJcbiAgICAgIGlmKHVzaW5nT1NLID09PSB0cnVlKSB7XHJcbiAgICAgICAgaWYodGhpcy50YXJnZXQgIT0gZGV2aWNlLmZvcm1GYWN0b3IpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZih1c2luZ09TSyA9PT0gZmFsc2UpIHtcclxuICAgICAgICBpZih0aGlzLnRhcmdldCAhPSAnaGFyZHdhcmUnKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYodGhpcy50YXJnZXQgIT0gZGV2aWNlLmZvcm1GYWN0b3IgJiYgdGhpcy50YXJnZXQgIT0gJ2hhcmR3YXJlJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYodGhpcy52YWxpZE9TTGlzdCkge1xyXG4gICAgICAgIGlmKHRoaXMudmFsaWRPU0xpc3QuaW5kZXhPZihkZXZpY2UuT1MgYXMgT1MpID09IC0xKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZih0aGlzLnZhbGlkQnJvd3NlcnMpIHtcclxuICAgICAgICBpZih0aGlzLnZhbGlkQnJvd3NlcnMuaW5kZXhPZihkZXZpY2UuYnJvd3NlciBhcyBCUk9XU0VSKSA9PSAtMSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2tzIGlmIGFub3RoZXIgQ29uc3RyYWludCBpbnN0YW5jZSBpcyBmdW5jdGlvbmFsbHkgaWRlbnRpY2FsIHRvIHRoaXMgb25lLlxyXG4gICAgZXF1YWxzKG90aGVyOiBDb25zdHJhaW50KSB7XHJcbiAgICAgIGlmKHRoaXMudGFyZ2V0ICE9IG90aGVyLnRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGxpc3QxID0gdGhpcy52YWxpZE9TTGlzdCA/IHRoaXMudmFsaWRPU0xpc3QgOiBbJ2FueSddO1xyXG4gICAgICB2YXIgbGlzdDIgPSBvdGhlci52YWxpZE9TTGlzdCA/IG90aGVyLnZhbGlkT1NMaXN0IDogWydhbnknXTtcclxuXHJcbiAgICAgIGlmKGxpc3QxLnNvcnQoKS5qb2luKCcsJykgIT0gbGlzdDIuc29ydCgpLmpvaW4oJywnKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGlzdDEgPSB0aGlzLnZhbGlkQnJvd3NlcnMgPyB0aGlzLnZhbGlkQnJvd3NlcnMgOiBbJ3dlYiddO1xyXG4gICAgICBsaXN0MiA9IG90aGVyLnZhbGlkQnJvd3NlcnMgPyBvdGhlci52YWxpZEJyb3dzZXJzIDogWyd3ZWInXTtcclxuXHJcbiAgICAgIGlmKGxpc3QxLnNvcnQoKS5qb2luKCcsJykgIT0gbGlzdDIuc29ydCgpLmpvaW4oJywnKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgVGVzdEZhaWx1cmUge1xyXG4gICAgY29uc3RyYWludDogQ29uc3RyYWludDtcclxuICAgIHRlc3Q6IElucHV0RXZlbnRTcGVjU2VxdWVuY2U7XHJcbiAgICByZXN1bHQ6IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJhaW50OiBDb25zdHJhaW50LCB0ZXN0OiBJbnB1dEV2ZW50U3BlY1NlcXVlbmNlLCBvdXRwdXQ6IHN0cmluZykge1xyXG4gICAgICB0aGlzLmNvbnN0cmFpbnQgPSBjb25zdHJhaW50O1xyXG4gICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG4gICAgICB0aGlzLnJlc3VsdCA9IG91dHB1dDtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgZXhwb3J0IGludGVyZmFjZSBUZXN0U2V0PFNlcXVlbmNlIGV4dGVuZHMgVGVzdFNlcXVlbmNlPGFueT4+IHtcclxuICAgIGNvbnN0cmFpbnQ6IENvbnN0cmFpbnQ7XHJcblxyXG4gICAgYWRkVGVzdChzZXE6IFNlcXVlbmNlKTogdm9pZDtcclxuICAgIGlzVmFsaWRGb3JEZXZpY2UoZGV2aWNlOiBjb20ua2V5bWFuLnV0aWxzLkRldmljZVNwZWMsIHVzaW5nT1NLPzogYm9vbGVhbik6IGJvb2xlYW47XHJcbiAgICB0ZXN0KHByb2N0b3I6IFByb2N0b3IpOiBUZXN0RmFpbHVyZVtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGNvcmUgY29uc3RyYWludC1zcGVjaWZpYyB0ZXN0IHNldCBkZWZpbml0aW9uIHVzZWQgZm9yIHRlc3RpbmcgdmVyc2lvbnMgMTAuMCB0byAxMy4wLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBFdmVudFNwZWNUZXN0U2V0IGltcGxlbWVudHMgVGVzdFNldDxJbnB1dEV2ZW50U3BlY1NlcXVlbmNlPiB7XHJcbiAgICBjb25zdHJhaW50OiBDb25zdHJhaW50O1xyXG4gICAgdGVzdFNldDogSW5wdXRFdmVudFNwZWNTZXF1ZW5jZVtdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbnN0cmFpbnQ6IENvbnN0cmFpbnR8RXZlbnRTcGVjVGVzdFNldCkge1xyXG4gICAgICBpZihcInRhcmdldFwiIGluIGNvbnN0cmFpbnQpIHtcclxuICAgICAgICB0aGlzLmNvbnN0cmFpbnQgPSBjb25zdHJhaW50IGFzIENvbnN0cmFpbnQ7XHJcbiAgICAgICAgdGhpcy50ZXN0U2V0ID0gW107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGpzb24gPSBjb25zdHJhaW50IGFzIEV2ZW50U3BlY1Rlc3RTZXQ7XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW50ID0gbmV3IENvbnN0cmFpbnQoanNvbi5jb25zdHJhaW50KTtcclxuICAgICAgICB0aGlzLnRlc3RTZXQgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gQ2xvbmUgZWFjaCB0ZXN0IHNlcXVlbmNlIC8gcmVjb25zdHJ1Y3QgZnJvbSBtZXRob2RsZXNzIEpTT04gb2JqZWN0LlxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwganNvbi50ZXN0U2V0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLnRlc3RTZXQucHVzaChuZXcgSW5wdXRFdmVudFNwZWNTZXF1ZW5jZShqc29uLnRlc3RTZXRbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRUZXN0KHNlcTogSW5wdXRFdmVudFNwZWNTZXF1ZW5jZSkge1xyXG4gICAgICB0aGlzLnRlc3RTZXQucHVzaChzZXEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IEV2ZW50U3BlY1Rlc3RTZXQgaXMgYXBwbGljYWJsZSB0byBiZSBydW4gb24gYSBkZXZpY2UuXHJcbiAgICBpc1ZhbGlkRm9yRGV2aWNlKGRldmljZTogY29tLmtleW1hbi51dGlscy5EZXZpY2VTcGVjLCB1c2luZ09TSz86IGJvb2xlYW4pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludC5tYXRjaGVzQ2xpZW50KGRldmljZSwgdXNpbmdPU0spO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhbGlkaXR5IHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxyXG4gICAgdGVzdChwcm9jdG9yOiBQcm9jdG9yKTogVGVzdEZhaWx1cmVbXSB7XHJcbiAgICAgIHZhciBmYWlsdXJlczogVGVzdEZhaWx1cmVbXSA9IFtdO1xyXG4gICAgICBsZXQgdGVzdFNldCA9IHRoaXMudGVzdFNldDtcclxuXHJcbiAgICAgIGZvcih2YXIgaT0wOyBpIDwgdGVzdFNldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciB0ZXN0U2VxID0gdGhpc1tpXTtcclxuICAgICAgICB2YXIgc2ltUmVzdWx0ID0gdGVzdFNldFtpXS50ZXN0KHByb2N0b3IpO1xyXG4gICAgICAgIGlmKCFzaW1SZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgLy8gRmFpbGVkIHRlc3QhXHJcbiAgICAgICAgICBmYWlsdXJlcy5wdXNoKG5ldyBUZXN0RmFpbHVyZSh0aGlzLmNvbnN0cmFpbnQsIHRlc3RTZXEsIHNpbVJlc3VsdC5yZXN1bHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWlsdXJlcy5sZW5ndGggPiAwID8gZmFpbHVyZXMgOiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGNvcmUgY29uc3RyYWludC1zcGVjaWZpYyB0ZXN0IHNldCBkZWZpbml0aW9uIHVzZWQgZm9yIHRlc3RpbmcgdmVyc2lvbnMgMTAuMCB0byAxMy4wLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZWNvcmRlZFNlcXVlbmNlVGVzdFNldCBpbXBsZW1lbnRzIFRlc3RTZXQ8UmVjb3JkZWRLZXlzdHJva2VTZXF1ZW5jZT4ge1xyXG4gICAgY29uc3RyYWludDogQ29uc3RyYWludDtcclxuICAgIHRlc3RTZXQ6IFJlY29yZGVkS2V5c3Ryb2tlU2VxdWVuY2VbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJhaW50OiBDb25zdHJhaW50fFJlY29yZGVkU2VxdWVuY2VUZXN0U2V0KSB7XHJcbiAgICAgIGlmKFwidGFyZ2V0XCIgaW4gY29uc3RyYWludCkge1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWludCA9IGNvbnN0cmFpbnQgYXMgQ29uc3RyYWludDtcclxuICAgICAgICB0aGlzLnRlc3RTZXQgPSBbXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIganNvbiA9IGNvbnN0cmFpbnQgYXMgUmVjb3JkZWRTZXF1ZW5jZVRlc3RTZXQ7XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW50ID0gbmV3IENvbnN0cmFpbnQoanNvbi5jb25zdHJhaW50KTtcclxuICAgICAgICB0aGlzLnRlc3RTZXQgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gQ2xvbmUgZWFjaCB0ZXN0IHNlcXVlbmNlIC8gcmVjb25zdHJ1Y3QgZnJvbSBtZXRob2RsZXNzIEpTT04gb2JqZWN0LlxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwganNvbi50ZXN0U2V0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLnRlc3RTZXQucHVzaChuZXcgUmVjb3JkZWRLZXlzdHJva2VTZXF1ZW5jZShqc29uLnRlc3RTZXRbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRUZXN0KHNlcTogUmVjb3JkZWRLZXlzdHJva2VTZXF1ZW5jZSkge1xyXG4gICAgICB0aGlzLnRlc3RTZXQucHVzaChzZXEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IEV2ZW50U3BlY1Rlc3RTZXQgaXMgYXBwbGljYWJsZSB0byBiZSBydW4gb24gYSBkZXZpY2UuXHJcbiAgICBpc1ZhbGlkRm9yRGV2aWNlKGRldmljZTogY29tLmtleW1hbi51dGlscy5EZXZpY2VTcGVjLCB1c2luZ09TSz86IGJvb2xlYW4pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludC5tYXRjaGVzQ2xpZW50KGRldmljZSwgdXNpbmdPU0spO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhbGlkaXR5IHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxyXG4gICAgdGVzdChwcm9jdG9yOiBQcm9jdG9yKTogVGVzdEZhaWx1cmVbXSB7XHJcbiAgICAgIHZhciBmYWlsdXJlczogVGVzdEZhaWx1cmVbXSA9IFtdO1xyXG4gICAgICBsZXQgdGVzdFNldCA9IHRoaXMudGVzdFNldDtcclxuXHJcbiAgICAgIGZvcih2YXIgaT0wOyBpIDwgdGVzdFNldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciB0ZXN0U2VxID0gdGhpc1tpXTtcclxuICAgICAgICB2YXIgc2ltUmVzdWx0ID0gdGVzdFNldFtpXS50ZXN0KHByb2N0b3IpO1xyXG4gICAgICAgIGlmKCFzaW1SZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgLy8gRmFpbGVkIHRlc3QhXHJcbiAgICAgICAgICBmYWlsdXJlcy5wdXNoKG5ldyBUZXN0RmFpbHVyZSh0aGlzLmNvbnN0cmFpbnQsIHRlc3RTZXEsIHNpbVJlc3VsdC5yZXN1bHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWlsdXJlcy5sZW5ndGggPiAwID8gZmFpbHVyZXMgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRvVGVzdE5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IG5hbWUgPSBcImNvbnN0cmFpbnQ6IGZvciBcIiArIHRoaXMuY29uc3RyYWludC50YXJnZXQ7XHJcblxyXG4gICAgICBpZih0aGlzLmNvbnN0cmFpbnQudGFyZ2V0ID09ICdoYXJkd2FyZScpIHtcclxuICAgICAgICBuYW1lICs9IFwiIGtleWJvYXJkXCI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbmFtZSArPSBcIiBPU0tcIjtcclxuICAgICAgfVxyXG4gICAgICBpZih0aGlzLmNvbnN0cmFpbnQudmFsaWRPU0xpc3QpIHtcclxuICAgICAgICBuYW1lICs9IFwiIG9uIE9TIG9mIFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5jb25zdHJhaW50LnZhbGlkT1NMaXN0KTtcclxuICAgICAgfVxyXG4gICAgICBpZih0aGlzLmNvbnN0cmFpbnQudmFsaWRCcm93c2Vycykge1xyXG4gICAgICAgIG5hbWUgKz0gXCIgaW4gYnJvd3NlciBvZiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuY29uc3RyYWludC52YWxpZEJyb3dzZXJzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgS2V5Ym9hcmRUZXN0IHtcclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHdoYXQgdmVyc2lvbiBvZiBLTVcncyByZWNvcmRlciB0aGUgc3BlYyBjb25mb3JtcyB0by5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNwZWNWZXJzaW9uOiBjb20ua2V5bWFuLnV0aWxzLlZlcnNpb24gPSBLZXlib2FyZFRlc3QuQ1VSUkVOVF9WRVJTSU9OO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZlcnNpb24gb2YgS01XIGluIHdoaWNoIHRoZSBSZWNvcmRlciB3YXMgZmlyc3Qgd3JpdHRlbi4gIFdvcmtlZCBmcm9tIDEwLjAgdG8gMTMuMCB3aXRoIFxyXG4gICAgICogb25seSBiYWNrd2FyZC1jb21wYXRpYmxlIGNoYW5nZXMgYW5kIG1pbm9yIHR3ZWFrcyB0byBjb25mb3JtIHRvIGludGVybmFsIEFQSSBzaGlmdHMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRkFMTEJBQ0tfVkVSU0lPTiA9IG5ldyBjb20ua2V5bWFuLnV0aWxzLlZlcnNpb24oXCIxMC4wXCIpO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBDVVJSRU5UX1ZFUlNJT04gID0gbmV3IGNvbS5rZXltYW4udXRpbHMuVmVyc2lvbihcIjE0LjBcIik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3R1YiBpbmZvcm1hdGlvbiB0byBiZSBwYXNzZWQgaW50byBrZXltYW4uYWRkS2V5Ym9hcmRzKCkgaW4gb3JkZXIgdG8gcnVuIHRoZSB0ZXN0LlxyXG4gICAgICovXHJcbiAgICBrZXlib2FyZDogS2V5Ym9hcmRTdHViO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1hc3RlciBhcnJheSBvZiB0ZXN0IHNldHMsIGVhY2ggb2Ygd2hpY2ggc3BlY2lmaWVzIGNvbnN0cmFpbnRzIGEgY2xpZW50IG11c3QgZnVsZmlsbCBmb3JcclxuICAgICAqIHRoZSB0ZXN0cyBjb250YWluZWQgdGhlcmVpbiB0byBiZSB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgaW5wdXRUZXN0U2V0czogVGVzdFNldDxhbnk+W107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNvbnN0cnVjdHMgYSBLZXlib2FyZFRlc3Qgb2JqZWN0IGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24sIHJlc3RvcmluZyBpdHMgbWV0aG9kcy4gXHJcbiAgICAgKiBAcGFyYW0gZnJvbUpTT04gXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGZyb21KU09OPzogc3RyaW5nfEtleWJvYXJkU3R1YnxLZXlib2FyZFRlc3QpIHtcclxuICAgICAgaWYoIWZyb21KU09OKSB7XHJcbiAgICAgICAgdGhpcy5rZXlib2FyZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbnB1dFRlc3RTZXRzID0gW107XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IGVsc2UgaWYodHlwZW9mKGZyb21KU09OKSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGZyb21KU09OID0gSlNPTi5wYXJzZShmcm9tSlNPTikgYXMgS2V5Ym9hcmRUZXN0O1xyXG4gICAgICB9IGVsc2UgaWYoZnJvbUpTT04gaW5zdGFuY2VvZiBLZXlib2FyZFN0dWIpIHtcclxuICAgICAgICB0aGlzLmtleWJvYXJkID0gZnJvbUpTT047XHJcbiAgICAgICAgdGhpcy5pbnB1dFRlc3RTZXRzID0gW107XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZighZnJvbUpTT04uc3BlY1ZlcnNpb24pIHtcclxuICAgICAgICBmcm9tSlNPTi5zcGVjVmVyc2lvbiA9IEtleWJvYXJkVGVzdC5GQUxMQkFDS19WRVJTSU9OO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIElzIHNlcmlhbGl6ZWQgdG8gYSBTdHJpbmcgd2hlbiBzYXZlZC5cclxuICAgICAgICBmcm9tSlNPTi5zcGVjVmVyc2lvbiA9IG5ldyBjb20ua2V5bWFuLnV0aWxzLlZlcnNpb24oZnJvbUpTT04uc3BlY1ZlcnNpb24gYXMgdW5rbm93biBhcyBzdHJpbmcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmtleWJvYXJkID0gbmV3IEtleWJvYXJkU3R1Yihmcm9tSlNPTi5rZXlib2FyZCk7XHJcbiAgICAgIHRoaXMuaW5wdXRUZXN0U2V0cyA9IFtdO1xyXG4gICAgICB0aGlzLnNwZWNWZXJzaW9uID0gZnJvbUpTT04uc3BlY1ZlcnNpb247XHJcblxyXG4gICAgICBpZih0aGlzLnNwZWNWZXJzaW9uLmVxdWFscyhLZXlib2FyZFRlc3QuRkFMTEJBQ0tfVkVSU0lPTikpIHtcclxuICAgICAgICAvLyBUb3AtbGV2ZWwgdGVzdCBzcGVjOiAgRXZlbnRTcGVjVGVzdFNldCwgYmFzZWQgZW50aXJlbHkgb24gYnJvd3NlciBldmVudHMuXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBmcm9tSlNPTi5pbnB1dFRlc3RTZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLmlucHV0VGVzdFNldHNbaV0gPSBuZXcgRXZlbnRTcGVjVGVzdFNldChmcm9tSlNPTi5pbnB1dFRlc3RTZXRzW2ldIGFzIEV2ZW50U3BlY1Rlc3RTZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IGZyb21KU09OLmlucHV0VGVzdFNldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHRoaXMuaW5wdXRUZXN0U2V0c1tpXSA9IG5ldyBSZWNvcmRlZFNlcXVlbmNlVGVzdFNldChmcm9tSlNPTi5pbnB1dFRlc3RTZXRzW2ldIGFzIFJlY29yZGVkU2VxdWVuY2VUZXN0U2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRUZXN0KGNvbnN0cmFpbnQ6IENvbnN0cmFpbnQsIHNlcTogUmVjb3JkZWRLZXlzdHJva2VTZXF1ZW5jZSkge1xyXG4gICAgICBpZighdGhpcy5zcGVjVmVyc2lvbi5lcXVhbHMoS2V5Ym9hcmRUZXN0LkNVUlJFTlRfVkVSU0lPTikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudGx5LWxvYWRlZCB0ZXN0IHdhcyBidWlsdCB0byBhbiBvdXRkYXRlZCBzcGVjaWZpY2F0aW9uIGFuZCBtYXkgbm90IGJlIGFsdGVyZWQuXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IodmFyIGk9MDsgaSA8IHRoaXMuaW5wdXRUZXN0U2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmKHRoaXMuaW5wdXRUZXN0U2V0c1tpXS5jb25zdHJhaW50LmVxdWFscyhjb25zdHJhaW50KSkge1xyXG4gICAgICAgICAgdGhpcy5pbnB1dFRlc3RTZXRzW2ldLmFkZFRlc3Qoc2VxKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBuZXdTZXQgPSBuZXcgUmVjb3JkZWRTZXF1ZW5jZVRlc3RTZXQobmV3IENvbnN0cmFpbnQoY29uc3RyYWludCkpO1xyXG4gICAgICB0aGlzLmlucHV0VGVzdFNldHMucHVzaChuZXdTZXQpO1xyXG4gICAgICBuZXdTZXQuYWRkVGVzdChzZXEpOyAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHRlc3QocHJvY3RvcjogUHJvY3Rvcikge1xyXG4gICAgICB2YXIgc2V0SGFzUnVuID0gZmFsc2U7XHJcbiAgICAgIHZhciBmYWlsdXJlczogVGVzdEZhaWx1cmVbXSA9IFtdO1xyXG5cclxuICAgICAgcHJvY3Rvci5iZWZvcmVBbGwoKTtcclxuXHJcbiAgICAgIC8vIFRoZSBvcmlnaW5hbCB0ZXN0IHNwZWMgcmVxdWlyZXMgYSBicm93c2VyIGVudmlyb25tZW50IGFuZCB0aHVzIHJlcXVpcmVzIGl0cyBvd24gYC5ydW5gIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICBpZighKHByb2N0b3IuY29tcGF0aWJsZVdpdGhTdWl0ZSh0aGlzKSkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBwZXJmb3JtIHZlcnNpb24gXCIgKyBLZXlib2FyZFRlc3QuRkFMTEJBQ0tfVkVSU0lPTiArIFwiLWJhc2VkIHRlc3Rpbmcgb3V0c2lkZSBvZiBicm93c2VyLWJhc2VkIGVudmlyb25tZW50cy5cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHRlc3Qgc3BlYyBpbnN0YW5jZXMgd2lsbCBrbm93IGhvdyB0byBydW4gaW4gYW55IGN1cnJlbnRseS1zdXBwb3J0ZWQgZW52aXJvbm1lbnQuXHJcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0VGVzdFNldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgdGVzdFNldCA9IHRoaXMuaW5wdXRUZXN0U2V0c1tpXTtcclxuXHJcbiAgICAgICAgaWYocHJvY3Rvci5tYXRjaGVzVGVzdFNldCh0ZXN0U2V0KSkge1xyXG4gICAgICAgICAgdmFyIHRlc3RGYWlsdXJlcyA9IHRlc3RTZXQudGVzdChwcm9jdG9yKTtcclxuICAgICAgICAgIGlmKHRlc3RGYWlsdXJlcykge1xyXG4gICAgICAgICAgICBmYWlsdXJlcyA9IGZhaWx1cmVzLmNvbmNhdCh0ZXN0RmFpbHVyZXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2V0SGFzUnVuID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKCFzZXRIYXNSdW4pIHtcclxuICAgICAgICAvLyBUaGUgc2V0cyBDQU4gYmUgZW1wdHksIGFsbG93aW5nIHNpbGVudCBmYWlsdXJlIGlmL3doZW4gd2UgYWN0dWFsbHkgd2FudCB0aGF0LlxyXG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vIHRlc3Qgc2V0cyBmb3IgdGhpcyBrZXlib2FyZCB3ZXJlIGFwcGxpY2FibGUgZm9yIHRoaXMgZGV2aWNlIVwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWxsb3cgdGhlIG1ldGhvZCdzIGNhbGxlciB0byB0cmlnZ2VyIGEgJ2ZhaWwnLlxyXG4gICAgICBpZihmYWlsdXJlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWx1cmVzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5wdXRUZXN0U2V0cy5sZW5ndGggPT0gMDtcclxuICAgIH1cclxuXHJcbiAgICB0b1ByZXR0eUpTT04oKSB7XHJcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAnICAnKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgaXNMZWdhY3koKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zcGVjVmVyc2lvbi5lcXVhbHMoS2V5Ym9hcmRUZXN0LkNVUlJFTlRfVkVSU0lPTik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIGNvbS5rZXltYW4udGV4dCB7XHJcbiAgZXhwb3J0IHZhciBDb2RlcyA9IHtcclxuICAgIC8vIERlZmluZSBLZXltYW4gRGV2ZWxvcGVyIG1vZGlmaWVyIGJpdC1mbGFncyAoZXhwb3NlZCBmb3IgdXNlIGJ5IG90aGVyIG1vZHVsZXMpXHJcbiAgICAvLyBDb21wYXJlIGFnYWluc3QgL2NvbW1vbi9jb3JlL2Rlc2t0b3Avc3JjL2tteC9rbXhfZmlsZS5oLiAgQ1RSTCtGIFwiI2RlZmluZSBMQ1RSTEZMQUdcIiB0byBmaW5kIHRoZSBzZWN0b24uXHJcbiAgICBtb2RpZmllckNvZGVzOiB7XHJcbiAgICAgIFwiTENUUkxcIjoweDAwMDEsICAgICAgICAgICAvLyBMQ1RSTEZMQUdcclxuICAgICAgXCJSQ1RSTFwiOjB4MDAwMiwgICAgICAgICAgIC8vIFJDVFJMRkxBR1xyXG4gICAgICBcIkxBTFRcIjoweDAwMDQsICAgICAgICAgICAgLy8gTEFMVEZMQUdcclxuICAgICAgXCJSQUxUXCI6MHgwMDA4LCAgICAgICAgICAgIC8vIFJBTFRGTEFHXHJcbiAgICAgIFwiU0hJRlRcIjoweDAwMTAsICAgICAgICAgICAvLyBLX1NISUZURkxBR1xyXG4gICAgICBcIkNUUkxcIjoweDAwMjAsICAgICAgICAgICAgLy8gS19DVFJMRkxBR1xyXG4gICAgICBcIkFMVFwiOjB4MDA0MCwgICAgICAgICAgICAgLy8gS19BTFRGTEFHXHJcbiAgICAgIC8vIFRFTlRBVElWRTogIFJlcHJlc2VudHMgY29tbWFuZCBrZXlzLCB3aGljaCBzb21lIE9TZXMgdXNlIGZvciBzaG9ydGN1dHMgd2UgZG9uJ3RcclxuICAgICAgLy8gd2FudCB0byBibG9jay4gIE5vIHJ1bGUgd2lsbCBldmVyIHRhcmdldCBhIG1vZGlmaWVyIHNldCB3aXRoIHRoaXMgYml0IHNldCB0byAxLiBcclxuICAgICAgXCJNRVRBXCI6MHgwMDgwLCAgICAgICAgICAgIC8vIEtfTUVUQUZMQUdcclxuICAgICAgXCJDQVBTXCI6MHgwMTAwLCAgICAgICAgICAgIC8vIENBUElUQUxGTEFHXHJcbiAgICAgIFwiTk9fQ0FQU1wiOjB4MDIwMCwgICAgICAgICAvLyBOT1RDQVBJVEFMRkxBR1xyXG4gICAgICBcIk5VTV9MT0NLXCI6MHgwNDAwLCAgICAgICAgLy8gTlVNTE9DS0ZMQUdcclxuICAgICAgXCJOT19OVU1fTE9DS1wiOjB4MDgwMCwgICAgIC8vIE5PVE5VTUxPQ0tGTEFHXHJcbiAgICAgIFwiU0NST0xMX0xPQ0tcIjoweDEwMDAsICAgICAvLyBTQ1JPTExGTEFHXHJcbiAgICAgIFwiTk9fU0NST0xMX0xPQ0tcIjoweDIwMDAsICAvLyBOT1RTQ1JPTExGTEFHXHJcbiAgICAgIFwiVklSVFVBTF9LRVlcIjoweDQwMDAsICAgICAvLyBJU1ZJUlRVQUxLRVlcclxuICAgICAgXCJWSVJUVUFMX0NIQVJfS0VZXCI6MHg4MDAwIC8vIFZJUlRVQUxDSEFSS0VZIC8vIFVudXNlZCBieSBLTVcsIGJ1dCByZXNlcnZlZCBmb3IgdXNlIGJ5IG90aGVyIEtleW1hbiBlbmdpbmVzLlxyXG4gICAgfSxcclxuXHJcbiAgICBtb2RpZmllckJpdG1hc2tzOiB7XHJcbiAgICAgIFwiQUxMXCI6MHgwMDdGLFxyXG4gICAgICBcIkFMVF9HUl9TSU1cIjogKDB4MDAwMSB8IDB4MDAwNCksXHJcbiAgICAgIFwiQ0hJUkFMXCI6MHgwMDFGLCAgICAvLyBUaGUgYmFzZSBiaXRtYXNrIGZvciBjaGlyYWwga2V5Ym9hcmRzLiAgSW5jbHVkZXMgU0hJRlQsIHdoaWNoIGlzIG5vbi1jaGlyYWwuXHJcbiAgICAgIFwiSVNfQ0hJUkFMXCI6MHgwMDBGLCAvLyBVc2VkIHRvIHRlc3QgaWYgYSBiaXRtYXNrIHVzZXMgYSBjaGlyYWwgbW9kaWZpZXIuXHJcbiAgICAgIFwiTk9OX0NISVJBTFwiOjB4MDA3MCAvLyBUaGUgZGVmYXVsdCBiaXRtYXNrLCBmb3Igbm9uLWNoaXJhbCBrZXlib2FyZHNcclxuICAgIH0sXHJcblxyXG4gICAgc3RhdGVCaXRtYXNrczoge1xyXG4gICAgICBcIkFMTFwiOjB4M0YwMCxcclxuICAgICAgXCJDQVBTXCI6MHgwMzAwLFxyXG4gICAgICBcIk5VTV9MT0NLXCI6MHgwQzAwLFxyXG4gICAgICBcIlNDUk9MTF9MT0NLXCI6MHgzMDAwXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIERlZmluZSBzdGFuZGFyZCBrZXljb2RlIG51bWJlcnMgKGV4cG9zZWQgZm9yIHVzZSBieSBvdGhlciBtb2R1bGVzKVxyXG4gICAga2V5Q29kZXM6IHtcclxuICAgICAgXCJLX0JLU1BcIjo4LFwiS19UQUJcIjo5LFwiS19FTlRFUlwiOjEzLFxyXG4gICAgICBcIktfU0hJRlRcIjoxNixcIktfQ09OVFJPTFwiOjE3LFwiS19BTFRcIjoxOCxcIktfUEFVU0VcIjoxOSxcIktfQ0FQU1wiOjIwLFxyXG4gICAgICBcIktfRVNDXCI6MjcsXCJLX1NQQUNFXCI6MzIsXCJLX1BHVVBcIjozMyxcclxuICAgICAgXCJLX1BHRE5cIjozNCxcIktfRU5EXCI6MzUsXCJLX0hPTUVcIjozNixcIktfTEVGVFwiOjM3LFwiS19VUFwiOjM4LFxyXG4gICAgICBcIktfUklHSFRcIjozOSxcIktfRE9XTlwiOjQwLFwiS19TRUxcIjo0MSxcIktfUFJJTlRcIjo0MixcIktfRVhFQ1wiOjQzLFxyXG4gICAgICBcIktfSU5TXCI6NDUsXCJLX0RFTFwiOjQ2LFwiS19IRUxQXCI6NDcsXCJLXzBcIjo0OCxcclxuICAgICAgXCJLXzFcIjo0OSxcIktfMlwiOjUwLFwiS18zXCI6NTEsXCJLXzRcIjo1MixcIktfNVwiOjUzLFwiS182XCI6NTQsXCJLXzdcIjo1NSxcclxuICAgICAgXCJLXzhcIjo1NixcIktfOVwiOjU3LFwiS19BXCI6NjUsXCJLX0JcIjo2NixcIktfQ1wiOjY3LFwiS19EXCI6NjgsXCJLX0VcIjo2OSxcclxuICAgICAgXCJLX0ZcIjo3MCxcIktfR1wiOjcxLFwiS19IXCI6NzIsXCJLX0lcIjo3MyxcIktfSlwiOjc0LFwiS19LXCI6NzUsXCJLX0xcIjo3NixcclxuICAgICAgXCJLX01cIjo3NyxcIktfTlwiOjc4LFwiS19PXCI6NzksXCJLX1BcIjo4MCxcIktfUVwiOjgxLFwiS19SXCI6ODIsXCJLX1NcIjo4MyxcclxuICAgICAgXCJLX1RcIjo4NCxcIktfVVwiOjg1LFwiS19WXCI6ODYsXCJLX1dcIjo4NyxcIktfWFwiOjg4LFwiS19ZXCI6ODksXCJLX1pcIjo5MCxcclxuICAgICAgXCJLX05QMFwiOjk2LFwiS19OUDFcIjo5NyxcIktfTlAyXCI6OTgsXHJcbiAgICAgIFwiS19OUDNcIjo5OSxcIktfTlA0XCI6MTAwLFwiS19OUDVcIjoxMDEsXCJLX05QNlwiOjEwMixcclxuICAgICAgXCJLX05QN1wiOjEwMyxcIktfTlA4XCI6MTA0LFwiS19OUDlcIjoxMDUsXCJLX05QU1RBUlwiOjEwNixcclxuICAgICAgXCJLX05QUExVU1wiOjEwNyxcIktfU0VQQVJBVE9SXCI6MTA4LFwiS19OUE1JTlVTXCI6MTA5LFwiS19OUERPVFwiOjExMCxcclxuICAgICAgXCJLX05QU0xBU0hcIjoxMTEsXCJLX0YxXCI6MTEyLFwiS19GMlwiOjExMyxcIktfRjNcIjoxMTQsXCJLX0Y0XCI6MTE1LFxyXG4gICAgICBcIktfRjVcIjoxMTYsXCJLX0Y2XCI6MTE3LFwiS19GN1wiOjExOCxcIktfRjhcIjoxMTksXCJLX0Y5XCI6MTIwLFxyXG4gICAgICBcIktfRjEwXCI6MTIxLFwiS19GMTFcIjoxMjIsXCJLX0YxMlwiOjEyMyxcIktfTlVNTE9DS1wiOjE0NCxcIktfU0NST0xMXCI6MTQ1LFxyXG4gICAgICBcIktfTFNISUZUXCI6MTYwLFwiS19SU0hJRlRcIjoxNjEsXCJLX0xDT05UUk9MXCI6MTYyLFwiS19SQ09OVFJPTFwiOjE2MyxcclxuICAgICAgXCJLX0xBTFRcIjoxNjQsXCJLX1JBTFRcIjoxNjUsXHJcbiAgICAgIFwiS19DT0xPTlwiOjE4NixcIktfRVFVQUxcIjoxODcsXCJLX0NPTU1BXCI6MTg4LFwiS19IWVBIRU5cIjoxODksXHJcbiAgICAgIFwiS19QRVJJT0RcIjoxOTAsXCJLX1NMQVNIXCI6MTkxLFwiS19CS1FVT1RFXCI6MTkyLFxyXG4gICAgICBcIktfTEJSS1RcIjoyMTksXCJLX0JLU0xBU0hcIjoyMjAsXCJLX1JCUktUXCI6MjIxLFxyXG4gICAgICBcIktfUVVPVEVcIjoyMjIsXCJLX29FMlwiOjIyNixcIktfT0UyXCI6MjI2LFxyXG4gICAgICBcIktfTE9QVFwiOjUwMDAxLFwiS19ST1BUXCI6NTAwMDIsXHJcbiAgICAgIFwiS19OVU1FUkFMU1wiOjUwMDAzLFwiS19TWU1CT0xTXCI6NTAwMDQsXCJLX0NVUlJFTkNJRVNcIjo1MDAwNSxcclxuICAgICAgXCJLX1VQUEVSXCI6NTAwMDYsXCJLX0xPV0VSXCI6NTAwMDcsXCJLX0FMUEhBXCI6NTAwMDgsXHJcbiAgICAgIFwiS19TSElGVEVEXCI6NTAwMDksXCJLX0FMVEdSXCI6NTAwMTAsXHJcbiAgICAgIFwiS19UQUJCQUNLXCI6NTAwMTEsXCJLX1RBQkZXRFwiOjUwMDEyXHJcbiAgICB9LFxyXG5cclxuICAgIGNvZGVzVVM6IFtcclxuICAgICAgWycwMTIzNDU2Nzg5JywnOz0sLS4vYCcsICdbXFxcXF1cXCcnXSxcclxuICAgICAgWycpIUAjJCVeJiooJywnOis8Xz4/ficsICd7fH1cIiddXHJcbiAgICBdXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIGNvbS5rZXltYW4udGV4dCB7XHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyB0aGUgY29tbWFuZHMgYW5kIHN0YXRlIGNoYW5nZXMgdGhhdCByZXN1bHQgZnJvbSBhIG1hdGNoZWQga2V5Ym9hcmQgcnVsZS5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUnVsZUJlaGF2aW9yIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJlZm9yZS1hbmQtYWZ0ZXIgVHJhbnNmb3JtIGZyb20gbWF0Y2hpbmcgYSBrZXlib2FyZCBydWxlLiAgTWF5IGJlIGBudWxsYFxyXG4gICAgICogaWYgbm8ga2V5Ym9hcmQgcnVsZXMgd2VyZSBtYXRjaGVkIGZvciB0aGUga2V5c3Ryb2tlLlxyXG4gICAgICovXHJcbiAgICB0cmFuc2NyaXB0aW9uOiBUcmFuc2NyaXB0aW9uID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCBhIEJFRVAgY29tbWFuZCB3YXMgaXNzdWVkIGJ5IHRoZSBtYXRjaGVkIGtleWJvYXJkIHJ1bGUuXHJcbiAgICAgKi9cclxuICAgIGJlZXA/OiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzZXQgb2YgY2hhbmdlZCBzdG9yZSB2YWx1ZXMgdHJpZ2dlcmVkIGJ5IHRoZSBtYXRjaGVkIGtleWJvYXJkIHJ1bGUuXHJcbiAgICAgKi9cclxuICAgIHNldFN0b3JlOiB7W2lkOiBudW1iZXJdOiBzdHJpbmd9ID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNldCBvZiB2YXJpYWJsZSBzdG9yZXMgd2l0aCBzYXZlIHJlcXVlc3RzIHRyaWdnZXJlZCBieSB0aGUgbWF0Y2hlZCBrZXlib2FyZCBydWxlXHJcbiAgICAgKi9cclxuICAgIHNhdmVTdG9yZToge1tuYW1lOiBzdHJpbmddOiBWYXJpYWJsZVN0b3JlfSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVub3RlcyBhIG5vbi1vdXRwdXQgZGVmYXVsdCBiZWhhdmlvcjsgdGhpcyBzaG91bGQgYmUgZXZhbHVhdGVkIGxhdGVyLCBhZ2FpbnN0IHRoZSB0cnVlIGtleXN0cm9rZS5cclxuICAgICAqL1xyXG4gICAgdHJpZ2dlcnNEZWZhdWx0Q29tbWFuZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVub3RlcyBlcnJvciBsb2cgbWVzc2FnZXMgZ2VuZXJhdGVkIHdoZW4gYXR0ZW1wdGluZyB0byBnZW5lcmF0ZSB0aGlzIGJlaGF2aW9yLlxyXG4gICAgICovXHJcbiAgICBlcnJvckxvZz86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbm90ZXMgd2FybmluZyBsb2cgbWVzc2FnZXMgZ2VuZXJhdGVkIHdoZW4gYXR0ZW1wdGluZyB0byBnZW5lcmF0ZSB0aGlzIGJlaGF2aW9yLlxyXG4gICAgICovXHJcbiAgICB3YXJuaW5nTG9nPzogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgcHJlZGljdGl2ZSB0ZXh0IGlzIGFjdGl2ZSwgY29udGFpbnMgYSBQcm9taXNlIHJldHVybmluZyBwcmVkaWN0aXZlIFN1Z2dlc3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBwcmVkaWN0aW9uUHJvbWlzZT86IFByb21pc2U8U3VnZ2VzdGlvbltdPjtcclxuXHJcbiAgICBmaW5hbGl6ZShwcm9jZXNzb3I6IEtleWJvYXJkUHJvY2Vzc29yLCBvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCkge1xyXG4gICAgICBpZighdGhpcy50cmFuc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgXCJDYW5ub3QgZmluYWxpemUgYSBSdWxlQmVoYXZpb3Igd2l0aCBubyB0cmFuc2NyaXB0aW9uLlwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihwcm9jZXNzb3IuYmVlcEhhbmRsZXIgJiYgdGhpcy5iZWVwKSB7XHJcbiAgICAgICAgcHJvY2Vzc29yLmJlZXBIYW5kbGVyKG91dHB1dFRhcmdldCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvcihsZXQgc3RvcmVJRCBpbiB0aGlzLnNldFN0b3JlKSB7XHJcbiAgICAgICAgbGV0IHN5c1N0b3JlID0gcHJvY2Vzc29yLmtleWJvYXJkSW50ZXJmYWNlLnN5c3RlbVN0b3Jlc1tzdG9yZUlEXTtcclxuICAgICAgICBpZihzeXNTdG9yZSkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc3lzU3RvcmUuc2V0KHRoaXMuc2V0U3RvcmVbc3RvcmVJRF0pO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYocHJvY2Vzc29yLmVycm9yTG9nZ2VyKSB7XHJcbiAgICAgICAgICAgICAgcHJvY2Vzc29yLmVycm9yTG9nZ2VyKFwiUnVsZSBhdHRlbXB0ZWQgdG8gcGVyZm9ybSBpbGxlZ2FsIG9wZXJhdGlvbiAtICdwbGF0Zm9ybScgbWF5IG5vdCBiZSBjaGFuZ2VkLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZihwcm9jZXNzb3Iud2FybmluZ0xvZ2dlcikge1xyXG4gICAgICAgICAgcHJvY2Vzc29yLndhcm5pbmdMb2dnZXIoXCJVbmtub3duIHN0b3JlIGFmZmVjdGVkIGJ5IGtleWJvYXJkIHJ1bGU6IFwiICsgc3RvcmVJRCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihwcm9jZXNzb3Iua2V5Ym9hcmRJbnRlcmZhY2UudmFyaWFibGVTdG9yZVNlcmlhbGl6ZXIpIHtcclxuICAgICAgICBmb3IobGV0IHN0b3JlSUQgaW4gdGhpcy5zYXZlU3RvcmUpIHtcclxuICAgICAgICAgIHByb2Nlc3Nvci5rZXlib2FyZEludGVyZmFjZS52YXJpYWJsZVN0b3JlU2VyaWFsaXplci5zYXZlU3RvcmUocHJvY2Vzc29yLmFjdGl2ZUtleWJvYXJkLmlkLCBzdG9yZUlELCB0aGlzLnNhdmVTdG9yZVtzdG9yZUlEXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZih0aGlzLnRyaWdnZXJzRGVmYXVsdENvbW1hbmQpIHtcclxuICAgICAgICBsZXQga2V5RXZlbnQgPSB0aGlzLnRyYW5zY3JpcHRpb24ua2V5c3Ryb2tlO1xyXG4gICAgICAgIERlZmF1bHRPdXRwdXQuYXBwbHlDb21tYW5kKGtleUV2ZW50LCBvdXRwdXRUYXJnZXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihwcm9jZXNzb3Iud2FybmluZ0xvZ2dlciAmJiB0aGlzLndhcm5pbmdMb2cpIHtcclxuICAgICAgICBwcm9jZXNzb3Iud2FybmluZ0xvZ2dlcih0aGlzLndhcm5pbmdMb2cpO1xyXG4gICAgICB9IGVsc2UgaWYocHJvY2Vzc29yLmVycm9yTG9nZ2VyICYmIHRoaXMuZXJyb3JMb2cpIHtcclxuICAgICAgICBwcm9jZXNzb3IuZXJyb3JMb2dnZXIodGhpcy5lcnJvckxvZyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyBFc3RhYmxpc2hlcyBrZXktY29kZSBkZWZpbml0aW9ucy5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cImNvZGVzLnRzXCIgLz5cclxuLy8gRGVmaW5lcyBvdXIgZ2VuZXJhbGl6ZWQgXCJLZXlFdmVudFwiIGNsYXNzLlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwia2V5RXZlbnQudHNcIiAvPlxyXG5cclxubmFtZXNwYWNlIGNvbS5rZXltYW4udGV4dCB7XHJcbiAgZXhwb3J0IGVudW0gRW11bGF0aW9uS2V5c3Ryb2tlcyB7XHJcbiAgICBFbnRlciA9ICdcXG4nLFxyXG4gICAgQmFja3NwYWNlID0gJ1xcYidcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgYSBjb2xsZWN0aW9uIG9mIHN0YXRpYyBsaWJyYXJ5IGZ1bmN0aW9ucyB0aGF0IGRlZmluZSBLZXltYW5XZWIncyBkZWZhdWx0IChpbXBsaWVkKSBrZXlib2FyZCBydWxlIGJlaGF2aW9ycy5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRGVmYXVsdE91dHB1dCB7XHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBjb2RlRm9yRXZlbnQoTGtjOiBLZXlFdmVudCkge1xyXG4gICAgICByZXR1cm4gQ29kZXMua2V5Q29kZXNbTGtjLmtOYW1lXSB8fCBMa2MuTGNvZGU7O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VydmVzIGFzIGEgZGVmYXVsdCBrZXljb2RlIGxvb2t1cCB0YWJsZS4gIFRoaXMgbWF5IGJlIHJlZmVyZW5jZWQgc2FmZWx5IGJ5IG1uZW1vbmljIGhhbmRsaW5nIHdpdGhvdXQgZmVhciBvZiBzaWRlLWVmZmVjdHMuXHJcbiAgICAgKiBBbHNvIHVzZWQgYnkgUHJvY2Vzc29yLmRlZmF1bHRSdWxlQmVoYXZpb3IgdG8gZ2VuZXJhdGUgb3V0cHV0IGFmdGVyIGZpbHRlcmluZyBmb3Igc3BlY2lhbCBjYXNlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBmb3JBbnkoTGtjOiBLZXlFdmVudCwgaXNNbmVtb25pYzogYm9vbGVhbiwgcnVsZUJlaGF2aW9yPzogUnVsZUJlaGF2aW9yKSB7XHJcbiAgICAgIHZhciBjaGFyID0gJyc7XHJcblxyXG4gICAgICAvLyBBIHByZXR0eSBzaW1wbGUgdGFibGUgb2YgbG9va3VwcywgY29ycmVzcG9uZGluZyBWRVJZIGNsb3NlbHkgdG8gdGhlIG9yaWdpbmFsIGRlZmF1bHRLZXlPdXRwdXQuXHJcbiAgICAgIGlmKChjaGFyID0gRGVmYXVsdE91dHB1dC5mb3JTcGVjaWFsRW11bGF0aW9uKExrYywgcnVsZUJlaGF2aW9yKSkgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBjaGFyO1xyXG4gICAgICB9IGVsc2UgaWYoIWlzTW5lbW9uaWMgJiYgKChjaGFyID0gRGVmYXVsdE91dHB1dC5mb3JOdW1wYWRLZXlzKExrYywgcnVsZUJlaGF2aW9yKSkgIT0gbnVsbCkpIHtcclxuICAgICAgICByZXR1cm4gY2hhcjtcclxuICAgICAgfSBlbHNlIGlmKChjaGFyID0gRGVmYXVsdE91dHB1dC5mb3JVbmljb2RlS2V5bmFtZXMoTGtjLCBydWxlQmVoYXZpb3IpKSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoYXI7XHJcbiAgICAgIH0gZWxzZSBpZigoY2hhciA9IERlZmF1bHRPdXRwdXQuZm9yQmFzZUtleXMoTGtjLCBydWxlQmVoYXZpb3IpKSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoYXI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gLy8gRm9yIGhlYWRsZXNzIGFuZCBlbWJlZGRkZWQsIHdlIG1heSB3ZWxsIGFsbG93ICdcXHQnLiAgSXQncyBET00gbW9kZSB0aGF0IGhhcyBvdGhlciB1c2VzLlxyXG4gICAgICAgIC8vIC8vIE5vdCBvcmlnaW5hbGx5IGRlZmluZWQgZm9yIHRleHQgb3V0cHV0IHdpdGhpbiBkZWZhdWx0S2V5T3V0cHV0LlxyXG4gICAgICAgIC8vIC8vIFdlIGNhbid0IGVuYWJsZSBpdCB5ZXQsIGFzIGl0J2xsIGNhdXNlIGhhcmR3YXJlIGtleXN0cm9rZXMgaW4gdGhlIERPTSB0byBvdXRwdXQgJ1xcdCcgcmF0aGVyXHJcbiAgICAgICAgLy8gLy8gdGhhbiByZWx5IG9uIHRoZSBicm93c2VyLWRlZmF1bHQgaGFuZGxpbmcuXHJcbiAgICAgICAgbGV0IGNvZGUgPSBEZWZhdWx0T3V0cHV0LmNvZGVGb3JFdmVudChMa2MpO1xyXG4gICAgICAgIHN3aXRjaChjb2RlKSB7XHJcbiAgICAgICAgLy8gICBjYXNlIENvZGVzLmtleUNvZGVzWydLX1RBQiddOlxyXG4gICAgICAgIC8vICAgY2FzZSBDb2Rlcy5rZXlDb2Rlc1snS19UQUJCQUNLJ106XHJcbiAgICAgICAgLy8gICBjYXNlIENvZGVzLmtleUNvZGVzWydLX1RBQkZXRCddOlxyXG4gICAgICAgIC8vICAgICByZXR1cm4gJ1xcdCc7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogaXNDb21tYW5kIC0gcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIG5vbi10ZXh0IGV2ZW50IHNob3VsZCBiZSB0cmlnZ2VyZWQgYnkgdGhlIGtleXN0cm9rZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpc0NvbW1hbmQoTGtjOiBLZXlFdmVudCk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgY29kZSA9IERlZmF1bHRPdXRwdXQuY29kZUZvckV2ZW50KExrYyk7XHJcblxyXG4gICAgICBzd2l0Y2goY29kZSkge1xyXG4gICAgICAgIC8vIFNob3VsZCB3ZSBldmVyIGltcGxlbWVudCB0aGVtOlxyXG4gICAgICAgIC8vIGNhc2UgQ29kZXMua2V5Q29kZXNbJ0tfTEVGVCddOiAgLy8gd291bGQgbm90IG91dHB1dCB0ZXh0LCBidXQgd291bGQgYWx0ZXIgdGhlIGNhcmV0J3MgcG9zaXRpb24gaW4gdGhlIGNvbnRleHQuXHJcbiAgICAgICAgLy8gY2FzZSBDb2Rlcy5rZXlDb2Rlc1snS19SSUdIVCddOlxyXG4gICAgICAgIC8vICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB3aGVuIGEgUnVsZUJlaGF2aW9yIHJlcHJlc2VudHMgYSBub24tdGV4dCBcImNvbW1hbmRcIiB3aXRoaW4gdGhlIEVuZ2luZS4gIFRoaXMgd2lsbCBnZW5lcmFsbHkgXHJcbiAgICAgKiB0cmlnZ2VyIGV2ZW50cyB0aGF0IHJlcXVpcmUgY29udGV4dCByZXNldCAtIG9mdGVuIGJ5IG1vdmluZyB0aGUgY2FyZXQgb3IgYnkgbW92aW5nIHdoYXQgT3V0cHV0VGFyZ2V0XHJcbiAgICAgKiB0aGUgY2FyZXQgaXMgaW4uICBIb3dldmVyLCB3ZSBsZXQgdGhvc2UgZXZlbnRzIHBlcmZvcm0gdGhlIGFjdHVhbCBjb250ZXh0IHJlc2V0LlxyXG4gICAgICogXHJcbiAgICAgKiBOb3RlOiAgaXMgZXh0ZW5kZWQgYnkgRE9NLWF3YXJlIEtleW1hbldlYiBjb2RlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFwcGx5Q29tbWFuZChMa2M6IEtleUV2ZW50LCBvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCk6IHZvaWQge1xyXG4gICAgICAvLyBOb3RlcyBmb3IgcG90ZW50aWFsIGRlZmF1bHQtaGFuZGxpbmcgZXh0ZW5zaW9uczpcclxuICAgICAgLy8gXHJcbiAgICAgIC8vIHN3aXRjaChjb2RlKSB7XHJcbiAgICAgICAgLy8gLy8gUHJvYmxlbTogIGNsdXN0ZXJzLCBhbmQgZG9pbmcgdGhlbSByaWdodC5cclxuICAgICAgICAvLyAvLyBUaGUgY29tbWVudGVkLW91dCBjb2RlIGJlbG93IHNob3VsZCBiZSBhIGRlY2VudCBzdGFydGluZyBwb2ludCwgYnV0IGNsdXN0ZXJzIG1ha2UgaXQgY29tcGxleC5cclxuICAgICAgICAvLyAvLyBNb3N0bHkgYmFzZWQgb24gcHJlLTEyLjAgY29kZSwgYnV0IHRoZSBnZW5lcmFsIGlkZWEgc2hvdWxkIGJlIHJlbGF0aXZlbHkgY2xlYXIuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBjYXNlIENvZGVzLmtleUNvZGVzWydLX0xFRlQnXTpcclxuICAgICAgICAvLyAgIGlmKHRvdWNoQWxpYXMpIHtcclxuICAgICAgICAvLyAgICAgdmFyIGNhcmV0UG9zID0ga2V5bWFud2ViLmdldFRleHRDYXJldChMZWxlbSk7XHJcbiAgICAgICAgLy8gICAgIGtleW1hbndlYi5zZXRUZXh0Q2FyZXQoTGVsZW0sIGNhcmV0UG9zIC0gMSA+PSAwID8gY2FyZXRQb3MgLSAxIDogMCk7XHJcbiAgICAgICAgLy8gICB9XHJcbiAgICAgICAgLy8gICBicmVhaztcclxuICAgICAgICAvLyBjYXNlIENvZGVzLmtleUNvZGVzWydLX1JJR0hUJ106XHJcbiAgICAgICAgLy8gICBpZih0b3VjaEFsaWFzKSB7XHJcbiAgICAgICAgLy8gICAgIHZhciBjYXJldFBvcyA9IGtleW1hbndlYi5nZXRUZXh0Q2FyZXQoTGVsZW0pO1xyXG4gICAgICAgIC8vICAgICBrZXltYW53ZWIuc2V0VGV4dENhcmV0KExlbGVtLCBjYXJldFBvcyArIDEpO1xyXG4gICAgICAgIC8vICAgfVxyXG4gICAgICAgIC8vICAgaWYoY29kZSA9PSBWaXN1YWxLZXlib2FyZC5rZXlDb2Rlc1snS19SSUdIVCddKSB7XHJcbiAgICAgICAgLy8gICAgIGJyZWFrO1xyXG4gICAgICAgIC8vICAgfVxyXG4gICAgICAvLyB9XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIE5vdGUgdGhhdCB0aGVzZSB3b3VsZCBiZSB1c2VmdWwgZXZlbiBvdXRzaWRlIG9mIGEgRE9NIGNvbnRleHQuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2RlcyBtYXRjaGVkIGhlcmUgZ2VuZXJhbGx5IGhhdmUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbnMgd2hlbiBpbiBhIGJyb3dzZXIgYnV0IHJlcXVpcmUgZW11bGF0aW9uXHJcbiAgICAgKiBmb3IgJ3N5bnRoZXRpYycgYE91dHB1dFRhcmdldGBzIGxpa2UgYE1vY2tgcywgd2hpY2ggaGF2ZSBubyBkZWZhdWx0IHRleHQgaGFuZGxpbmcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZm9yU3BlY2lhbEVtdWxhdGlvbihMa2M6IEtleUV2ZW50LCBydWxlQmVoYXZpb3I/OiBSdWxlQmVoYXZpb3IpOiBFbXVsYXRpb25LZXlzdHJva2VzIHtcclxuICAgICAgbGV0IGNvZGUgPSBEZWZhdWx0T3V0cHV0LmNvZGVGb3JFdmVudChMa2MpO1xyXG5cclxuICAgICAgc3dpdGNoKGNvZGUpIHtcclxuICAgICAgICBjYXNlIENvZGVzLmtleUNvZGVzWydLX0JLU1AnXTpcclxuICAgICAgICAgIHJldHVybiBFbXVsYXRpb25LZXlzdHJva2VzLkJhY2tzcGFjZTtcclxuICAgICAgICBjYXNlIENvZGVzLmtleUNvZGVzWydLX0VOVEVSJ106XHJcbiAgICAgICAgICByZXR1cm4gRW11bGF0aW9uS2V5c3Ryb2tlcy5FbnRlcjtcclxuICAgICAgICAvLyBjYXNlIENvZGVzLmtleUNvZGVzWydLX0RFTCddOlxyXG4gICAgICAgIC8vICAgcmV0dXJuICdcXHUwMDdmJzsgLy8gMTI3LCBBU0NJSSAvIFVuaWNvZGUgY29udHJvbCBjb2RlIGZvciBERUwuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2hvdWxkIG5vdCBiZSB1c2VkIGZvciBtbmVub21pYyBrZXlib2FyZHMuICBmb3JBbnkoKSdzIHVzZSBvZiB0aGlzIG1ldGhvZCBjaGVja3MgZmlyc3QuXHJcbiAgICBwdWJsaWMgc3RhdGljIGZvck51bXBhZEtleXMoTGtjOiBLZXlFdmVudCwgcnVsZUJlaGF2aW9yPzogUnVsZUJlaGF2aW9yKSB7XHJcbiAgICAgIC8vIFRyYW5zbGF0ZSBudW1wYWQga2V5c3Ryb2tlcyBpbnRvIHRoZWlyIG5vbi1udW1wYWQgZXF1aXZhbGVudHNcclxuICAgICAgaWYoTGtjLkxjb2RlID49IENvZGVzLmtleUNvZGVzW1wiS19OUDBcIl0gICYmICBMa2MuTGNvZGUgPD0gQ29kZXMua2V5Q29kZXNbXCJLX05QU0xBU0hcIl0pIHtcclxuICAgICAgICAvLyBOdW1iZXIgcGFkLCBudW1sb2NrIG9uXHJcbiAgICAgICAgaWYoTGtjLkxjb2RlIDwgMTA2KSB7XHJcbiAgICAgICAgICB2YXIgTGNoID0gTGtjLkxjb2RlLTQ4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBMY2ggPSBMa2MuTGNvZGUtNjQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjaCA9IFN0cmluZy5fa213RnJvbUNoYXJDb2RlKExjaCk7IC8vSTMzMTlcclxuICAgICAgICByZXR1cm4gY2g7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUZXN0IGZvciBmYWxsIGJhY2sgdG8gVV94eHh4eHgga2V5IGlkXHJcbiAgICAvLyBGb3IgdGhpcyBmaXJzdCB0ZXN0LCB3ZSBpZ25vcmUgdGhlIGtleUNvZGUgYW5kIHVzZSB0aGUga2V5TmFtZVxyXG4gICAgcHVibGljIHN0YXRpYyBmb3JVbmljb2RlS2V5bmFtZXMoTGtjOiBLZXlFdmVudCwgcnVsZUJlaGF2aW9yPzogUnVsZUJlaGF2aW9yKSB7XHJcbiAgICAgIGxldCBrZXlOYW1lID0gTGtjLmtOYW1lO1xyXG5cclxuICAgICAgLy8gVGVzdCBmb3IgZmFsbCBiYWNrIHRvIFVfeHh4eHh4IGtleSBpZFxyXG4gICAgICAvLyBGb3IgdGhpcyBmaXJzdCB0ZXN0LCB3ZSBpZ25vcmUgdGhlIGtleUNvZGUgYW5kIHVzZSB0aGUga2V5TmFtZVxyXG4gICAgICBpZigha2V5TmFtZSB8fCBrZXlOYW1lLnN1YnN0cigwLDIpICE9ICdVXycpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgXHJcbiAgICAgIHZhciBjb2RlUG9pbnQgPSBwYXJzZUludChrZXlOYW1lLnN1YnN0cigyLDYpLCAxNik7XHJcbiAgICAgIGlmICgoKDB4MCA8PSBjb2RlUG9pbnQpICYmIChjb2RlUG9pbnQgPD0gMHgxRikpIHx8ICgoMHg4MCA8PSBjb2RlUG9pbnQpICYmIChjb2RlUG9pbnQgPD0gMHg5RikpKSB7XHJcbiAgICAgICAgLy8gQ29kZSBwb2ludHMgW1VfMDAwMCAtIFVfMDAxRl0gYW5kIFtVXzAwODAgLSBVXzAwOUZdIHJlZmVyIHRvIFVuaWNvZGUgQzAgYW5kIEMxIGNvbnRyb2wgY29kZXMuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGNvZGVQb2ludCBudW1iZXIgYW5kIGRvIG5vdCBhbGxvdyBvdXRwdXQgb2YgdGhlc2UgY29kZXMgdmlhIFVfeHh4eHh4IHNob3J0Y3V0cy5cclxuICAgICAgICBpZihydWxlQmVoYXZpb3IpIHtcclxuICAgICAgICAgIHJ1bGVCZWhhdmlvci5lcnJvckxvZyA9IChcIlN1cHByZXNzaW5nIFVuaWNvZGUgY29udHJvbCBjb2RlOiBVXzAwXCIgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gU3RyaW5nLmZyb21DaGFyQ29kZSgpIGlzIGluYWRlcXVhdGUgdG8gaGFuZGxlIHRoZSBlbnRpcmUgcmFuZ2Ugb2YgVW5pY29kZVxyXG4gICAgICAgIC8vIFNvbWVkYXkgYWZ0ZXIgdXBncmFkaW5nIHRvIEVTMjAxNSwgY2FuIHVzZSBTdHJpbmcuZnJvbUNvZGVQb2ludCgpXHJcbiAgICAgICAgcmV0dXJuIFN0cmluZy5rbXdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRlc3QgZm9yIG90aGVyd2lzZSB1bmltcGxlbWVudGVkIGtleXMgb24gdGhlIHRoZSBiYXNlIGRlZmF1bHQgJiBzaGlmdCBsYXllcnMuXHJcbiAgICAvLyBUaG9zZSBrZXlzIG11c3QgYmUgYmxvY2tlZCBieSBrZXlib2FyZCBydWxlcyBpZiBpbnRlbnRpb25hbGx5IHVuaW1wbGVtZW50ZWQ7IG90aGVyd2lzZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHRyaWdnZXIuXHJcbiAgICBwdWJsaWMgc3RhdGljIGZvckJhc2VLZXlzKExrYzogS2V5RXZlbnQsIHJ1bGVCZWhhdmlvcj86IFJ1bGVCZWhhdmlvcikge1xyXG4gICAgICBsZXQgbiA9IExrYy5MY29kZTtcclxuICAgICAgbGV0IGtleVNoaWZ0U3RhdGUgPSBMa2MuTG1vZGlmaWVycztcclxuXHJcbiAgICAgIC8vIGNoZWNrIGlmIGV4YWN0IG1hdGNoIHRvIFNISUZUJ3MgY29kZS4gIE9ubHkgdGhlICdkZWZhdWx0JyBhbmQgJ3NoaWZ0JyBsYXllcnMgc2hvdWxkIGhhdmUgZGVmYXVsdCBrZXkgb3V0cHV0cy5cclxuICAgICAgLy8gVE9ETzogIEV4dGVuZCB0byBhbGxvdyBBbHRHciBhcyB3ZWxsIC0gYmV0dGVyIG1uZW1vbmljIHN1cHBvcnQuXHJcbiAgICAgIGlmKGtleVNoaWZ0U3RhdGUgPT0gQ29kZXMubW9kaWZpZXJDb2Rlc1snU0hJRlQnXSkge1xyXG4gICAgICAgIGtleVNoaWZ0U3RhdGUgPSAxO1xyXG4gICAgICB9IGVsc2UgaWYoa2V5U2hpZnRTdGF0ZSAhPSAwKSB7XHJcbiAgICAgICAgaWYocnVsZUJlaGF2aW9yKSB7XHJcbiAgICAgICAgICBydWxlQmVoYXZpb3Iud2FybmluZ0xvZyA9IFwiS01XIG9ubHkgZGVmaW5lcyBkZWZhdWx0IGtleSBvdXRwdXQgZm9yIHRoZSAnZGVmYXVsdCcgYW5kICdzaGlmdCcgbGF5ZXJzIVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm93IHRoYXQga2V5U2hpZnRTdGF0ZSBpcyBlaXRoZXIgMCBvciAxLCB3ZSBjYW4gdXNlIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlIHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBvdXRwdXQuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYobiA9PSBDb2Rlcy5rZXlDb2Rlc1snS19TUEFDRSddKSB7XHJcbiAgICAgICAgICByZXR1cm4gJyAnO1xyXG4gICAgICAgIH0gZWxzZSBpZihuID49IENvZGVzLmtleUNvZGVzWydLXzAnXSAmJiBuIDw9IENvZGVzLmtleUNvZGVzWydLXzknXSkgeyAvLyBUaGUgbnVtYmVyIGtleXMuXHJcbiAgICAgICAgICByZXR1cm4gQ29kZXMuY29kZXNVU1trZXlTaGlmdFN0YXRlXVswXVtuLUNvZGVzLmtleUNvZGVzWydLXzAnXV07XHJcbiAgICAgICAgfSBlbHNlIGlmKG4gPj0gQ29kZXMua2V5Q29kZXNbJ0tfQSddICYmIG4gPD0gQ29kZXMua2V5Q29kZXNbJ0tfWiddKSB7IC8vIFRoZSBiYXNlIGxldHRlciBrZXlzXHJcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuKyhrZXlTaGlmdFN0YXRlPzA6MzIpKTsgIC8vIDMyIGlzIHRoZSBvZmZzZXQgZnJvbSB1cHBlcmNhc2UgdG8gbG93ZXJjYXNlLlxyXG4gICAgICAgIH0gZWxzZSBpZihuID49IENvZGVzLmtleUNvZGVzWydLX0NPTE9OJ10gJiYgbiA8PSBDb2Rlcy5rZXlDb2Rlc1snS19CS1FVT1RFJ10pIHtcclxuICAgICAgICAgIHJldHVybiBDb2Rlcy5jb2Rlc1VTW2tleVNoaWZ0U3RhdGVdWzFdW24tQ29kZXMua2V5Q29kZXNbJ0tfQ09MT04nXV07XHJcbiAgICAgICAgfSBlbHNlIGlmKG4gPj0gQ29kZXMua2V5Q29kZXNbJ0tfTEJSS1QnXSAmJiBuIDw9IENvZGVzLmtleUNvZGVzWydLX1FVT1RFJ10pIHtcclxuICAgICAgICAgIHJldHVybiBDb2Rlcy5jb2Rlc1VTW2tleVNoaWZ0U3RhdGVdWzJdW24tQ29kZXMua2V5Q29kZXNbJ0tfTEJSS1QnXV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYocnVsZUJlaGF2aW9yKSB7XHJcbiAgICAgICAgICBydWxlQmVoYXZpb3IuZXJyb3JMb2cgPSBcIkVycm9yIGRldGVjdGVkIHdpdGggZGVmYXVsdCBtYXBwaW5nIGZvciBrZXk6ICBjb2RlID0gXCIgKyBuICsgXCIsIHNoaWZ0IHN0YXRlID0gXCIgKyAoa2V5U2hpZnRTdGF0ZSA9PSAxID8gJ3NoaWZ0JyA6ICdkZWZhdWx0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiLyoqKlxyXG4gICBLZXltYW5XZWIgMTAuMFxyXG4gICBDb3B5cmlnaHQgMjAxNyBTSUwgSW50ZXJuYXRpb25hbFxyXG4qKiovXHJcblxyXG4vLyBSZWxpZXMgb24gd2ViLXV0aWxzIGZvciB2ZXJzaW9uIGFuZCBkZWVwLWNvcHkgZnVuY3Rpb25hbGl0eS5cclxuXHJcbm5hbWVzcGFjZSBjb20ua2V5bWFuLmtleWJvYXJkcyB7XHJcbiAgbGV0IENvZGVzID0gY29tLmtleW1hbi50ZXh0LkNvZGVzO1xyXG5cclxuICBleHBvcnQgdHlwZSBLTFMgPSB7W2xheWVyTmFtZTogc3RyaW5nXTogc3RyaW5nW119O1xyXG5cclxuICAvLyBUaGUgZm9sbG93aW5nIHR5cGVzIHByb3ZpZGUgdHlwZSBkZWZpbml0aW9ucyBmb3IgdGhlIGZ1bGwgSlNPTiBmb3JtYXQgd2UgdXNlIGZvciB2aXN1YWwga2V5Ym9hcmQgZGVmaW5pdGlvbnMuXHJcbiAgZXhwb3J0IHR5cGUgQnV0dG9uQ2xhc3MgPSBudW1iZXJ8XCIwXCJ8XCIxXCJ8XCIyXCJ8XCIzXCJ8XCI0XCJ8XCI1XCJ8XCI2XCJ8XCI3XCJ8XCI4XCJ8XCI5XCJ8XCIxMFwiXHJcblxyXG4gIGV4cG9ydCB0eXBlIExheW91dEtleSA9IHtcclxuICAgIFwiaWRcIj86IHN0cmluZyxcclxuICAgIFwidGV4dFwiPzogc3RyaW5nLFxyXG4gICAgXCJzcFwiPzogQnV0dG9uQ2xhc3MsXHJcbiAgICBcIndpZHRoXCI/OiBzdHJpbmcsXHJcbiAgICBcImxheWVyXCI/OiBzdHJpbmcsIC8vIEtleSBkZXJpdmVzIGFueSBtb2RpZmllcnMgZnJvbSB0aGUgdmFsdWUgc2V0IGhlcmUgaWYgc3BlY2lmaWVkLCBub3QgdGhlIGFjdHVhbCBkaXNwbGF5IGxheWVyLlxyXG4gICAgXCJuZXh0bGF5ZXJcIj86IHN0cmluZyxcclxuICAgIFwicGFkXCI/OiBzdHJpbmcsXHJcbiAgICBcInNrXCI/OiBMYXlvdXRLZXlbXVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IHR5cGUgTGF5b3V0Um93ID0ge1xyXG4gICAgXCJpZFwiOiBzdHJpbmcsIC8vIHJlcHJlc2VudHMgYSBudW1iZXIsIHRob3VnaC4uLlxyXG4gICAgXCJrZXlcIjogTGF5b3V0S2V5W11cclxuICB9O1xyXG5cclxuICBleHBvcnQgdHlwZSBMYXlvdXRMYXllciA9IHtcclxuICAgIFwiaWRcIjogc3RyaW5nLFxyXG4gICAgXCJyb3dcIjogTGF5b3V0Um93W10sXHJcblxyXG4gICAgLy8gUG9zdC1wcm9jZXNzaW5nIGVsZW1lbnRzLlxyXG4gICAgc2hpZnRLZXk/OiBMYXlvdXRLZXksXHJcbiAgICBjYXBzS2V5PzogTGF5b3V0S2V5LFxyXG4gICAgbnVtS2V5PzogTGF5b3V0S2V5LFxyXG4gICAgc2Nyb2xsS2V5PzogTGF5b3V0S2V5LFxyXG4gICAgYWxpZ25lZD86IGJvb2xlYW5cclxuICB9XHJcblxyXG4gIGV4cG9ydCB0eXBlIExheW91dEZvcm1GYWN0b3IgPSB7XHJcbiAgICBcImRpc3BsYXlVbmRlcmx5aW5nXCI/OiBib29sZWFuLFxyXG4gICAgXCJmb250XCI6IHN0cmluZyxcclxuICAgIFwibGF5ZXJcIjogTGF5b3V0TGF5ZXJbXSxcclxuICAgIGlzRGVmYXVsdD86IGJvb2xlYW5cclxuICB9XHJcblxyXG4gIGV4cG9ydCB0eXBlIExheW91dFNwZWMgPSB7XHJcbiAgICBcImRlc2t0b3BcIj86IExheW91dEZvcm1GYWN0b3IsXHJcbiAgICBcInBob25lXCI/OiBMYXlvdXRGb3JtRmFjdG9yLFxyXG4gICAgXCJ0YWJsZXRcIj86IExheW91dEZvcm1GYWN0b3JcclxuICB9XHJcblxyXG4gIC8vIFRoaXMgY2xhc3MgbWFuYWdlcyBkZWZhdWx0IGxheW91dCBjb25zdHJ1Y3Rpb24gZm9yIGNvbnN1bXB0aW9uIGJ5IE9TS3Mgd2l0aG91dCBhIHNwZWNpZmllZCBsYXlvdXQuXHJcbiAgZXhwb3J0IGNsYXNzIExheW91dHMge1xyXG4gICAgc3RhdGljIGRmbHRDb2Rlcz1bXHJcbiAgICAgIFwiS19CS1FVT1RFXCIsXCJLXzFcIixcIktfMlwiLFwiS18zXCIsXCJLXzRcIixcIktfNVwiLFwiS182XCIsXCJLXzdcIixcIktfOFwiLFwiS185XCIsXCJLXzBcIixcclxuICAgICAgXCJLX0hZUEhFTlwiLFwiS19FUVVBTFwiLFwiS18qXCIsXCJLXypcIixcIktfKlwiLFwiS19RXCIsXCJLX1dcIixcIktfRVwiLFwiS19SXCIsXCJLX1RcIixcclxuICAgICAgXCJLX1lcIixcIktfVVwiLFwiS19JXCIsXCJLX09cIixcIktfUFwiLFwiS19MQlJLVFwiLFwiS19SQlJLVFwiLFwiS19CS1NMQVNIXCIsXCJLXypcIixcclxuICAgICAgXCJLXypcIixcIktfKlwiLFwiS19BXCIsXCJLX1NcIixcIktfRFwiLFwiS19GXCIsXCJLX0dcIixcIktfSFwiLFwiS19KXCIsXCJLX0tcIixcIktfTFwiLFxyXG4gICAgICBcIktfQ09MT05cIixcIktfUVVPVEVcIixcIktfKlwiLFwiS18qXCIsXCJLXypcIixcIktfKlwiLFwiS18qXCIsXCJLX29FMlwiLFxyXG4gICAgICBcIktfWlwiLFwiS19YXCIsXCJLX0NcIixcIktfVlwiLFwiS19CXCIsXCJLX05cIixcIktfTVwiLFwiS19DT01NQVwiLFwiS19QRVJJT0RcIixcclxuICAgICAgXCJLX1NMQVNIXCIsXCJLXypcIixcIktfKlwiLFwiS18qXCIsXCJLXypcIixcIktfKlwiLFwiS19TUEFDRVwiXHJcbiAgICBdO1xyXG5cclxuICAgIHN0YXRpYyBkZmx0VGV4dD0nYDEyMzQ1Njc4OTAtPVxceEE3fn5xd2VydHl1aW9wW11cXFxcfn5+YXNkZmdoamtsO1xcJ35+fn5+P3p4Y3Zibm0sLi9+fn5+fiAnXHJcbiAgICAgICsnfiFAIyQlXiYqKClfK1xceEE3fn5RV0VSVFlVSU9Qe31cXFxcfn5+QVNERkdISktMOlwifn5+fn4/WlhDVkJOTTw+P35+fn5+ICc7XHJcblxyXG4gICAgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfUkFXX1NQRUMgPSB7J0YnOidUYWhvbWEnLCAnQksnOiBMYXlvdXRzLmRmbHRUZXh0fTtcclxuXHJcbiAgICAvLyBDcm9zcy1yZWZlcmVuY2Ugd2l0aCB0aGUgaWRzIGluIG9zay5zZXRCdXR0b25DbGFzcy5cclxuICAgIHN0YXRpYyBidXR0b25DbGFzc2VzOiB7W25hbWU6IHN0cmluZ106IEJ1dHRvbkNsYXNzfSA9IHtcclxuICAgICAgJ0RFRkFVTFQnOicwJyxcclxuICAgICAgJ1NISUZUJzonMScsXHJcbiAgICAgICdTSElGVC1PTic6JzInLFxyXG4gICAgICAnU1BFQ0lBTCc6JzMnLFxyXG4gICAgICAnU1BFQ0lBTC1PTic6JzQnLFxyXG4gICAgICAnREVBREtFWSc6JzgnLFxyXG4gICAgICAnQkxBTksnOic5JyxcclxuICAgICAgJ0hJRERFTic6JzEwJ1xyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgbW9kaWZpZXJTcGVjaWFscyA9IHtcclxuICAgICAgJ2xlZnRhbHQnOiAnKkxBbHQqJyxcclxuICAgICAgJ3JpZ2h0YWx0JzogJypSQWx0KicsXHJcbiAgICAgICdhbHQnOiAnKkFsdConLFxyXG4gICAgICAnbGVmdGN0cmwnOiAnKkxDdHJsKicsXHJcbiAgICAgICdyaWdodGN0cmwnOiAnKlJDdHJsKicsXHJcbiAgICAgICdjdHJsJzogJypDdHJsKicsXHJcbiAgICAgICdjdHJsLWFsdCc6ICcqQWx0R3IqJyxcclxuICAgICAgJ2xlZnRjdHJsLWxlZnRhbHQnOiAnKkxBbHRDdHJsKicsXHJcbiAgICAgICdyaWdodGN0cmwtcmlnaHRhbHQnOiAnKlJBbHRDdHJsKicsXHJcbiAgICAgICdsZWZ0Y3RybC1sZWZ0YWx0LXNoaWZ0JzogJypMQWx0Q3RybFNoaWZ0KicsXHJcbiAgICAgICdyaWdodGN0cmwtcmlnaHRhbHQtc2hpZnQnOiAnKlJBbHRDdHJsU2hpZnQqJyxcclxuICAgICAgJ3NoaWZ0JzogJypTaGlmdConLFxyXG4gICAgICAnc2hpZnQtYWx0JzogJypBbHRTaGlmdConLFxyXG4gICAgICAnc2hpZnQtY3RybCc6ICcqQ3RybFNoaWZ0KicsXHJcbiAgICAgICdzaGlmdC1jdHJsLWFsdCc6ICcqQWx0Q3RybFNoaWZ0KicsXHJcbiAgICAgICdsZWZ0YWx0LXNoaWZ0JzogJypMQWx0U2hpZnQqJyxcclxuICAgICAgJ3JpZ2h0YWx0LXNoaWZ0JzogJypSQWx0U2hpZnQqJyxcclxuICAgICAgJ2xlZnRjdHJsLXNoaWZ0JzogJypMQ3RybFNoaWZ0KicsXHJcbiAgICAgICdyaWdodGN0cmwtc2hpZnQnOiAnKlJDdHJsU2hpZnQqJ1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogQnVpbGQgYSBkZWZhdWx0IGxheW91dCBmb3Iga2V5Ym9hcmRzIHdpdGggbm8gZXhwbGljaXQgbGF5b3V0XHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSAgIHtPYmplY3R9ICBQVksgICAgICAgICByYXcgc3BlY2lmaWNhdGlvbnNcclxuICAgICogQHBhcmFtICAge0tleWJvYXJkfSBrZXlib2FyZCAgIGtleWJvYXJkIG9iamVjdCAoYXMgbG9hZGVkKVxyXG4gICAgKiBAcGFyYW0gICB7c3RyaW5nfSBmb3JtRmFjdG9yICAgKHJlYWxseSB1dGlscy5Gb3JtRmFjdG9yKVxyXG4gICAgKiBAcmV0dXJuICB7TGF5b3V0Rm9ybUZhY3Rvcn1cclxuICAgICovXHJcbiAgICBzdGF0aWMgYnVpbGREZWZhdWx0TGF5b3V0KFBWSywga2V5Ym9hcmQ6IEtleWJvYXJkLCBmb3JtRmFjdG9yOiBzdHJpbmcpOiBMYXlvdXRGb3JtRmFjdG9yIHtcclxuICAgICAgLy8gQnVpbGQgYSBsYXlvdXQgdXNpbmcgdGhlIGRlZmF1bHQgZm9yIHRoZSBkZXZpY2VcclxuICAgICAgdmFyIGxheW91dFR5cGU9Zm9ybUZhY3RvcjtcclxuXHJcbiAgICAgIGlmKHR5cGVvZiBMYXlvdXRzLmRmbHRMYXlvdXRbbGF5b3V0VHlwZV0gIT0gJ29iamVjdCcpIHtcclxuICAgICAgICBsYXlvdXRUeXBlID0gJ2Rlc2t0b3AnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQga2JkQml0bWFzayA9IENvZGVzLm1vZGlmaWVyQml0bWFza3NbJ05PTl9DSElSQUwnXTtcclxuICAgICAgLy8gQW4gdW5mb3J0dW5hdGUgZGVwZW5kZW5jeSB0aGVyZS4gIFNob3VsZCBwcm9iYWJseSBhbHNvIHNldCBhIHZlcnNpb24gd2l0aGluIHdlYi1jb3JlIGZvciB1c2UuXHJcbiAgICAgIGxldCBrYmREZXZWZXJzaW9uID0gdXRpbHMuVmVyc2lvbi5DVVJSRU5UO1xyXG4gICAgICBpZihrZXlib2FyZCkge1xyXG4gICAgICAgIGtiZEJpdG1hc2sgPSBrZXlib2FyZC5tb2RpZmllckJpdG1hc2s7XHJcbiAgICAgICAga2JkRGV2VmVyc2lvbiA9IGtleWJvYXJkLmNvbXBpbGVyVmVyc2lvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoIVBWSykge1xyXG4gICAgICAgIFBWSyA9IHRoaXMuREVGQVVMVF9SQVdfU1BFQztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xvbmUgdGhlIGRlZmF1bHQgbGF5b3V0IG9iamVjdCBmb3IgdGhpcyBkZXZpY2VcclxuICAgICAgdmFyIGxheW91dDogTGF5b3V0Rm9ybUZhY3RvciA9IHV0aWxzLmRlZXBDb3B5KExheW91dHMuZGZsdExheW91dFtsYXlvdXRUeXBlXSk7XHJcblxyXG4gICAgICB2YXIgbixsYXllcnM9bGF5b3V0WydsYXllciddLCBrZXlMYWJlbHM6IEtMUz1QVktbJ0tMUyddLCBrZXkxMDI9UFZLWydLMTAyJ107XHJcbiAgICAgIHZhciBpLCBqLCBrLCBtLCByb3csIHJvd3M6IExheW91dFJvd1tdLCBrZXk6IExheW91dEtleSwga2V5czogTGF5b3V0S2V5W107XHJcbiAgICAgIHZhciBjaGlyYWw6IGJvb2xlYW4gPSAoa2JkQml0bWFzayAmIENvZGVzLm1vZGlmaWVyQml0bWFza3MuSVNfQ0hJUkFMKSAhPSAwO1xyXG5cclxuICAgICAgdmFyIGttdzEwUGx1cyA9ICEodHlwZW9mIGtleUxhYmVscyA9PSAndW5kZWZpbmVkJyB8fCAha2V5TGFiZWxzKTtcclxuICAgICAgaWYoIWttdzEwUGx1cykge1xyXG4gICAgICAgIC8vIFNhdmUgdGhlIHByb2Nlc3NlZCBrZXkgbGFiZWwgaW5mb3JtYXRpb24gdG8gdGhlIGtleWJvYXJkJ3MgZ2VuZXJhbCBkYXRhLlxyXG4gICAgICAgIC8vIE1ha2VzIHRoaW5ncyBtb3JlIGVmZmljaWVudCBlbHNld2hlcmUgYW5kIGZvciByZWxvYWRpbmcgYWZ0ZXIga2V5Ym9hcmQgc3dhcHMuXHJcbiAgICAgICAga2V5TGFiZWxzID0gUFZLWydLTFMnXSA9IExheW91dHMucHJvY2Vzc0xlZ2FjeURlZmluaXRpb25zKFBWS1snQksnXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElkZW50aWZ5IGtleSBsYWJlbHMgKGUuZy4gKlNoaWZ0KikgdGhhdCByZXF1aXJlIHRoZSBzcGVjaWFsIE9TSyBmb250XHJcbiAgICAgIHZhciBzcGVjaWFsTGFiZWw9L1xcKlxcdytcXCovO1xyXG5cclxuICAgICAgLy8gKioqIFN0ZXAgMTogIGluc3RhbnRpYXRlIHRoZSBsYXllciBvYmplY3RzLiAqKipcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgbGlzdCBvZiB2YWxpZCBsYXllcnMsIGVuZm9yY2luZyB0aGF0IHRoZSAnZGVmYXVsdCcgbGF5ZXIgbXVzdCBiZSB0aGUgZmlyc3Qgb25lIHByb2Nlc3NlZC5cclxuICAgICAgdmFyIHZhbGlkSWRMaXN0ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoa2V5TGFiZWxzKSwgaW52YWxpZElkTGlzdCA9IFtdO1xyXG4gICAgICB2YWxpZElkTGlzdC5zcGxpY2UodmFsaWRJZExpc3QuaW5kZXhPZignZGVmYXVsdCcpLCAxKTtcclxuICAgICAgdmFsaWRJZExpc3QgPSBbICdkZWZhdWx0JyBdLmNvbmNhdCh2YWxpZElkTGlzdCk7XHJcblxyXG4gICAgICAvLyBBdXRvbWF0aWMgQWx0R3IgZW11bGF0aW9uIGlmIHRoZSAnbGVmdGN0cmwtbGVmdGFsdCcgbGF5ZXIgaXMgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cclxuICAgICAgaWYoa2V5Ym9hcmQgJiYga2V5Ym9hcmQuZW11bGF0ZXNBbHRHcikge1xyXG4gICAgICAgIC8vIFdlIGluc2VydCBvbmx5IHRoZSBsYXllcnMgdGhhdCBuZWVkIHRvIGJlIGVtdWxhdGVkLlxyXG4gICAgICAgIGlmKCh2YWxpZElkTGlzdC5pbmRleE9mKCdsZWZ0Y3RybC1sZWZ0YWx0JykgPT0gLTEpICYmIHZhbGlkSWRMaXN0LmluZGV4T2YoJ3JpZ2h0YWx0JykgIT0gLTEpIHtcclxuICAgICAgICAgIHZhbGlkSWRMaXN0LnB1c2goJ2xlZnRjdHJsLWxlZnRhbHQnKTtcclxuICAgICAgICAgIGtleUxhYmVsc1snbGVmdGN0cmwtbGVmdGFsdCddID0ga2V5TGFiZWxzWydyaWdodGFsdCddO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoKHZhbGlkSWRMaXN0LmluZGV4T2YoJ2xlZnRjdHJsLWxlZnRhbHQtc2hpZnQnKSA9PSAtMSkgJiYgdmFsaWRJZExpc3QuaW5kZXhPZigncmlnaHRhbHQtc2hpZnQnKSAhPSAtMSkge1xyXG4gICAgICAgICAgdmFsaWRJZExpc3QucHVzaCgnbGVmdGN0cmwtbGVmdGFsdC1zaGlmdCcpO1xyXG4gICAgICAgICAga2V5TGFiZWxzWydsZWZ0Y3RybC1sZWZ0YWx0LXNoaWZ0J10gPSBrZXlMYWJlbHNbJ3JpZ2h0YWx0LXNoaWZ0J107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmVkZWZpbmVkIGxheW91dCwgZXZlbiB0b3VjaCBsYXlvdXRzIHdpbGwgZm9sbG93IHRoZSBkZXNrdG9wJ3NcclxuICAgICAgLy8gc2V0dGluZyBmb3IgdGhlIGRpc3BsYXlVbmRlcmx5aW5nIGZsYWcuICBBcyB0aGUgZGVza3RvcCBsYXlvdXQgdXNlcyBhIGRpZmZlcmVudFxyXG4gICAgICAvLyBmb3JtYXQgZm9yIGl0cyBsYXlvdXQgc3BlYywgdGhhdCdzIGZvdW5kIGF0IHRoZSBmaWVsZCByZWZlcmVuY2VkIGJlbG93LlxyXG4gICAgICBsYXlvdXRbXCJkaXNwbGF5VW5kZXJseWluZ1wiXSA9IGtleWJvYXJkID8gISFrZXlib2FyZC5zY3JpcHRPYmplY3RbJ0tEVSddIDogZmFsc2U7XHJcblxyXG4gICAgICAvLyBGb3IgZGVza3RvcCBkZXZpY2VzLCB3ZSBtdXN0IGNyZWF0ZSBhbGwgbGF5ZXJzLCBldmVuIGlmIGludmFsaWQuXHJcbiAgICAgIGlmKGZvcm1GYWN0b3IgPT0gJ2Rlc2t0b3AnKSB7XHJcbiAgICAgICAgaW52YWxpZElkTGlzdCA9IExheW91dHMuZ2VuZXJhdGVMYXllcklkcyhjaGlyYWwpO1xyXG5cclxuICAgICAgICAvLyBGaWx0ZXIgb3V0IGFsbCBpZHMgY29uc2lkZXJlZCB2YWxpZC4gIChXZSBhbHNvIGRvbid0IHdhbnQgZHVwbGljYXRlcyBpbiB0aGUgZm9sbG93aW5nIGxpc3QuLi4pXHJcbiAgICAgICAgZm9yKG49MDsgbjxpbnZhbGlkSWRMaXN0Lmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICBpZih2YWxpZElkTGlzdC5pbmRleE9mKGludmFsaWRJZExpc3Rbbl0pICE9IC0xKSB7XHJcbiAgICAgICAgICAgIGludmFsaWRJZExpc3Quc3BsaWNlKG4tLSwgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgYWxsICd2YWxpZCcgbGF5ZXJzIGFyZSBhdCB0aGUgZnJvbnQgb2YgdGhlIGxheWVyIGFycmF5IGFuZCBtYW5hZ2VkIGJ5IHRoZSBtYWluIGxvb3AgYmVsb3cuXHJcbiAgICAgIC8vICdpbnZhbGlkJyBsYXllcnMgYXJlbid0IGhhbmRsZWQgYnkgdGhlIGxvb3AgYW5kIHRodXMgcmVtYWluIGJsYW5rIGFmdGVyIGl0LlxyXG4gICAgICB2YXIgaWRMaXN0ID0gdmFsaWRJZExpc3QuY29uY2F0KGludmFsaWRJZExpc3QpO1xyXG5cclxuICAgICAgaWYoa213MTBQbHVzICYmIGZvcm1GYWN0b3IgIT0gJ2Rlc2t0b3AnKSB7IC8vIEtMUyBleGlzdHMsIHNvIHdlIGtub3cgdGhlIGV4YWN0IGxheWVyIHNldC5cclxuICAgICAgICAvLyBGaW5kIHRoZSBTSElGVCBrZXkuLi5cclxuICAgICAgICB2YXIgc2hpZnRLZXk6IExheW91dEtleSA9IG51bGw7XHJcblxyXG4gICAgICAgIHJvd3MgPSBsYXllcnNbMF1bJ3JvdyddO1xyXG4gICAgICAgIGZvcih2YXIgcj0wOyByIDwgcm93cy5sZW5ndGg7IHIrKykge1xyXG4gICAgICAgICAga2V5cyA9IHJvd3Nbcl1bJ2tleSddO1xyXG4gICAgICAgICAgZm9yKHZhciBjPTA7IGMgPCBrZXlzLmxlbmd0aDsgYysrKSB7XHJcbiAgICAgICAgICAgIGtleSA9IGtleXNbY107XHJcbiAgICAgICAgICAgIGlmKGtleVsnaWQnXSA9PSAnS19TSElGVCcpIHtcclxuICAgICAgICAgICAgICBzaGlmdEtleSA9IGtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoc2hpZnRLZXkpIHtcclxuICAgICAgICAgIC8vIEVyYXNlIHRoZSBsZWdhY3kgc2hpZnRlZCBzdWJrZXkgYXJyYXkuXHJcbiAgICAgICAgICBzaGlmdEtleVsnc2snXSA9IFtdO1xyXG5cclxuICAgICAgICAgIGZvcih2YXIgbGF5ZXJJRCBpbiBrZXlMYWJlbHMpIHtcclxuICAgICAgICAgICAgaWYobGF5ZXJJRCA9PSAnZGVmYXVsdCcgfHwgbGF5ZXJJRCA9PSAnc2hpZnQnKSB7XHJcbiAgICAgICAgICAgICAgLy8gVGhlc2UgdHdvIGFyZSBhY2Nlc3NpYmxlIGZyb20gdGhlIGxheWVyIHdpdGhvdXQgc3Via2V5cy5cclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHN1YmtleSBmb3IgdGhlIHNwZWNpZmllZCBsYXllciBzbyB0aGF0IGl0IHdpbGwgYmUgYWNjZXNzaWJsZSB2aWEgT1NLLlxyXG4gICAgICAgICAgICB2YXIgc3BlY2lhbENoYXIgPSBMYXlvdXRzLm1vZGlmaWVyU3BlY2lhbHNbbGF5ZXJJRF07XHJcbiAgICAgICAgICAgIGxldCBzdWJrZXk6IExheW91dEtleSA9IHtcclxuICAgICAgICAgICAgICBpZDogXCJLX1wiICsgc3BlY2lhbENoYXIsXHJcbiAgICAgICAgICAgICAgdGV4dDogc3BlY2lhbENoYXIsXHJcbiAgICAgICAgICAgICAgc3A6IFwiMVwiLFxyXG4gICAgICAgICAgICAgIG5leHRsYXllcjogbGF5ZXJJRFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNoaWZ0S2V5WydzayddLnB1c2goc3Via2V5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gU2VyaW91c2x5LCB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4uICBJdCdzIGhlcmUgZm9yIHRoZSBkZWJ1Z2dpbmcgbG9nIG9ubHkuXHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBpbiBkZWZhdWx0IGxheW91dCAtIGNhbm5vdCBmaW5kIGRlZmF1bHQgU2hpZnQga2V5IVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvcihuPTA7IG48aWRMaXN0Lmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgLy8gUG9wdWxhdGUgbm9uLWRlZmF1bHQgKHNoaWZ0ZWQpIGtleWdyb3Vwc1xyXG4gICAgICAgIGlmKG4gPiAwKSB7XHJcbiAgICAgICAgICBsYXllcnNbbl09dXRpbHMuZGVlcENvcHkobGF5ZXJzWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGF5ZXJzW25dWydpZCddPWlkTGlzdFtuXTtcclxuICAgICAgICBsYXllcnNbbl1bJ25leHRsYXllciddPWlkTGlzdFtuXTsgLy8gVGhpcyB3b3VsZCBvbmx5IGJlIGRpZmZlcmVudCBmb3IgYSBkeW5hbWljIGtleWJvYXJkXHJcblxyXG4gICAgICAgIC8vIEV4dHJhY2VkIGludG8gYSBoZWxwZXIgbWV0aG9kIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkuXHJcbiAgICAgICAgTGF5b3V0cy5mb3JtYXREZWZhdWx0TGF5ZXIobGF5ZXJzW25dLCBjaGlyYWwsIGZvcm1GYWN0b3IsICEha2V5MTAyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gKioqIFN0ZXAgMjogTGF5ZXIgb2JqZWN0cyBub3cgZXhpc3Q7IHRpbWUgdG8gZmlsbCB0aGVtIHdpdGggdGhlIGFwcHJvcHJpYXRlIGtleSBsYWJlbHMgYW5kIGtleSBzdHlsZXMgKioqXHJcbiAgICAgIGZvcihuPTA7IG48bGF5ZXJzLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgdmFyIGxheWVyPWxheWVyc1tuXSwga3gsIHNoaWZ0S2V5OiBMYXlvdXRLZXkgPSBudWxsLCBuZXh0S2V5PW51bGwsIGFsbFRleHQ9Jyc7XHJcbiAgICAgICAgdmFyIGNhcHNLZXk6IExheW91dEtleSA9IG51bGwsIG51bUtleTogTGF5b3V0S2V5ID0gbnVsbCwgc2Nyb2xsS2V5OiBMYXlvdXRLZXkgPSBudWxsOyAgLy8gbnVsbCBpZiBub3QgaW4gdGhlIE9TSyBsYXlvdXQuXHJcbiAgICAgICAgdmFyIGxheWVyU3BlYyA9IGtleUxhYmVsc1tsYXllclsnaWQnXV07XHJcbiAgICAgICAgdmFyIGlzU2hpZnQgPSBsYXllclsnaWQnXSA9PSAnc2hpZnQnID8gMSA6IDA7XHJcbiAgICAgICAgdmFyIGlzRGVmYXVsdCA9IGxheWVyWydpZCddID09ICdkZWZhdWx0JyB8fCBpc1NoaWZ0ID8gMSA6IDA7XHJcblxyXG4gICAgICAgIHJvd3M9bGF5ZXJbJ3JvdyddO1xyXG4gICAgICAgIGZvcihpPTA7IGk8cm93cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAga2V5cz1yb3dzW2ldWydrZXknXTtcclxuICAgICAgICAgIGZvcihqPTA7IGo8a2V5cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBrZXk9a2V5c1tqXTtcclxuICAgICAgICAgICAga3g9TGF5b3V0cy5kZmx0Q29kZXMuaW5kZXhPZihrZXlbJ2lkJ10pO1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBjcmVhdGUga2V5cyBmb3IgZGVmaW5lZCBsYXllcnMuICAoJ2RlZmF1bHQnIGFuZCAnc2hpZnQnIGFyZSBhbHdheXMgZGVmaW5lZC4pXHJcbiAgICAgICAgICAgIGlmKGxheWVyU3BlYyB8fCBpc0RlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAvLyBHZXQga2V5Y2FwIHRleHQgZnJvbSB2aXN1YWwga2V5Ym9hcmQgYXJyYXksIGlmIGRlZmluZWQgaW4ga2V5Ym9hcmRcclxuICAgICAgICAgICAgICBpZihsYXllclNwZWMpIHtcclxuICAgICAgICAgICAgICAgIGlmKGt4ID49IDAgJiYga3ggPCBsYXllclNwZWMubGVuZ3RoKSBrZXlbJ3RleHQnXT1sYXllclNwZWNba3hdO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gTGVnYWN5IChwcmUgMTIuMCkgYmVoYXZpb3I6ICBmYWxsIGJhY2sgdG8gVVMgRW5nbGlzaCBrZXljYXAgdGV4dCBhcyBkZWZhdWx0IGZvciB0aGUgYmFzZSB0d28gbGF5ZXJzXHJcbiAgICAgICAgICAgICAgLy8gaWYgYSBrZXkgY2FwIGlzIG5vdCBvdGhlcndpc2UgZGVmaW5lZC4gKEFueSBpbnRlbnRpb25hbCAnZ2hvc3QnIGtleXMgbXVzdCBiZSBleHBsaWNpdGx5IGRlZmluZWQuKVxyXG4gICAgICAgICAgICAgIGlmKGlzRGVmYXVsdCAmJiBrYmREZXZWZXJzaW9uLnByZWNlZGVzKHV0aWxzLlZlcnNpb24uTk9fREVGQVVMVF9LRVlDQVBTKSkge1xyXG4gICAgICAgICAgICAgICAgaWYoa2V5WydpZCddICE9ICdLX1NQQUNFJyAmJiBreCs2NSAqIGlzU2hpZnQgPCBMYXlvdXRzLmRmbHRUZXh0Lmxlbmd0aCAmJiBrZXlbJ3RleHQnXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICBrZXlbJ3RleHQnXSA9IGtleVsndGV4dCddIHx8IExheW91dHMuZGZsdFRleHRba3grNjUqaXNTaGlmdF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMZWF2ZSBhbnkgdW5tYXJrZWQga2V5IGNhcHMgYXMgbnVsbCBzdHJpbmdzXHJcbiAgICAgICAgICAgIGlmKGtleVsndGV4dCddICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAga2V5Wyd0ZXh0J10gPSBrZXlbJ3RleHQnXSB8fCAnJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZWN0IGltcG9ydGFudCB0cmFja2luZyBrZXlzLlxyXG4gICAgICAgICAgICBzd2l0Y2goa2V5WydpZCddKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSBcIktfU0hJRlRcIjpcclxuICAgICAgICAgICAgICAgIHNoaWZ0S2V5PWtleTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgXCJLX1RBQlwiOlxyXG4gICAgICAgICAgICAgICAgbmV4dEtleT1rZXk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlIFwiS19DQVBTXCI6XHJcbiAgICAgICAgICAgICAgICBjYXBzS2V5PWtleTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgXCJLX05VTUxPQ0tcIjpcclxuICAgICAgICAgICAgICAgIG51bUtleT1rZXk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlIFwiS19TQ1JPTExcIjpcclxuICAgICAgICAgICAgICAgIHNjcm9sbEtleT1rZXk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHBvcC11cCBzaGlmdCBrZXlzIHJlZmVyZW5jaW5nIGludmFsaWQgbGF5ZXJzIChCdWlsZCAzNDkpXHJcbiAgICAgICAgICAgIGlmKGtleVsnc2snXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgZm9yKGs9MDsgazxrZXlbJ3NrJ10ubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGlmKHZhbGlkSWRMaXN0LmluZGV4T2Yoa2V5WydzayddW2tdWyduZXh0bGF5ZXInXSkgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAga2V5WydzayddLnNwbGljZShrLS0sIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYoa2V5WydzayddLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBrZXlbJ3NrJ109bnVsbDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGUgbGF5ZXIga2V5cyBpbml0aWFsaXphdGlvbiBwYXNzLiAgVGltZSB0byBkbyBwb3N0LWFuYWx5c2lzIGxheWVyLWxldmVsIGluaXQgd2hlcmUgbmVjZXNzYXJ5LlxyXG4gICAgICAgIGxheWVyLnNoaWZ0S2V5PXNoaWZ0S2V5O1xyXG4gICAgICAgIGxheWVyLmNhcHNLZXk9Y2Fwc0tleTtcclxuICAgICAgICBsYXllci5udW1LZXk9bnVtS2V5O1xyXG4gICAgICAgIGxheWVyLnNjcm9sbEtleT1zY3JvbGxLZXk7XHJcblxyXG4gICAgICAgIC8vIFNldCBtb2RpZmllciBrZXkgYXBwZWFyYW5jZSBhbmQgYmVoYXZpb3VyIGZvciBub24tZGVza3RvcCBkZXZpY2VzIHVzaW5nIHRoZSBkZWZhdWx0IGxheW91dFxyXG4gICAgICAgIGlmKGZvcm1GYWN0b3IgIT0gJ2Rlc2t0b3AnKSB7XHJcbiAgICAgICAgICBpZihuID4gMCAmJiBzaGlmdEtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNoaWZ0S2V5WydzcCddPUxheW91dHMuYnV0dG9uQ2xhc3Nlc1snU0hJRlQtT04nXTtcclxuICAgICAgICAgICAgc2hpZnRLZXlbJ3NrJ109bnVsbDtcclxuICAgICAgICAgICAgc2hpZnRLZXlbJ3RleHQnXSA9IExheW91dHMubW9kaWZpZXJTcGVjaWFsc1tsYXllcnNbbl0uaWRdID8gTGF5b3V0cy5tb2RpZmllclNwZWNpYWxzW2xheWVyc1tuXS5pZF0gOiBcIipTaGlmdCpcIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBsYXlvdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gICAgIGdldExheWVySWRcclxuICAgICAqIFNjb3BlICAgICAgICBQcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBtICAgICBzaGlmdCBtb2RpZmllciBjb2RlXHJcbiAgICAgKiBAcmV0dXJuICAgICAge3N0cmluZ30gICAgICAgICAgICBsYXllciBzdHJpbmcgZnJvbSBzaGlmdCBtb2RpZmllciBjb2RlIChkZXNrdG9wIGtleWJvYXJkcylcclxuICAgICAqIERlc2NyaXB0aW9uICBHZXQgbmFtZSBvZiBsYXllciBmcm9tIGNvZGUsIHdoZXJlIHRoZSBtb2RpZmVyIG9yZGVyIGlzIGRldGVybWluZWQgYnkgYXNjZW5kaW5nIGJpdC1mbGFnIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0TGF5ZXJJZChtOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgbW9kaWZpZXJDb2RlcyA9IENvZGVzLm1vZGlmaWVyQ29kZXM7XHJcblxyXG4gICAgICB2YXIgcz0nJztcclxuICAgICAgaWYobSA9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuICdkZWZhdWx0JztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZihtICYgbW9kaWZpZXJDb2Rlc1snTENUUkwnXSkge1xyXG4gICAgICAgICAgcyA9IChzLmxlbmd0aCA+IDAgPyBzICsgJy0nIDogJycpICsgJ2xlZnRjdHJsJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYobSAmIG1vZGlmaWVyQ29kZXNbJ1JDVFJMJ10pIHtcclxuICAgICAgICAgIHMgPSAocy5sZW5ndGggPiAwID8gcyArICctJyA6ICcnKSArICdyaWdodGN0cmwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihtICYgbW9kaWZpZXJDb2Rlc1snTEFMVCddKSB7XHJcbiAgICAgICAgICBzID0gKHMubGVuZ3RoID4gMCA/IHMgKyAnLScgOiAnJykgKyAnbGVmdGFsdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG0gJiBtb2RpZmllckNvZGVzWydSQUxUJ10pIHtcclxuICAgICAgICAgIHMgPSAocy5sZW5ndGggPiAwID8gcyArICctJyA6ICcnKSArICdyaWdodGFsdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG0gJiBtb2RpZmllckNvZGVzWydTSElGVCddKSB7XHJcbiAgICAgICAgICBzID0gKHMubGVuZ3RoID4gMCA/IHMgKyAnLScgOiAnJykgKyAnc2hpZnQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihtICYgbW9kaWZpZXJDb2Rlc1snQ1RSTCddKSB7XHJcbiAgICAgICAgICBzID0gKHMubGVuZ3RoID4gMCA/IHMgKyAnLScgOiAnJykgKyAnY3RybCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG0gJiBtb2RpZmllckNvZGVzWydBTFQnXSkge1xyXG4gICAgICAgICAgcyA9IChzLmxlbmd0aCA+IDAgPyBzICsgJy0nIDogJycpICsgJ2FsdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBsaXN0IG9mIHBvdGVudGlhbCBsYXllciBpZHMgZm9yIHRoZSBzcGVjaWZpZWQgY2hpcmFsaXR5IG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAgY2hpcmFsICAgIC8vIERvZXMgdGhlIGtleWJvYXJkIHVzZSBjaGlyYWwgbW9kaWZpZXJzIG9yIG5vdD9cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdlbmVyYXRlTGF5ZXJJZHMoY2hpcmFsOiBib29sZWFuKTogc3RyaW5nW10ge1xyXG4gICAgICB2YXIgbGF5ZXJDbnQsIG9mZnNldDtcclxuXHJcbiAgICAgIGlmKGNoaXJhbCkge1xyXG4gICAgICAgIGxheWVyQ250PTMyO1xyXG4gICAgICAgIG9mZnNldD0weDAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxheWVyQ250PTg7XHJcbiAgICAgICAgb2Zmc2V0PTB4MTA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBsYXllcklkcyA9IFtdO1xyXG5cclxuICAgICAgZm9yKHZhciBpPTA7IGkgPCBsYXllckNudDsgaSsrKSB7XHJcbiAgICAgICAgbGF5ZXJJZHMucHVzaChMYXlvdXRzLmdldExheWVySWQoaSAqIG9mZnNldCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbGF5ZXJJZHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgZm9ybWF0dGluZyBwcm9wZXJ0eSBmb3IgdGhlIG1vZGlmaWVyIGtleXMgd2hlbiBjb25zdHJ1Y3RpbmcgYSBkZWZhdWx0IGxheW91dCBmb3IgYSBrZXlib2FyZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgICBsYXllciAgIC8vIE9uZSBsYXllciBzcGVjaWZpY2F0aW9uXHJcbiAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICBjaGlyYWwgIC8vIFdoZXRoZXIgb3Igbm90IHRoZSBrZXlib2FyZCB1c2VzIGNoaXJhbCBtb2RpZmllciBpbmZvcm1hdGlvbi5cclxuICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIGZvcm1GYWN0b3IgIC8vIFRoZSBmb3JtIGZhY3RvciBvZiB0aGUgZGV2aWNlIHRoZSBsYXlvdXQgaXMgYmVpbmcgY29uc3RydWN0ZWQgZm9yLlxyXG4gICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAga2V5MTAyICAgICAgLy8gV2hldGhlciBvciBub3QgdGhlIGV4dGVuZGVkIGtleSAxMDIgc2hvdWxkIGJlIGhpZGRlbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZvcm1hdERlZmF1bHRMYXllcihsYXllcjogTGF5b3V0TGF5ZXIsIGNoaXJhbDogYm9vbGVhbiwgZm9ybUZhY3Rvcjogc3RyaW5nLCBrZXkxMDI6IGJvb2xlYW4pIHtcclxuICAgICAgdmFyIGxheWVySWQgPSBsYXllclsnaWQnXTtcclxuICAgICAgbGV0IGJ1dHRvbkNsYXNzZXMgPSBMYXlvdXRzLmJ1dHRvbkNsYXNzZXM7XHJcblxyXG4gICAgICAvLyBDb3JyZWN0IGFwcGVhcmFuY2Ugb2Ygc3RhdGUtZGVwZW5kZW50IG1vZGlmaWVyIGtleXMgYWNjb3JkaW5nIHRvIGdyb3VwXHJcbiAgICAgIGZvcih2YXIgaT0wOyBpPGxheWVyWydyb3cnXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciByb3c9bGF5ZXJbJ3JvdyddW2ldO1xyXG4gICAgICAgIHZhciBrZXlzPXJvd1sna2V5J107XHJcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8a2V5cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgdmFyIGtleT1rZXlzW2pdO1xyXG4gICAgICAgICAgc3dpdGNoKGtleVsnaWQnXSkge1xyXG4gICAgICAgICAgICBjYXNlICdLX1NISUZUJzpcclxuICAgICAgICAgICAgY2FzZSAnS19MU0hJRlQnOlxyXG4gICAgICAgICAgICBjYXNlICdLX1JTSElGVCc6XHJcbiAgICAgICAgICAgICAgaWYobGF5ZXJJZC5pbmRleE9mKCdzaGlmdCcpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBrZXlbJ3NwJ10gPSBidXR0b25DbGFzc2VzWydTSElGVC1PTiddO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZihmb3JtRmFjdG9yICE9ICdkZXNrdG9wJykge1xyXG4gICAgICAgICAgICAgICAgaWYobGF5ZXJJZCAhPSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgICAgICAga2V5WyduZXh0bGF5ZXInXT0nZGVmYXVsdCc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBrZXlbJ25leHRsYXllciddPSdzaGlmdCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdLX0xDVFJMJzpcclxuICAgICAgICAgICAgY2FzZSAnS19MQ09OVFJPTCc6XHJcbiAgICAgICAgICAgICAgaWYoY2hpcmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpZihsYXllcklkLmluZGV4T2YoJ2xlZnRjdHJsJykgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAga2V5WydzcCddID0gYnV0dG9uQ2xhc3Nlc1snU0hJRlQtT04nXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnS19SQ1RSTCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0tfUkNPTlRST0wnOlxyXG4gICAgICAgICAgICAgIGlmKGNoaXJhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYobGF5ZXJJZC5pbmRleE9mKCdyaWdodGN0cmwnKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICBrZXlbJ3NwJ10gPSBidXR0b25DbGFzc2VzWydTSElGVC1PTiddO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlICdLX0NPTlRST0wnOlxyXG4gICAgICAgICAgICAgIGlmKGxheWVySWQuaW5kZXhPZignY3RybCcpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZighY2hpcmFsIHx8IChsYXllcklkLmluZGV4T2YoJ2xlZnRjdHJsJykgIT0gLTEgJiYgbGF5ZXJJZC5pbmRleE9mKCdyaWdodGN0cmwnKSAhPSAtMSkpIHtcclxuICAgICAgICAgICAgICAgICAga2V5WydzcCddID0gYnV0dG9uQ2xhc3Nlc1snU0hJRlQtT04nXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0tfTEFMVCc6XHJcbiAgICAgICAgICAgICAgaWYoY2hpcmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpZihsYXllcklkLmluZGV4T2YoJ2xlZnRhbHQnKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICBrZXlbJ3NwJ10gPSBidXR0b25DbGFzc2VzWydTSElGVC1PTiddO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlICdLX1JBTFQnOlxyXG4gICAgICAgICAgICAgIGlmKGNoaXJhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYobGF5ZXJJZC5pbmRleE9mKCdyaWdodGFsdCcpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgIGtleVsnc3AnXSA9IGJ1dHRvbkNsYXNzZXNbJ1NISUZULU9OJ107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgJ0tfQUxUJzpcclxuICAgICAgICAgICAgICBpZihsYXllcklkLmluZGV4T2YoJ2FsdCcpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZighY2hpcmFsIHx8IChsYXllcklkLmluZGV4T2YoJ2xlZnRhbHQnKSAhPSAtMSAmJiBsYXllcklkLmluZGV4T2YoJ3JpZ2h0YWx0JykgIT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGtleVsnc3AnXSA9IGJ1dHRvbkNsYXNzZXNbJ1NISUZULU9OJ107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdLX29FMic6XHJcbiAgICAgICAgICAgICAgaWYodHlwZW9mIGtleTEwMiA9PSAndW5kZWZpbmVkJyB8fCAha2V5MTAyKSB7XHJcbiAgICAgICAgICAgICAgICBpZihmb3JtRmFjdG9yID09ICdkZXNrdG9wJykge1xyXG4gICAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShqLS0sIDEpO1xyXG4gICAgICAgICAgICAgICAgICBrZXlzWzBdWyd3aWR0aCddPScyMDAnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAga2V5c1tqXVsnc3AnXT1idXR0b25DbGFzc2VzWydISURERU4nXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgbGVnYWN5IEJLIHByb3BlcnR5IGZyb20gcHJlIDEwLjAgaW50byB0aGUgS0xTIGtleWJvYXJkIGxheWVyIHNwZWMgZm9ybWF0LFxyXG4gICAgICogc3BhcnNpZnlpbmcgaXQgYXMgcG9zc2libGUgdG8gcHJlLWVtcHRpdmVseSBjaGVjayBpbnZhbGlkIGxheWVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICB7QXJyYXl9ICAgQksgICAgICBrZXlib2FyZCBvYmplY3QgKGFzIGxvYWRlZClcclxuICAgICAqIEByZXR1cm4gIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwcm9jZXNzTGVnYWN5RGVmaW5pdGlvbnMoQks6IHN0cmluZ1tdKTogS0xTIHtcclxuICAgICAgLy9bJ2RlZmF1bHQnLCdzaGlmdCcsJ2N0cmwnLCdzaGlmdGN0cmwnLCdhbHQnLCdzaGlmdGFsdCcsJ2N0cmxhbHQnLCdzaGlmdGN0cmxhbHQnXTtcclxuICAgICAgdmFyIGlkTGlzdD1MYXlvdXRzLmdlbmVyYXRlTGF5ZXJJZHMoZmFsc2UpOyAvLyBOb24tY2hpcmFsLlxyXG5cclxuICAgICAgdmFyIEtMUzogS0xTID0ge307XHJcblxyXG4gICAgICAvLyBUaGUgb2xkIGRlZmF1bHQ6ICBlaWdodCBhdXRvLW1hbmFnZWQgbGF5ZXJzLi4uXHJcbiAgICAgIGZvcih2YXIgbj0wOyBuPGlkTGlzdC5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgIHZhciBpZCA9IGlkTGlzdFtuXSwgYXJyID0gW10sIHZhbGlkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIC4uLiB3aXRoIGtleWNvZGUgbWFwcGluZ3MgaW4gYmxvY2tzIG9mIDY1LlxyXG4gICAgICAgIGZvcih2YXIgaz0wOyBrIDwgNjU7IGsrKykge1xyXG4gICAgICAgICAgdmFyIGluZGV4ID0gayArIDY1ICogbjtcclxuICAgICAgICAgIGFyci5wdXNoKEJLW2luZGV4XSk7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIGVudHJ5IGZvciBLX1NQQUNFJ3Mga2V5Y29kZSB0ZW5kcyB0byBob2xkICcgJyBpbnN0ZWFkIG9mICcnLCB3aGljaCBjYXVzZXNcclxuICAgICAgICAgIC8vIHRoZSB3aG9sZSBsYXllciB0byBiZSB0cmVhdGVkIGFzICd2YWxpZCcgaWYgbm90IGluY2x1ZGVkIGluIHRoZSBjb25kaXRpb25hbC5cclxuICAgICAgICAgIGlmKGluZGV4IDwgQksubGVuZ3RoICYmIEJLW2luZGV4XSAhPSAnJyAmJiBrICE9IExheW91dHMuZGZsdENvZGVzLmluZGV4T2YoJ0tfU1BBQ0UnKSkge1xyXG4gICAgICAgICAgICB2YWxpZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih2YWxpZCkge1xyXG4gICAgICAgICAgS0xTW2lkXSA9IGFycjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZXJlIG11c3QgYWx3YXlzIGJlIGF0IGxlYXN0IGEgcGxhaW4gJ2RlZmF1bHQnIGxheWVyLiAgQXJyYXkoNjUpLmZpbGwoJycpIHdvdWxkIGJlIHByZWZlcmFibGUgYnV0IGlzbid0IHN1cHBvcnRlZCBvbiBJRSxcclxuICAgICAgLy8gYnV0IGJ1aWxkRGVmYXVsdExheWVyIHdpbGwgc2V0IHRoZSBkZWZhdWx0cyBmb3IgdGhlc2UgbGF5ZXJzIGlmIG5vIGVudHJ5IGV4aXN0cyBmb3IgdGhlbSBpbiB0aGUgYXJyYXkgZHVlIHRvIGxlbmd0aC5cclxuICAgICAgaWYodHlwZW9mIEtMU1snZGVmYXVsdCddID09ICd1bmRlZmluZWQnIHx8ICEgS0xTWydkZWZhdWx0J10pIHtcclxuICAgICAgICBLTFNbJ2RlZmF1bHQnXSA9IFsnJ107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZXJlIG11c3QgYWx3YXlzIGJlIGF0IGxlYXN0IGEgcGxhaW4gJ3NoaWZ0JyBsYXllci5cclxuICAgICAgaWYodHlwZW9mIEtMU1snc2hpZnQnXSA9PSAndW5kZWZpbmVkJyB8fCAhIEtMU1snc2hpZnQnXSkge1xyXG4gICAgICAgIEtMU1snc2hpZnQnXSA9IFsnJ107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBLTFM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVmaW5lcyB0aGUgZGVmYXVsdCB2aXN1YWwgbGF5b3V0IGZvciBhIGtleWJvYXJkLlxyXG4gICAgc3RhdGljIGRmbHRMYXlvdXQ6IExheW91dFNwZWMgPSB7XHJcbiAgICAgICAgXCJkZXNrdG9wXCI6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBcImZvbnRcIjogXCJUYWhvbWEsSGVsdmV0aWNhXCIsXHJcbiAgICAgICAgICAgIFwibGF5ZXJcIjogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJkZWZhdWx0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJyb3dcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrZXlcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfQktRVU9URVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS18xXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLXzJcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfM1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS180XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLXzVcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfNlwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS183XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLXzhcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfOVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS18wXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0hZUEhFTlwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19FUVVBTFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19CS1NQXCIsIFwidGV4dFwiOiBcIipCa1NwKlwiLCBcInNwXCI6IFwiMVwiLCBcIndpZHRoXCI6IFwiMTMwXCIgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiMlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrZXlcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfVEFCXCIsIFwidGV4dFwiOiBcIipUYWIqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCIxMzBcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfUVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19XXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0VcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfUlwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19UXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1lcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfVVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19JXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX09cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfUFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19MQlJLVFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19SQlJLVFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19CS1NMQVNIXCIgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiM1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrZXlcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfQ0FQU1wiLCBcInRleHRcIjogXCIqQ2FwcypcIiwgXCJzcFwiOiBcIjFcIiwgXCJ3aWR0aFwiOiBcIjE2NVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19BXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1NcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfRFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19GXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0dcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfSFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19KXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0tcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfTFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19DT0xPTlwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19RVU9URVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19FTlRFUlwiLCBcInRleHRcIjogXCIqRW50ZXIqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCIxNjVcIiB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImtleVwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19TSElGVFwiLCBcInRleHRcIjogXCIqU2hpZnQqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCIxMzBcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfb0UyXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1pcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfWFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19DXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1ZcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfQlwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19OXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX01cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfQ09NTUFcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfUEVSSU9EXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1NMQVNIXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1JTSElGVFwiLCBcInRleHRcIjogXCIqU2hpZnQqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCIxMzBcIiB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCI1XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImtleVwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19MQ09OVFJPTFwiLCBcInRleHRcIjogXCIqQ3RybCpcIiwgXCJzcFwiOiBcIjFcIiwgXCJ3aWR0aFwiOiBcIjE3MFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19MQUxUXCIsIFwidGV4dFwiOiBcIipBbHQqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCIxNjBcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfU1BBQ0VcIiwgXCJ0ZXh0XCI6IFwiXCIsIFwid2lkdGhcIjogXCI3NzBcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfUkFMVFwiLCBcInRleHRcIjogXCIqQWx0KlwiLCBcInNwXCI6IFwiMVwiLCBcIndpZHRoXCI6IFwiMTYwXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1JDT05UUk9MXCIsIFwidGV4dFwiOiBcIipDdHJsKlwiLCBcInNwXCI6IFwiMVwiLCBcIndpZHRoXCI6IFwiMTcwXCIgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRhYmxldFwiOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgXCJmb250XCI6IFwiVGFob21hLEhlbHZldGljYVwiLFxyXG4gICAgICAgICAgICBcImxheWVyXCI6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiZGVmYXVsdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicm93XCI6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIjBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwia2V5XCI6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLXzFcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfMlwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS18zXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLXzRcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfNVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS182XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLXzdcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfOFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS185XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLXzBcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfSFlQSEVOXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0VRVUFMXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwic3BcIjogXCIxMFwiLCBcIndpZHRoXCI6IFwiMVwiIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIjFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwia2V5XCI6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1FcIiwgXCJwYWRcIjogXCIyNVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19XXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0VcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfUlwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19UXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1lcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfVVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19JXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX09cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfUFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19MQlJLVFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19SQlJLVFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcInNwXCI6IFwiMTBcIiwgXCJ3aWR0aFwiOiBcIjFcIiB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImtleVwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19BXCIsIFwicGFkXCI6IFwiNTBcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfU1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19EXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0ZcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfR1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19IXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0pcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfS1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19MXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0NPTE9OXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1FVT1RFXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0JLU0xBU0hcIiwgXCJ3aWR0aFwiOiBcIjkwXCIgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiM1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrZXlcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfb0UyXCIsIFwid2lkdGhcIjogXCI5MFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19aXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1hcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfQ1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19WXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0JcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfTlwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19NXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0NPTU1BXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1BFUklPRFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19TTEFTSFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19CS1FVT1RFXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwic3BcIjogXCIxMFwiLCBcIndpZHRoXCI6IFwiMVwiIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIjRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwia2V5XCI6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJLX1NISUZUXCIsIFwidGV4dFwiOiBcIipTaGlmdCpcIiwgXCJzcFwiOiBcIjFcIiwgXCJ3aWR0aFwiOiBcIjIwMFwiLCBcInNrXCI6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfTENPTlRST0xcIiwgXCJ0ZXh0XCI6IFwiKkN0cmwqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCI1MFwiLCBcIm5leHRsYXllclwiOiBcImN0cmxcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19MQ09OVFJPTFwiLCBcInRleHRcIjogXCIqTEN0cmwqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCI1MFwiLCBcIm5leHRsYXllclwiOiBcImxlZnRjdHJsXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfUkNPTlRST0xcIiwgXCJ0ZXh0XCI6IFwiKlJDdHJsKlwiLCBcInNwXCI6IFwiMVwiLCBcIndpZHRoXCI6IFwiNTBcIiwgXCJuZXh0bGF5ZXJcIjogXCJyaWdodGN0cmxcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19MQUxUXCIsIFwidGV4dFwiOiBcIipBbHQqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCI1MFwiLCBcIm5leHRsYXllclwiOiBcImFsdFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0xBTFRcIiwgXCJ0ZXh0XCI6IFwiKkxBbHQqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCI1MFwiLCBcIm5leHRsYXllclwiOiBcImxlZnRhbHRcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19SQUxUXCIsIFwidGV4dFwiOiBcIipSQWx0KlwiLCBcInNwXCI6IFwiMVwiLCBcIndpZHRoXCI6IFwiNTBcIiwgXCJuZXh0bGF5ZXJcIjogXCJyaWdodGFsdFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0FMVEdSXCIsIFwidGV4dFwiOiBcIipBbHRHcipcIiwgXCJzcFwiOiBcIjFcIiwgXCJ3aWR0aFwiOiBcIjUwXCIsIFwibmV4dGxheWVyXCI6IFwiY3RybC1hbHRcIiB9XVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19MT1BUXCIsIFwidGV4dFwiOiBcIipNZW51KlwiLCBcInNwXCI6IFwiMVwiLCBcIndpZHRoXCI6IFwiMTUwXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1NQQUNFXCIsIFwidGV4dFwiOiBcIlwiLCBcIndpZHRoXCI6IFwiNTcwXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0JLU1BcIiwgXCJ0ZXh0XCI6IFwiKkJrU3AqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCIxNTBcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfRU5URVJcIiwgXCJ0ZXh0XCI6IFwiKkVudGVyKlwiLCBcInNwXCI6IFwiMVwiLCBcIndpZHRoXCI6IFwiMjAwXCIgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBob25lXCI6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBcImZvbnRcIjogXCJUYWhvbWEsSGVsdmV0aWNhXCIsXHJcbiAgICAgICAgICAgIFwibGF5ZXJcIjogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJkZWZhdWx0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJyb3dcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrZXlcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfMVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS18yXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLXzNcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfNFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS181XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLXzZcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfN1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS184XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLXzlcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfMFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19IWVBIRU5cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfRVFVQUxcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJzcFwiOiBcIjEwXCIsIFwid2lkdGhcIjogXCIxXCIgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrZXlcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfUVwiLCBcInBhZFwiOiBcIjI1XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1dcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfRVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19SXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1RcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfWVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19VXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0lcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfT1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19QXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0xCUktUXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1JCUktUXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwic3BcIjogXCIxMFwiLCBcIndpZHRoXCI6IFwiMVwiIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIjJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwia2V5XCI6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0FcIiwgXCJwYWRcIjogXCI1MFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19TXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0RcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfRlwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19HXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0hcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfSlwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19LXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0xcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfQ09MT05cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfUVVPVEVcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfQktTTEFTSFwiLCBcIndpZHRoXCI6IFwiOTBcIiB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImtleVwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19vRTJcIiwgXCJ3aWR0aFwiOiBcIjkwXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1pcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfWFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19DXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1ZcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfQlwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19OXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX01cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfQ09NTUFcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfUEVSSU9EXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1NMQVNIXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0JLUVVPVEVcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJzcFwiOiBcIjEwXCIsIFwid2lkdGhcIjogXCIxXCIgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiNFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrZXlcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIktfU0hJRlRcIiwgXCJ0ZXh0XCI6IFwiKlNoaWZ0KlwiLCBcInNwXCI6IFwiMVwiLCBcIndpZHRoXCI6IFwiMjAwXCIsIFwic2tcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19MQ09OVFJPTFwiLCBcInRleHRcIjogXCIqQ3RybCpcIiwgXCJzcFwiOiBcIjFcIiwgXCJ3aWR0aFwiOiBcIjUwXCIsIFwibmV4dGxheWVyXCI6IFwiY3RybFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0xDT05UUk9MXCIsIFwidGV4dFwiOiBcIipMQ3RybCpcIiwgXCJzcFwiOiBcIjFcIiwgXCJ3aWR0aFwiOiBcIjUwXCIsIFwibmV4dGxheWVyXCI6IFwibGVmdGN0cmxcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19SQ09OVFJPTFwiLCBcInRleHRcIjogXCIqUkN0cmwqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCI1MFwiLCBcIm5leHRsYXllclwiOiBcInJpZ2h0Y3RybFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0xBTFRcIiwgXCJ0ZXh0XCI6IFwiKkFsdCpcIiwgXCJzcFwiOiBcIjFcIiwgXCJ3aWR0aFwiOiBcIjUwXCIsIFwibmV4dGxheWVyXCI6IFwiYWx0XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfTEFMVFwiLCBcInRleHRcIjogXCIqTEFsdCpcIiwgXCJzcFwiOiBcIjFcIiwgXCJ3aWR0aFwiOiBcIjUwXCIsIFwibmV4dGxheWVyXCI6IFwibGVmdGFsdFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX1JBTFRcIiwgXCJ0ZXh0XCI6IFwiKlJBbHQqXCIsIFwic3BcIjogXCIxXCIsIFwid2lkdGhcIjogXCI1MFwiLCBcIm5leHRsYXllclwiOiBcInJpZ2h0YWx0XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfQUxUR1JcIiwgXCJ0ZXh0XCI6IFwiKkFsdEdyKlwiLCBcInNwXCI6IFwiMVwiLCBcIndpZHRoXCI6IFwiNTBcIiwgXCJuZXh0bGF5ZXJcIjogXCJjdHJsLWFsdFwiIH1dXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwiaWRcIjogXCJLX0xPUFRcIiwgXCJ0ZXh0XCI6IFwiKk1lbnUqXCIsIFwid2lkdGhcIjogXCIxNTBcIiwgXCJzcFwiOiBcIjFcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfU1BBQ0VcIiwgXCJ3aWR0aFwiOiBcIjU3MFwiLCBcInRleHRcIjogXCJcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJpZFwiOiBcIktfQktTUFwiLCBcInRleHRcIjogXCIqQmtTcCpcIiwgXCJ3aWR0aFwiOiBcIjE1MFwiLCBcInNwXCI6IFwiMVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcImlkXCI6IFwiS19FTlRFUlwiLCBcInRleHRcIjogXCIqRW50ZXIqXCIsIFwid2lkdGhcIjogXCIyMDBcIiwgXCJzcFwiOiBcIjFcIiB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgY29tLmtleW1hbi5rZXlib2FyZHMge1xyXG4gIHR5cGUgS2V5RGlzdHJpYnV0aW9uID0gdGV4dC5LZXlEaXN0cmlidXRpb247XHJcblxyXG5cclxuICBleHBvcnQgY2xhc3MgQWN0aXZlS2V5IGltcGxlbWVudHMgTGF5b3V0S2V5IHtcclxuXHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9QQUQ9MTU7ICAgICAgICAgIC8vIFBhZGRpbmcgdG8gbGVmdCBvZiBrZXksIGluIHZpcnR1YWwgdW5pdHNcclxuICAgIHN0YXRpYyByZWFkb25seSBERUZBVUxUX1JJR0hUX01BUkdJTj0xNTsgLy8gUGFkZGluZyB0byByaWdodCBvZiByaWdodC1tb3N0IGtleSwgaW4gdmlydHVhbCB1bml0c1xyXG4gICAgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfS0VZX1dJRFRIPTEwMDsgICAvLyBXaWR0aCBvZiBhIGtleSwgaWYgbm90IHNwZWNpZmllZCwgaW4gdmlydHVhbCB1bml0c1xyXG5cclxuICAgIC8vIERlZmluZXMga2V5IGRlZmF1bHRzXHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9LRVkgPSB7XHJcbiAgICAgIHRleHQ6ICcnLFxyXG4gICAgICB3aWR0aDogQWN0aXZlS2V5LkRFRkFVTFRfS0VZX1dJRFRILnRvU3RyaW5nKCksXHJcbiAgICAgIHNwOiAnMCcsXHJcbiAgICAgIHBhZDogQWN0aXZlS2V5LkRFRkFVTFRfUEFELnRvU3RyaW5nKClcclxuICAgIH07XHJcblxyXG4gICAgLyoqIFdBUk5JTkcgLSBETyBOT1QgVVNFIERJUkVDVExZIG91dHNpZGUgb2YgQGtleW1hbmFwcC9rZXlib2FyZC1wcm9jZXNzb3IhICovXHJcbiAgICBpZD86IHN0cmluZztcclxuXHJcbiAgICAvLyBUaGVzZSBhcmUgZmluZS5cclxuICAgIHdpZHRoPzogc3RyaW5nO1xyXG4gICAgcGFkPzogc3RyaW5nO1xyXG4gICAgbGF5ZXI6IHN0cmluZztcclxuICAgIGRpc3BsYXlMYXllcjogc3RyaW5nO1xyXG4gICAgbmV4dGxheWVyOiBzdHJpbmc7XHJcblxyXG4gICAgcHJpdmF0ZSBiYXNlS2V5RXZlbnQ6IHRleHQuS2V5RXZlbnQ7XHJcbiAgICBpc01uZW1vbmljOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgcHJvcG9ydGlvbmFsUGFkOiBudW1iZXI7XHJcbiAgICBwcm9wb3J0aW9uYWxYOiBudW1iZXI7XHJcbiAgICBwcm9wb3J0aW9uYWxXaWR0aDogbnVtYmVyO1xyXG5cclxuICAgIHNrPzogQWN0aXZlS2V5W107XHJcblxyXG4gICAgLy8gS2VlcGluZyB0aGluZ3Mgc2ltcGxlIGhlcmUsIGFzIHRoaXMgd2FzIGFkZGVkIExBVEUgaW4gMTQuMCBiZXRhLlxyXG4gICAgLy8gQ291bGQgZGVmaW5pdGVseSBleHRlbmQgaW4gdGhlIGZ1dHVyZSB0byBpbnN0ZWFkIHJldHVybiBhbiBvYmplY3RcclxuICAgIC8vIHRoYXQgZGVub3RlcyB0aGUgJ25hdHVyZScgb2YgdGhlIGtleS5cclxuICAgIC8vIC0gaXNVbmljb2RlXHJcbiAgICAvLyAtIGlzSGFyZHdhcmVLZXlcclxuICAgIC8vIC0gZXRjLlxyXG5cclxuICAgIC8vIFJlZmVyZW5jZSBmb3IgdGhlIHRlcm1pbm9sb2d5IGluIHRoZSBjb21tZW50cyBiZWxvdzpcclxuICAgIC8vIGh0dHBzOi8vaGVscC5rZXltYW4uY29tL2RldmVsb3Blci9jdXJyZW50LXZlcnNpb24vZ3VpZGVzL2RldmVsb3AvY3JlYXRpbmctYS10b3VjaC1rZXlib2FyZC1sYXlvdXQtZm9yLWFtaGFyaWMtdGhlLW5pdHR5LWdyaXR0eVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF0Y2hlcyB0aGUga2V5IGNvZGUgYXMgc2V0IHdpdGhpbiBLZXltYW4gRGV2ZWxvcGVyIGZvciB0aGUgbGF5b3V0LlxyXG4gICAgICogRm9yIGV4YW1wbGUsIEtfUiBvciBVXzAwMjAuICBEZW5vdGVzIGVpdGhlciBwaHlzaWNhbCBrZXlzIG9yIHZpcnR1YWwga2V5cyB3aXRoIGN1c3RvbSBvdXRwdXQsXHJcbiAgICAgKiB3aXRoIG5vIGFkZGl0aW9uYWwgbWV0YWRhdGEgbGlrZSBsYXllciBvciBhY3RpdmUgbW9kaWZpZXJzLlxyXG4gICAgICogXHJcbiAgICAgKiBJcyB1c2VkIHRvIGRldGVybWluZSB0aGUga2V5Y29kZSBmb3IgaW5wdXQgZXZlbnRzLCBydWxlLW1hdGNoaW5nLCBhbmQga2V5c3Ryb2tlIHByb2Nlc3NpbmcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgYmFzZUtleUlEKCk6IHN0cmluZyB7XHJcbiAgICAgIGlmKHR5cGVvZiB0aGlzLmlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSB1bmlxdWUgaWRlbnRpZmllciBiYXNlZCBvbiBib3RoIHRoZSBrZXkgSUQgJiB0aGUgJ2Rlc2t0b3AgbGF5ZXInIHRvIGJlIHVzZWQgZm9yIHRoZSBrZXkuXHJcbiAgICAgKiBcclxuICAgICAqIEFsbG93cyBkaWFtYmlndWF0aW9uIG9mIHNjZW5hcmlvcyB3aGVyZSB0aGUgc2FtZSBrZXkgSUQgaXMgdXNlZCB0d2ljZSB3aXRoaW4gYSBsYXllciwgYnV0XHJcbiAgICAgKiB3aXRoIGRpZmZlcmVudCBpbm5hdGUgbW9kaWZpZXJzLiAgKFJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9rZXltYW5hcHAva2V5bWFuL2lzc3Vlcy80NjE3KVxyXG4gICAgICogVGhlICdkZXNrdG9wIGxheWVyJyBtYXkgYmUgb21pdHRlZCBpZiBpdCBtYXRjaGVzIHRoZSBrZXkncyBkaXNwbGF5IGxheWVyLlxyXG4gICAgICogXHJcbiAgICAgKiBFeGFtcGxlcywgZ2l2ZW4gYSAnZGVmYXVsdCcgZGlzcGxheSBsYXllciwgbWF0Y2hpbmcga2V5cyB0byBLZXltYW4ga2V5Ym9hcmQgbGFuZ3VhZ2U6XHJcbiAgICAgKiBcclxuICAgICAqIGBgYFxyXG4gICAgICogXCJLX1FcIiBcclxuICAgICAqICsgW0tfUV1cclxuICAgICAqIFwiS19RK3NoaWZ0XCJcclxuICAgICAqICsgW0tfUSBTSElGVF1cclxuICAgICAqIGBgYFxyXG4gICAgICogXHJcbiAgICAgKiBVc2VmdWwgd2hlbiB0aGUgYWN0aXZlIGxheWVyIG9mIGFuIGlucHV0LWV2ZW50IGlzIGFscmVhZHkga25vd24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY29yZUlEKCk6IHN0cmluZyB7XHJcbiAgICAgIGlmKHR5cGVvZiB0aGlzLmlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBiYXNlSUQgPSB0aGlzLmlkIHx8ICcnO1xyXG4gICAgICBcclxuICAgICAgaWYodGhpcy5kaXNwbGF5TGF5ZXIgIT0gdGhpcy5sYXllcikge1xyXG4gICAgICAgIGJhc2VJRCA9IGJhc2VJRCArICcrJyArIHRoaXMubGF5ZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBiYXNlSUQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGtleWJvYXJkLXVuaXF1ZSBpZGVudGlmaWVyIHRvIGJlIHVzZWQgZm9yIGFueSBkaXNwbGF5IGVsZW1lbnRzIHJlcHJlc2VudGluZyB0aGlzIGtleVxyXG4gICAgICogaW4gdXNlciBpbnRlcmZhY2VzIGFuZC9vciBvbi1zY3JlZW4ga2V5Ym9hcmRzLlxyXG4gICAgICogXHJcbiAgICAgKiBEaXN0aW5ndWlzaGVzIGJldHdlZW4gb3RoZXJ3aXNlLWlkZW50aWNhbCBrZXlzIG9uIGRpZmZlcmVudCBsYXllcnMgb2YgYW4gT1NLLlxyXG4gICAgICogSW5jbHVkZXMgaWRlbnRpZnlpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGtleSdzIGRpc3BsYXkgbGF5ZXIuXHJcbiAgICAgKiBcclxuICAgICAqIEV4YW1wbGVzLCBnaXZlbiBhICdkZWZhdWx0JyBkaXNwbGF5IGxheWVyLCBtYXRjaGluZyBrZXlzIHRvIEtleW1hbiBrZXlib2FyZCBsYW5ndWFnZTpcclxuICAgICAqIFxyXG4gICAgICogYGBgXHJcbiAgICAgKiBcImRlZmF1bHQtS19RXCIgXHJcbiAgICAgKiArIFtLX1FdXHJcbiAgICAgKiBcImRlZmF1bHQtS19RK3NoaWZ0XCJcclxuICAgICAqICsgW0tfUSBTSElGVF1cclxuICAgICAqIGBgYFxyXG4gICAgICogXHJcbiAgICAgKiBVc2VmdWwgd2hlbiBvbmx5IHRoZSBhY3RpdmUga2V5Ym9hcmQgaXMga25vd24gYWJvdXQgYW4gaW5wdXQgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgZWxlbWVudElEKCk6IHN0cmluZyB7XHJcbiAgICAgIGlmKHR5cGVvZiB0aGlzLmlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlMYXllciArICctJyArIHRoaXMuY29yZUlEO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwb2x5ZmlsbChrZXk6IExheW91dEtleSwgbGF5b3V0OiBBY3RpdmVMYXlvdXQsIGRpc3BsYXlMYXllcjogc3RyaW5nKSB7XHJcbiAgICAgIC8vIEFkZCBjbGFzcyBmdW5jdGlvbnMgdG8gdGhlIGV4aXN0aW5nIGxheW91dCBvYmplY3QsIGFsbG93aW5nIGl0IHRvIGFjdCBhcyBhbiBBY3RpdmVMYXlvdXQuXHJcbiAgICAgIGxldCBkdW1teSA9IG5ldyBBY3RpdmVLZXkoKTtcclxuICAgICAgbGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGR1bW15KTtcclxuXHJcbiAgICAgIGZvcihsZXQgcHJvcCBpbiBkdW1teSkge1xyXG4gICAgICAgIGlmKCFrZXkuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgIGxldCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcCk7XHJcbiAgICAgICAgICBpZihkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgICAgIC8vIEl0J3MgYSBjb21wdXRlZCBwcm9wZXJ0eSEgIENvcHkgdGhlIGRlc2NyaXB0b3Igb250byB0aGUga2V5J3Mgb2JqZWN0LlxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoa2V5LCBwcm9wLCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGtleVtwcm9wXSA9IGR1bW15W3Byb3BdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRW5zdXJlIHN1YmtleXMgYXJlIGFsc28gcHJvcGVybHkgZXh0ZW5kZWQuXHJcbiAgICAgIGlmKGtleS5zaykge1xyXG4gICAgICAgIGZvcihsZXQgc3Via2V5IG9mIGtleS5zaykge1xyXG4gICAgICAgICAgQWN0aXZlS2V5LnBvbHlmaWxsKHN1YmtleSwgbGF5b3V0LCBkaXNwbGF5TGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGFLZXkgPSBrZXkgYXMgQWN0aXZlS2V5O1xyXG4gICAgICBhS2V5LmRpc3BsYXlMYXllciA9IGRpc3BsYXlMYXllcjtcclxuICAgICAgYUtleS5sYXllciA9IGFLZXkubGF5ZXIgfHwgZGlzcGxheUxheWVyO1xyXG5cclxuICAgICAgLy8gQ29tcHV0ZSB0aGUga2V5J3MgYmFzZSBLZXlFdmVudCBwcm9wZXJ0aWVzIGZvciB1c2UgaW4gZnV0dXJlIGV2ZW50IGdlbmVyYXRpb25cclxuICAgICAgYUtleS5jb25zdHJ1Y3RCYXNlS2V5RXZlbnQobGF5b3V0LCBkaXNwbGF5TGF5ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0QmFzZUtleUV2ZW50KGxheW91dDogQWN0aXZlTGF5b3V0LCBkaXNwbGF5TGF5ZXI6IHN0cmluZykge1xyXG4gICAgICAvLyBHZXQga2V5IG5hbWUgYW5kIGtleWJvYXJkIHNoaWZ0IHN0YXRlIChuZWVkZWQgb25seSBmb3IgZGVmYXVsdCBsYXlvdXRzIGFuZCBwaHlzaWNhbCBrZXlib2FyZCBoYW5kbGluZylcclxuICAgICAgLy8gTm90ZSAtIHZpcnR1YWwga2V5cyBzaG91bGQgYmUgdHJlYXRlZCBjYXNlLWluc2Vuc2l0aXZlLCBzbyB3ZSBmb3JjZSB1cHBlcmNhc2luZyBoZXJlLlxyXG4gICAgICBsZXQgbGF5ZXIgPSB0aGlzLmxheWVyIHx8IGRpc3BsYXlMYXllciB8fCAnJztcclxuICAgICAgbGV0IGtleU5hbWU9IHRoaXMuaWQgPyB0aGlzLmlkLnRvVXBwZXJDYXNlKCkgOiBudWxsO1xyXG5cclxuICAgICAgLy8gU3RhcnQ6ICBtaXJyb3JzIF9HZXRLZXlFdmVudFByb3BlcnRpZXNcclxuXHJcbiAgICAgIC8vIE92ZXJyaWRlIGtleSBzaGlmdCBzdGF0ZSBpZiBzcGVjaWZpZWQgZm9yIGtleSBpbiBsYXlvdXQgKGNvcnJlY3RlZCBmb3IgcG9wdXAga2V5cyBLTUVXLTkzKVxyXG4gICAgICBsZXQga2V5U2hpZnRTdGF0ZSA9IHRleHQuS2V5Ym9hcmRQcm9jZXNzb3IuZ2V0TW9kaWZpZXJTdGF0ZShsYXllcik7XHJcblxyXG4gICAgICAvLyBGaXJzdCBjaGVjayB0aGUgdmlydHVhbCBrZXksIGFuZCBwcm9jZXNzIHNoaWZ0LCBjb250cm9sLCBhbHQgb3IgZnVuY3Rpb24ga2V5c1xyXG4gICAgICB2YXIgTGtjOiB0ZXh0LktleUV2ZW50ID0ge1xyXG4gICAgICAgIExtb2RpZmllcnM6IGtleVNoaWZ0U3RhdGUsXHJcbiAgICAgICAgTHN0YXRlczogMCxcclxuICAgICAgICBMY29kZToga2V5TmFtZSA/IHRleHQuQ29kZXMua2V5Q29kZXNba2V5TmFtZV0gOiAwLFxyXG4gICAgICAgIExpc1ZpcnR1YWxLZXk6IHRydWUsXHJcbiAgICAgICAgdmtDb2RlOiAwLFxyXG4gICAgICAgIGtOYW1lOiBrZXlOYW1lLFxyXG4gICAgICAgIGtMYXllcjogbGF5ZXIsXHJcbiAgICAgICAga2JkTGF5ZXI6IGRpc3BsYXlMYXllcixcclxuICAgICAgICBrTmV4dExheWVyOiB0aGlzLm5leHRsYXllcixcclxuICAgICAgICBkZXZpY2U6IG51bGwsXHJcbiAgICAgICAgaXNTeW50aGV0aWM6IHRydWVcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmKGxheW91dC5rZXlib2FyZCkge1xyXG4gICAgICAgIGxldCBrZXlib2FyZCA9IGxheW91dC5rZXlib2FyZDtcclxuXHJcbiAgICAgICAgLy8gSW5jbHVkZSAqbGltaXRlZCogc3VwcG9ydCBmb3IgbW5lbW9uaWMga2V5Ym9hcmRzIChTZXB0IDIwMTIpXHJcbiAgICAgICAgLy8gSWYgYSB0b3VjaCBsYXlvdXQgaGFzIGJlZW4gZGVmaW5lZCBmb3IgYSBtbmVtb25pYyBrZXlvdXQsIGRvIG5vdCBwZXJmb3JtIG1uZW1vbmljIG1hcHBpbmcgZm9yIHJ1bGVzIG9uIHRvdWNoIGRldmljZXMuXHJcbiAgICAgICAgaWYoa2V5Ym9hcmQuaXNNbmVtb25pYyAmJiAhKGxheW91dC5pc0RlZmF1bHQgJiYgbGF5b3V0LmZvcm1GYWN0b3IgIT0gJ2Rlc2t0b3AnKSkge1xyXG4gICAgICAgICAgaWYoTGtjLkxjb2RlICE9IHRleHQuQ29kZXMua2V5Q29kZXNbJ0tfU1BBQ0UnXSkgeyAvLyBleGNlcHRpb24gcmVxdWlyZWQsIE1hcmNoIDIwMTNcclxuICAgICAgICAgICAgLy8gSmFuIDIwMTkgLSBpbnRlcmVzdGluZyB0aGF0ICdLX1NQQUNFJyBhbHNvIGFmZmVjdHMgdGhlIGNhcHMtc3RhdGUgY2hlY2suLi5cclxuICAgICAgICAgICAgTGtjLnZrQ29kZSA9IExrYy5MY29kZTtcclxuICAgICAgICAgICAgdGhpcy5pc01uZW1vbmljID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgTGtjLnZrQ29kZT1Ma2MuTGNvZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdXBwb3J0IHZlcnNpb24gMS4wIEtleW1hbldlYiBrZXlib2FyZHMgdGhhdCBkbyBub3QgZGVmaW5lIHBvc2l0aW9uYWwgdnMgbW5lbW9uaWNcclxuICAgICAgICBpZigha2V5Ym9hcmQuZGVmaW5lc1Bvc2l0aW9uYWxPck1uZW1vbmljKSB7XHJcbiAgICAgICAgICAvLyBOb3QgdGhlIGJlc3QgcGF0dGVybiwgYnV0IGN1cnJlbnRseSBzYWZlIC0gd2UgZG9uJ3QgbG9vayB1cCBhbnkgcHJvcGVydGllcyBvZiBhbnkgb2YgdGhlXHJcbiAgICAgICAgICAvLyBhcmd1bWVudHMgaW4gdGhpcyB1c2UgY2FzZSwgYW5kIHRoZSBvYmplY3QncyBzY29wZSBpcyBleHRyZW1lbHkgbGltaXRlZC5cclxuICAgICAgICAgIExrYy5MY29kZSA9IEtleU1hcHBpbmcuX1VTS2V5Q29kZVRvQ2hhckNvZGUodGhpcy5jb25zdHJ1Y3RLZXlFdmVudChudWxsLCBudWxsKSk7XHJcbiAgICAgICAgICBMa2MuTGlzVmlydHVhbEtleT1mYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuYmFzZUtleUV2ZW50ID0gTGtjO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdEtleUV2ZW50KGtleWJvYXJkUHJvY2Vzc29yOiB0ZXh0LktleWJvYXJkUHJvY2Vzc29yLCBkZXZpY2U6IHV0aWxzLkRldmljZVNwZWMpOiB0ZXh0LktleUV2ZW50IHtcclxuICAgICAgLy8gTWFrZSBhIGRlZXAgY29weSBvZiBvdXIgcHJlY29uc3RydWN0ZWQga2V5IGV2ZW50LCBmaWxsaW5nIGl0IG91dCBmcm9tIHRoZXJlLlxyXG4gICAgICBsZXQgTGtjID0gdXRpbHMuZGVlcENvcHkodGhpcy5iYXNlS2V5RXZlbnQpO1xyXG4gICAgICBMa2MuZGV2aWNlID0gZGV2aWNlO1xyXG5cclxuICAgICAgaWYodGhpcy5pc01uZW1vbmljKSB7XHJcbiAgICAgICAgdGV4dC5LZXlib2FyZFByb2Nlc3Nvci5zZXRNbmVtb25pY0NvZGUoTGtjLCB0aGlzLmxheWVyLmluZGV4T2YoJ3NoaWZ0JykgIT0gLTEsIGtleWJvYXJkUHJvY2Vzc29yID8ga2V5Ym9hcmRQcm9jZXNzb3Iuc3RhdGVLZXlzWydLX0NBUFMnXSA6IGZhbHNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUGVyZm9ybXMgY29tbW9uIHByZS1hbmFseXNpcyBmb3IgYm90aCAnbmF0aXZlJyBhbmQgJ2VtYmVkZGVkJyBPU0sga2V5ICYgc3Via2V5IGlucHV0IGV2ZW50cy5cclxuICAgICAgLy8gVGhpcyBwYXJ0IGRlcGVuZHMgb24gdGhlIGtleWJvYXJkIHByb2Nlc3NvcidzIGFjdGl2ZSBzdGF0ZS5cclxuICAgICAgaWYoa2V5Ym9hcmRQcm9jZXNzb3IpIHtcclxuICAgICAgICBrZXlib2FyZFByb2Nlc3Nvci5zZXRTeW50aGV0aWNFdmVudERlZmF1bHRzKExrYyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBMa2M7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFN1YmtleShjb3JlSUQ6IHN0cmluZyk6IEFjdGl2ZUtleSB7XHJcbiAgICAgIGlmKHRoaXMuc2spIHtcclxuICAgICAgICBmb3IobGV0IGtleSBvZiB0aGlzLnNrKSB7XHJcbiAgICAgICAgICBpZihrZXkuY29yZUlEID09IGNvcmVJRCkge1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjbGFzcyBBY3RpdmVSb3cgaW1wbGVtZW50cyBMYXlvdXRSb3cge1xyXG4gICAgLy8gSWRlbnRpZnkga2V5IGxhYmVscyAoZS5nLiAqU2hpZnQqKSB0aGF0IHJlcXVpcmUgdGhlIHNwZWNpYWwgT1NLIGZvbnRcclxuICAgIHN0YXRpYyByZWFkb25seSBTUEVDSUFMX0xBQkVMPS9cXCpcXHcrXFwqLztcclxuXHJcbiAgICBpZDogc3RyaW5nO1xyXG4gICAga2V5OiBBY3RpdmVLZXlbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIGNhbGN1bGF0aW5nIGZhdC1maW5nZXJpbmcgb2Zmc2V0cy5cclxuICAgICAqL1xyXG4gICAgcHJvcG9ydGlvbmFsWTogbnVtYmVyO1xyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwb2x5ZmlsbChyb3c6IExheW91dFJvdywgbGF5b3V0OiBBY3RpdmVMYXlvdXQsIGRpc3BsYXlMYXllcjogc3RyaW5nLCB0b3RhbFdpZHRoOiBudW1iZXIsIHByb3BvcnRpb25hbFk6IG51bWJlcikge1xyXG4gICAgICAvLyBBcHBseSBkZWZhdWx0cywgc2V0dGluZyB0aGUgd2lkdGggYW5kIG90aGVyIHVuZGVmaW5lZCBwcm9wZXJ0aWVzIGZvciBlYWNoIGtleVxyXG4gICAgICBsZXQga2V5cz1yb3dbJ2tleSddO1xyXG4gICAgICBmb3IobGV0IGo9MDsgajxrZXlzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgbGV0IGtleT1rZXlzW2pdO1xyXG4gICAgICAgIGZvcih2YXIgdHAgaW4gQWN0aXZlS2V5LkRFRkFVTFRfS0VZKSB7XHJcbiAgICAgICAgICBpZih0eXBlb2Yga2V5W3RwXSAhPSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBrZXlbdHBdPUFjdGl2ZUtleS5ERUZBVUxUX0tFWVt0cF07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNb2RpZnkgdGhlIGtleSB0eXBlIGZvciBzcGVjaWFsIGtleXMgd2l0aCBub24tc3RhbmRhcmQgbGFiZWxzXHJcbiAgICAgICAgLy8gdG8gYWxsb3cgdGhlIGtleWJvYXJkIGZvbnQgdG8gb3Z2ZXJpZGUgdGhlIFNwZWNpYWxPU0sgZm9udC5cclxuICAgICAgICAvLyBCbGFuayBrZXlzIGFyZSBubyBsb25nZXIgcmVjbGFzc2VkIC0gY2FuIHVzZSBiZWZvcmUvYWZ0ZXIgQ1NTIHRvIGFkZCB0ZXh0XHJcbiAgICAgICAgc3dpdGNoKGtleVsnc3AnXSkge1xyXG4gICAgICAgICAgY2FzZSAnMSc6XHJcbiAgICAgICAgICAgIGlmKCFBY3RpdmVSb3cuU1BFQ0lBTF9MQUJFTC50ZXN0KGtleVsndGV4dCddKSAmJiBrZXlbJ3RleHQnXSAhPSAnJykge1xyXG4gICAgICAgICAgICAgIGtleVsnc3AnXT0nMyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICcyJzpcclxuICAgICAgICAgICAgaWYoIUFjdGl2ZVJvdy5TUEVDSUFMX0xBQkVMLnRlc3Qoa2V5Wyd0ZXh0J10pICYmIGtleVsndGV4dCddICE9ICcnKSB7XHJcbiAgICAgICAgICAgICAga2V5WydzcCddPSc0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEFjdGl2ZUtleS5wb2x5ZmlsbChrZXksIGxheW91dCwgZGlzcGxheUxheWVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyogVGhlIGNhbGN1bGF0aW9ucyBoZXJlIGFyZSBlZmZlY3RpdmVseSAndmlydHVhbGl6ZWQnLiAgV2hlbiB1c2VkIHdpdGggdGhlIE9TSywgdGhlIFZpc3VhbEtleWJvYXJkXHJcbiAgICAgICAqIHdpbGwgb3ZlcndyaXRlIHRoZXNlIHZhbHVlcyB3aXRoIHRoZWlyIHRydWUgcnVudGltZSBnZW9tZXRyeS5cclxuICAgICAgICpcclxuICAgICAgICogVGhlc2UgY2FsY3VsYXRpb25zIGFwcHJveGltYXRlIHRob3NlIG9mIHRoZSBhY3R1YWwgT1NLICh3aXRob3V0IGZpdHRpbmcgdG8gYSBzcGVjaWZpYyByZXNvbHV0aW9uKVxyXG4gICAgICAgKiBhbmQgYXJlIGludGVuZGVkIGZvciB1c2Ugd2l0aCBsYXlvdXQgdGVzdGluZyAod2hpbGUgaGVhZGxlc3MpIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAqL1xyXG5cclxuICAgICAgbGV0IHNldFByb3BvcnRpb25zID0gZnVuY3Rpb24oa2V5OiBBY3RpdmVLZXksIHBhZFBjOiBudW1iZXIsIGtleVBjOiBudW1iZXIsIHRvdGFsUGM6IG51bWJlcikge1xyXG4gICAgICAgIGtleS5wcm9wb3J0aW9uYWxQYWQgICA9IHBhZFBjO1xyXG4gICAgICAgIGtleS5wcm9wb3J0aW9uYWxXaWR0aCA9IGtleVBjO1xyXG4gICAgICAgIGtleS5wcm9wb3J0aW9uYWxYICAgICA9ICh0b3RhbFBjICsgcGFkUGMgKyAoa2V5UGMvMikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgcGVyY2VudGFnZS1iYXNlZCBzY2FsaW5ncyBieSBzdW1taW5nIGRlZmluZWQgd2lkdGhzIGFuZCBzY2FsaW5nIGVhY2gga2V5IHRvICUuXHJcbiAgICAgIC8vIFNhdmUgZWFjaCBwZXJjZW50YWdlIGtleSB3aWR0aCBhcyBhIHNlcGFyYXRlIG1lbWJlciAoZG8gKm5vdCogb3ZlcndyaXRlIGxheW91dCBzcGVjaWZpZWQgd2lkdGghKVxyXG4gICAgICB2YXIga2V5UGVyY2VudDogbnVtYmVyLCBwYWRQZXJjZW50OiBudW1iZXIsIHRvdGFsUGVyY2VudD0wO1xyXG4gICAgICBmb3IobGV0IGo9MDsgajxrZXlzLmxlbmd0aC0xOyBqKyspIHtcclxuICAgICAgICBrZXlQZXJjZW50PXBhcnNlSW50KGtleXNbal1bJ3dpZHRoJ10sMTApL3RvdGFsV2lkdGg7XHJcbiAgICAgICAga2V5c1tqXVsnd2lkdGhwYyddPWtleVBlcmNlbnQ7XHJcbiAgICAgICAgcGFkUGVyY2VudD1wYXJzZUludChrZXlzW2pdWydwYWQnXSwxMCkvdG90YWxXaWR0aDtcclxuICAgICAgICBrZXlzW2pdWydwYWRwYyddPXBhZFBlcmNlbnQ7XHJcblxyXG4gICAgICAgIC8vIGNvbXB1dGUgY2VudGVyJ3MgZGVmYXVsdCB4LWNvb3JkICh1c2VkIGluIGhlYWRsZXNzIG1vZGVzKVxyXG4gICAgICAgIHNldFByb3BvcnRpb25zKGtleXNbal0gYXMgQWN0aXZlS2V5LCBwYWRQZXJjZW50LCBrZXlQZXJjZW50LCB0b3RhbFBlcmNlbnQpO1xyXG4gICAgICAgIHRvdGFsUGVyY2VudCArPSBwYWRQZXJjZW50K2tleVBlcmNlbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFsbG93IGZvciByaWdodCBPU0sgbWFyZ2luICgxNSBsYXlvdXQgdW5pdHMpXHJcbiAgICAgIGxldCByaWdodE1hcmdpbiA9IEFjdGl2ZUtleS5ERUZBVUxUX1JJR0hUX01BUkdJTi90b3RhbFdpZHRoO1xyXG4gICAgICB0b3RhbFBlcmNlbnQgKz0gcmlnaHRNYXJnaW47XHJcblxyXG4gICAgICAvLyBJZiBhIHNpbmdsZSBrZXksIGFuZCBwYWRkaW5nIGlzIG5lZ2F0aXZlLCBhZGQgcGFkZGluZyB0byByaWdodCBhbGlnbiB0aGUga2V5XHJcbiAgICAgIGlmKGtleXMubGVuZ3RoID09IDEgJiYgcGFyc2VJbnQoa2V5c1swXVsncGFkJ10sMTApIDwgMCkge1xyXG4gICAgICAgIGtleVBlcmNlbnQ9cGFyc2VJbnQoa2V5c1swXVsnd2lkdGgnXSwxMCkvdG90YWxXaWR0aDtcclxuICAgICAgICBrZXlzWzBdWyd3aWR0aHBjJ109a2V5UGVyY2VudDtcclxuICAgICAgICB0b3RhbFBlcmNlbnQgKz0ga2V5UGVyY2VudDtcclxuICAgICAgICBrZXlzWzBdWydwYWRwYyddPTEtdG90YWxQZXJjZW50O1xyXG5cclxuICAgICAgICAvLyBjb21wdXRlIGNlbnRlcidzIGRlZmF1bHQgeC1jb29yZCAodXNlZCBpbiBoZWFkbGVzcyBtb2RlcylcclxuICAgICAgICBzZXRQcm9wb3J0aW9ucyhrZXlzWzBdIGFzIEFjdGl2ZUtleSwgcGFkUGVyY2VudCwga2V5UGVyY2VudCwgdG90YWxQZXJjZW50KTtcclxuICAgICAgfSBlbHNlIGlmKGtleXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGxldCBqPWtleXMubGVuZ3RoLTE7XHJcbiAgICAgICAgcGFkUGVyY2VudD1wYXJzZUludChrZXlzW2pdWydwYWQnXSwxMCkvdG90YWxXaWR0aDtcclxuICAgICAgICBrZXlzW2pdWydwYWRwYyddPXBhZFBlcmNlbnQ7XHJcbiAgICAgICAgdG90YWxQZXJjZW50ICs9IHBhZFBlcmNlbnQ7XHJcbiAgICAgICAga2V5c1tqXVsnd2lkdGhwYyddID0ga2V5UGVyY2VudCA9IDEtdG90YWxQZXJjZW50O1xyXG5cclxuICAgICAgICAvLyBjb21wdXRlIGNlbnRlcidzIGRlZmF1bHQgeC1jb29yZCAodXNlZCBpbiBoZWFkbGVzcyBtb2RlcylcclxuICAgICAgICBzZXRQcm9wb3J0aW9ucyhrZXlzW2pdIGFzIEFjdGl2ZUtleSwgcGFkUGVyY2VudCwga2V5UGVyY2VudCwgdG90YWxQZXJjZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkIGNsYXNzIGZ1bmN0aW9ucyB0byB0aGUgZXhpc3RpbmcgbGF5b3V0IG9iamVjdCwgYWxsb3dpbmcgaXQgdG8gYWN0IGFzIGFuIEFjdGl2ZUxheW91dC5cclxuICAgICAgbGV0IGR1bW15ID0gbmV3IEFjdGl2ZVJvdygpO1xyXG4gICAgICBmb3IobGV0IGtleSBpbiBkdW1teSkge1xyXG4gICAgICAgIGlmKCFyb3cuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgcm93W2tleV0gPSBkdW1teVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGFSb3cgPSByb3cgYXMgQWN0aXZlUm93O1xyXG4gICAgICBhUm93LnByb3BvcnRpb25hbFkgPSBwcm9wb3J0aW9uYWxZO1xyXG4gICAgfVxyXG5cclxuICAgIHBvcHVsYXRlS2V5TWFwKG1hcDoge1trZXlJZDogc3RyaW5nXTogQWN0aXZlS2V5fSkge1xyXG4gICAgICB0aGlzLmtleS5mb3JFYWNoKGZ1bmN0aW9uKGtleTogQWN0aXZlS2V5KSB7XHJcbiAgICAgICAgaWYoa2V5LmNvcmVJRCkge1xyXG4gICAgICAgICAgbWFwW2tleS5jb3JlSURdID0ga2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgQWN0aXZlTGF5ZXIgaW1wbGVtZW50cyBMYXlvdXRMYXllciB7XHJcbiAgICByb3c6IEFjdGl2ZVJvd1tdO1xyXG4gICAgaWQ6IHN0cmluZztcclxuXHJcbiAgICB0b3RhbFdpZHRoOiBudW1iZXI7XHJcblxyXG4gICAgZGVmYXVsdEtleVByb3BvcnRpb25hbFdpZHRoOiBudW1iZXI7XHJcbiAgICByb3dQcm9wb3J0aW9uYWxIZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZhY2lsaXRhdGVzIG1hcHBpbmcga2V5IGlkIHN0cmluZ3MgdG8gdGhlaXIgc3BlY2lmaWNhdGlvbiBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICBrZXlNYXA6IHtba2V5SWQ6IHN0cmluZ106IEFjdGl2ZUtleX07XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwb2x5ZmlsbChsYXllcjogTGF5b3V0TGF5ZXIsIGxheW91dDogQWN0aXZlTGF5b3V0KSB7XHJcbiAgICAgIGxheWVyLmFsaWduZWQ9ZmFsc2U7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgYSBESVYgZm9yIGVhY2ggcm93IG9mIHRoZSBncm91cFxyXG4gICAgICBsZXQgcm93cz1sYXllclsncm93J107XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIG1heGltdW0gcm93IHdpZHRoIChpbiBsYXlvdXQgdW5pdHMpXHJcbiAgICAgIHZhciB0b3RhbFdpZHRoPTA7XHJcbiAgICAgIGZvcihsZXQgaT0wOyBpPGxheWVyWydyb3cnXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciB3aWR0aD0wO1xyXG4gICAgICAgIGxldCByb3c9cm93c1tpXTtcclxuICAgICAgICBsZXQga2V5cz1yb3dbJ2tleSddO1xyXG4gICAgICAgIGZvcihsZXQgaj0wOyBqPGtleXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGxldCBrZXk9a2V5c1tqXTtcclxuXHJcbiAgICAgICAgICAvLyBUZXN0IGZvciBhIHRyYWlsaW5nIGNvbW1hIGluY2x1ZGVkIGluIHNwZWMsIGFkZGVkIGFzIG51bGwgb2JqZWN0IGJ5IElFXHJcbiAgICAgICAgICBpZihrZXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBrZXlzLmxlbmd0aCA9IGtleXMubGVuZ3RoLTE7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIga3csIGtwO1xyXG4gICAgICAgICAgICBrdyA9ICh0eXBlb2Yga2V5Wyd3aWR0aCddID09ICdzdHJpbmcnICYmIGtleVsnd2lkdGgnXSAhPSAnJykgPyBwYXJzZUludChrZXlbJ3dpZHRoJ10sMTApIDogQWN0aXZlS2V5LkRFRkFVTFRfS0VZX1dJRFRIO1xyXG4gICAgICAgICAgICBpZihpc05hTihrdykgfHwga3cgPT0gMCkga3cgPSBBY3RpdmVLZXkuREVGQVVMVF9LRVlfV0lEVEg7XHJcbiAgICAgICAgICAgIGtleVsnd2lkdGgnXSA9IGt3LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGtwID0gKHR5cGVvZiBrZXlbJ3BhZCddID09ICdzdHJpbmcnICYmIGtleVsncGFkJ10gIT0gJycpID8gcGFyc2VJbnQoa2V5WydwYWQnXSwxMCkgOiBBY3RpdmVLZXkuREVGQVVMVF9QQUQ7XHJcbiAgICAgICAgICAgIGlmKGlzTmFOKGtwKSB8fCBrcCA9PSAwKSBrcCA9IEFjdGl2ZUtleS5ERUZBVUxUX1BBRDsgIC8vIEtNRVctMTE5XHJcbiAgICAgICAgICAgIGtleVsncGFkJ10gPSBrcC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB3aWR0aCArPSBrdyArIGtwO1xyXG4gICAgICAgICAgICAvL2lmKHR5cGVvZiBrZXlbJ3dpZHRoJ10gPT0gJ3N0cmluZycgJiYga2V5Wyd3aWR0aCddICE9ICcnKSB3aWR0aCArPSBwYXJzZUludChrZXlbJ3dpZHRoJ10sMTApOyBlbHNlIHdpZHRoICs9IERFRkFVTFRfS0VZX1dJRFRIO1xyXG4gICAgICAgICAgICAvL2lmKHR5cGVvZiBrZXlbJ3BhZCddID09ICdzdHJpbmcnICYmIGtleVsncGFkJ10gIT0gJycpIHdpZHRoICs9IHBhcnNlSW50KGtleVsncGFkJ10sMTApOyBlbHNlIHdpZHRoICs9IDU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHdpZHRoID4gdG90YWxXaWR0aCkge1xyXG4gICAgICAgICAgdG90YWxXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkIGRlZmF1bHQgcmlnaHQgbWFyZ2luXHJcbiAgICAgIGlmKGxheW91dC5mb3JtRmFjdG9yID09ICdkZXNrdG9wJykge1xyXG4gICAgICAgIHRvdGFsV2lkdGggKz0gNTsgLy8gVE9ETzogcmVzb2x2ZSBkaWZmZXJlbmNlIGJldHdlZW4gdG91Y2ggYW5kIGRlc2t0b3A7IHdoeSBkb24ndCB3ZSB1c2UgQWN0aXZlS2V5LkRFRkFVTFRfUklHSFRfTUFSR0lOP1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRvdGFsV2lkdGggKz0gQWN0aXZlS2V5LkRFRkFVTFRfUklHSFRfTUFSR0lOO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgcm93Q291bnQgPSBsYXllci5yb3cubGVuZ3RoO1xyXG4gICAgICBmb3IobGV0IGk9MDsgaTxyb3dDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHByb3BvcnRpb25hbCB5LWNvb3JkIG9mIHJvdy4gIDAgaXMgYXQgdG9wIHdpdGggaGlnaGVzdCB5LWNvb3JkLlxyXG4gICAgICAgIGxldCByb3dQcm9wb3J0aW9uYWxZID0gKGkgKyAwLjUpIC8gcm93Q291bnQ7XHJcbiAgICAgICAgQWN0aXZlUm93LnBvbHlmaWxsKGxheWVyLnJvd1tpXSwgbGF5b3V0LCBsYXllci5pZCwgdG90YWxXaWR0aCwgcm93UHJvcG9ydGlvbmFsWSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFkZCBjbGFzcyBmdW5jdGlvbnMgYW5kIHByb3BlcnRpZXMgdG8gdGhlIGV4aXN0aW5nIGxheW91dCBvYmplY3QsIGFsbG93aW5nIGl0IHRvIGFjdCBhcyBhbiBBY3RpdmVMYXlvdXQuXHJcbiAgICAgIGxldCBkdW1teSA9IG5ldyBBY3RpdmVMYXllcigpO1xyXG4gICAgICBmb3IobGV0IGtleSBpbiBkdW1teSkge1xyXG4gICAgICAgIGlmKCFsYXllci5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICBsYXllcltrZXldID0gZHVtbXlba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBhTGF5ZXIgPSBsYXllciBhcyBBY3RpdmVMYXllcjtcclxuICAgICAgYUxheWVyLnRvdGFsV2lkdGggPSB0b3RhbFdpZHRoO1xyXG4gICAgICBhTGF5ZXIuZGVmYXVsdEtleVByb3BvcnRpb25hbFdpZHRoID0gcGFyc2VJbnQoQWN0aXZlS2V5LkRFRkFVTFRfS0VZLndpZHRoLCAxMCkgLyB0b3RhbFdpZHRoO1xyXG4gICAgICBhTGF5ZXIucm93UHJvcG9ydGlvbmFsSGVpZ2h0ID0gMS4wIC8gcm93Q291bnQ7XHJcbiAgICAgIGFMYXllci5rZXlNYXAgPSBhTGF5ZXIuY29uc3RydWN0S2V5TWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RLZXlNYXAoKToge1trZXlJZDogc3RyaW5nXTogQWN0aXZlS2V5fSB7XHJcbiAgICAgIGxldCBtYXA6IHtba2V5SWQ6IHN0cmluZ106IEFjdGl2ZUtleX0gPSB7fTtcclxuICAgICAgdGhpcy5yb3cuZm9yRWFjaChmdW5jdGlvbihyb3c6IEFjdGl2ZVJvdykge1xyXG4gICAgICAgIHJvdy5wb3B1bGF0ZUtleU1hcChtYXApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBzb3J0ZWQtb3JkZXIgYXJyYXkgb2YgbW9zdCBsaWtlbHkga2V5cyB0byBiZSBpbnRlbmRlZCBmb3IgYSBnaXZlbiB0b3VjaC5cclxuICAgICAqIEBwYXJhbSB0b3VjaENvb3JkcyBBIHByb3BvcnRpb25hbCAoeCwgeSkgY29vcmRpbmF0ZSBvZiB0aGUgdG91Y2ggd2l0aGluIHRoZSBrZXlib2FyZCdzIGdlb21ldHJ5LlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBTaG91bGQgYmUgd2l0aGluIFswLCAwXSB0byBbMSwgMV0uXHJcbiAgICAgKiBAcGFyYW0ga2JkU2NhbGVSYXRpbyBUaGUgcmF0aW8gb2YgdGhlIGtleWJvYXJkJ3MgaG9yaXpvbnRhbCBzY2FsZSB0byBpdHMgdmVydGljYWwgc2NhbGUuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvciBhIDQwMCB4IDIwMCBrZXlib2FyZCwgc2hvdWxkIGJlIDIuXHJcbiAgICAgKi9cclxuICAgIGdldFRvdWNoUHJvYmFiaWxpdGllcyh0b3VjaENvb3Jkczoge3g6IG51bWJlciwgeTogbnVtYmVyfSwga2JkU2NhbGVSYXRpbzogbnVtYmVyKTogS2V5RGlzdHJpYnV0aW9uIHtcclxuICAgICAgbGV0IGRpc3RyaWJ1dGlvbiA9IHRoaXMuc2ltcGxlVG91Y2hEaXN0cmlidXRpb24odG91Y2hDb29yZHMsIGtiZFNjYWxlUmF0aW8pO1xyXG4gICAgICBsZXQgbGlzdDoge2tleUlkOiBzdHJpbmcsIHA6IG51bWJlcn1bXSA9IFtdO1xyXG5cclxuICAgICAgZm9yKGxldCBrZXkgaW4gZGlzdHJpYnV0aW9uKSB7XHJcbiAgICAgICAgbGlzdC5wdXNoKHtrZXlJZDoga2V5LCBwOiBkaXN0cmlidXRpb25ba2V5XX0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYi5wIC0gYS5wOyAvLyBMYXJnZXN0IHByb2JhYmlsaXR5IGtleXMgc2hvdWxkIGJlIGxpc3RlZCBmaXJzdC5cclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGEgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIHJlZ2FyZGluZyB0aGUgbGlrZWxpaG9vZCBvZiBhIHRvdWNoIGNvbW1hbmQgYmVpbmcgaW50ZW5kZWRcclxuICAgICAqIGZvciBlYWNoIG9mIHRoZSBsYXlvdXQncyBrZXlzLlxyXG4gICAgICogQHBhcmFtIHRvdWNoQ29vcmRzIEEgcHJvcG9ydGlvbmFsICh4LCB5KSBjb29yZGluYXRlIG9mIHRoZSB0b3VjaCB3aXRoaW4gdGhlIGtleWJvYXJkJ3MgZ2VvbWV0cnkuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNob3VsZCBiZSB3aXRoaW4gWzAsIDBdIHRvIFsxLCAxXS5cclxuICAgICAqIEBwYXJhbSBrYmRTY2FsZVJhdGlvIFRoZSByYXRpbyBvZiB0aGUga2V5Ym9hcmQncyBob3Jpem9udGFsIHNjYWxlIHRvIGl0cyB2ZXJ0aWNhbCBzY2FsZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGEgNDAwIHggMjAwIGtleWJvYXJkLCBzaG91bGQgYmUgMi5cclxuICAgICAqL1xyXG4gICAgc2ltcGxlVG91Y2hEaXN0cmlidXRpb24odG91Y2hDb29yZHM6IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sIGtiZFNjYWxlUmF0aW86IG51bWJlcik6IHtba2V5SWQ6IHN0cmluZ106IG51bWJlcn0ge1xyXG4gICAgICBsZXQga2V5RGlzdHMgPSB0aGlzLmtleVRvdWNoRGlzdGFuY2VzKHRvdWNoQ29vcmRzLCBrYmRTY2FsZVJhdGlvKTtcclxuICAgICAgbGV0IGtleVByb2JzOiB7W2tleUlkOiBzdHJpbmddOiBudW1iZXJ9ID0ge307XHJcblxyXG4gICAgICBsZXQgdG90YWxNYXNzID0gMDtcclxuXHJcbiAgICAgIC8vIFNob3VsZCB3ZSB3aXNoIHRvIGFsbG93IG11bHRpcGxlIGRpZmZlcmVudCB0cmFuc2Zvcm1zIGZvciBkaXN0YW5jZSAtPiBwcm9iYWJpbGl0eSwgdXNlIGEgZnVuY3Rpb24gcGFyYW1ldGVyIGluIHBsYWNlXHJcbiAgICAgIC8vIG9mIHRoZSBmb3JtdWxhIGluIHRoZSBsb29wIGJlbG93LlxyXG4gICAgICBmb3IobGV0IGtleSBpbiBrZXlEaXN0cykge1xyXG4gICAgICAgIHRvdGFsTWFzcyArPSBrZXlQcm9ic1trZXldID0gMSAvIChrZXlEaXN0c1trZXldICsgMWUtNik7IC8vIFByZXZlbnQgZGl2LWJ5LTAgZXJyb3JzLlxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IobGV0IGtleSBpbiBrZXlQcm9icykge1xyXG4gICAgICAgIGtleVByb2JzW2tleV0gLz0gdG90YWxNYXNzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ga2V5UHJvYnM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhIHNxdWFyZWQgJ3BzZXVkby1kaXN0YW5jZScgZm9yIHRoZSB0b3VjaCBmcm9tIGVhY2gga2V5LiAgKE5vdCBhIHByb3BlciBtZXRyaWMuKVxyXG4gICAgICogSW50ZW5kZWQgZm9yIHVzZSBpbiBnZW5lcmF0aW5nIGEgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIG92ZXIgdGhlIGtleXMgYmFzZWQgb24gdGhlIHRvdWNoIGlucHV0LlxyXG4gICAgICogQHBhcmFtIHRvdWNoQ29vcmRzIEEgcHJvcG9ydGlvbmFsICh4LCB5KSBjb29yZGluYXRlIG9mIHRoZSB0b3VjaCB3aXRoaW4gdGhlIGtleWJvYXJkJ3MgZ2VvbWV0cnkuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNob3VsZCBiZSB3aXRoaW4gWzAsIDBdIHRvIFsxLCAxXS5cclxuICAgICAqIEBwYXJhbSBrYmRTY2FsZVJhdGlvIFRoZSByYXRpbyBvZiB0aGUga2V5Ym9hcmQncyBob3Jpem9udGFsIHNjYWxlIHRvIGl0cyB2ZXJ0aWNhbCBzY2FsZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGEgNDAwIHggMjAwIGtleWJvYXJkLCBzaG91bGQgYmUgMi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBrZXlUb3VjaERpc3RhbmNlcyh0b3VjaENvb3Jkczoge3g6IG51bWJlciwgeTogbnVtYmVyfSwga2JkU2NhbGVSYXRpbzogbnVtYmVyKToge1trZXlJZDogc3RyaW5nXTogbnVtYmVyfSB7XHJcbiAgICAgIGxldCBsYXllciA9IHRoaXM7XHJcblxyXG4gICAgICBsZXQga2V5RGlzdHM6IHtba2V5SWQ6IHN0cmluZ106IG51bWJlcn0gPSB7fTtcclxuXHJcbiAgICAgIC8vIFRoaXMgZG91YmxlLW5lc3RlZCBsb29wIGNvbXB1dGVzIGEgcHNldWRvLWRpc3RhbmNlIGZvciB0aGUgdG91Y2ggZnJvbSBlYWNoIGtleS4gIFF1aXRlIHVzZWZ1bCBmb3JcclxuICAgICAgLy8gZ2VuZXJhdGluZyBhIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbi5cclxuICAgICAgdGhpcy5yb3cuZm9yRWFjaChmdW5jdGlvbihyb3c6IEFjdGl2ZVJvdyk6IHZvaWQge1xyXG4gICAgICAgIHJvdy5rZXkuZm9yRWFjaChmdW5jdGlvbihrZXk6IEFjdGl2ZUtleSk6IHZvaWQge1xyXG4gICAgICAgICAgLy8gSWYgdGhlIGtleSBsYWNrcyBhbiBJRCwganVzdCBza2lwIGl0LiAgU29tZXRpbWVzIHVzZWQgZm9yIHBhZGRpbmcuXHJcbiAgICAgICAgICBpZigha2V5LmJhc2VLZXlJRCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGZpbHRlciBvdXQga25vd24gbm9uLW91dHB1dCBrZXlzLlxyXG4gICAgICAgICAgICAvLyBSZXN1bHRzIGluIGEgbW9yZSBvcHRpbWl6ZWQgZGlzdHJpYnV0aW9uLlxyXG4gICAgICAgICAgICBzd2l0Y2goa2V5LmJhc2VLZXlJRCkge1xyXG4gICAgICAgICAgICAgIGNhc2UgJ0tfU0hJRlQnOlxyXG4gICAgICAgICAgICAgIGNhc2UgJ0tfTE9QVCc6XHJcbiAgICAgICAgICAgICAgY2FzZSAnS19ST1BUJzpcclxuICAgICAgICAgICAgICBjYXNlICdLX05VTUxPQ0snOiAvLyBPZnRlbiB1c2VkIGZvciBudW1lcmljIGxheWVycy5cclxuICAgICAgICAgICAgICBjYXNlICdLX0NBUFMnOlxyXG4gICAgICAgICAgICAgICAgLy8gQXMgdGhlc2UgYXJlbid0IG91dHB1dCBrZXlzLCB0aGV5IHNob3VsZG4ndCBiZSBwb3NzaWJsZSBmYXQtZmluZ2VyIHRhcmdldHMuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIC8vIFJlZmVyIHRvIHRleHQvY29kZXMudHMgLSB0aGVzZSBhcmUgS2V5bWFuLWN1c3RvbSBcImtleWNvZGVzXCIgdXNlZCBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGxheWVyIHNoaWZ0aW5nIGtleXMuICBUbyBiZSBzYWZlLCB3ZSBjdXJyZW50bHkgbGV0IEtfVEFCQkFDSyBhbmQgXHJcbiAgICAgICAgICAgICAgICAvLyBLX1RBQkZXRCB0aHJvdWdoLCB0aG91Z2ggd2UgbWlnaHQgYmUgYWJsZSB0byBkcm9wIHRoZW0gdG9vLlxyXG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBjb20ua2V5bWFuLnRleHQuQ29kZXNba2V5LmJhc2VLZXlJRF07XHJcbiAgICAgICAgICAgICAgICBpZihjb2RlID4gNTAwMDAgJiYgY29kZSA8IDUwMDExKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gVGhlc2UgcmVwcmVzZW50IHRoZSB3aXRoaW4ta2V5IGRpc3RhbmNlIG9mIHRoZSB0b3VjaCBmcm9tIHRoZSBrZXkncyBjZW50ZXIuXHJcbiAgICAgICAgICAvLyBCb3RoIHNob3VsZCBiZSBvbiB0aGUgaW50ZXJ2YWwgWzAsIDAuNV0uXHJcbiAgICAgICAgICBsZXQgZHggPSBNYXRoLmFicyh0b3VjaENvb3Jkcy54IC0ga2V5LnByb3BvcnRpb25hbFgpO1xyXG4gICAgICAgICAgbGV0IGR5ID0gTWF0aC5hYnModG91Y2hDb29yZHMueSAtIHJvdy5wcm9wb3J0aW9uYWxZKTtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgdG91Y2ggaXNuJ3Qgd2l0aGluIHRoZSBrZXksIHRoZXNlIHN0b3JlIHRoZSBvdXQtb2Yta2V5IGRpc3RhbmNlXHJcbiAgICAgICAgICAvLyBmcm9tIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBrZXkgYmVpbmcgY2hlY2tlZC5cclxuICAgICAgICAgIGxldCBkaXN0WDogbnVtYmVyLCBkaXN0WTogbnVtYmVyO1xyXG5cclxuICAgICAgICAgIGlmKGR4ID4gMC41ICoga2V5LnByb3BvcnRpb25hbFdpZHRoKSB7XHJcbiAgICAgICAgICAgIGRpc3RYID0gKGR4IC0gMC41ICoga2V5LnByb3BvcnRpb25hbFdpZHRoKTtcclxuICAgICAgICAgICAgZHggPSAwLjU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkaXN0WCA9IDA7XHJcbiAgICAgICAgICAgIGR4IC89IGtleS5wcm9wb3J0aW9uYWxXaWR0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZihkeSA+IDAuNSAqIGxheWVyLnJvd1Byb3BvcnRpb25hbEhlaWdodCkge1xyXG4gICAgICAgICAgICBkaXN0WSA9IChkeSAtIDAuNSAqIGxheWVyLnJvd1Byb3BvcnRpb25hbEhlaWdodCk7XHJcbiAgICAgICAgICAgIGR5ID0gMC41O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGlzdFkgPSAwO1xyXG4gICAgICAgICAgICBkeSAvPSBsYXllci5yb3dQcm9wb3J0aW9uYWxIZWlnaHQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTm93IHRoYXQgdGhlIGRpZmZlcmVudGlhbHMgYXJlIGNvbXB1dGVkLCBpdCdzIHRpbWUgdG8gZG8gZGlzdGFuY2Ugc2NhbGluZy5cclxuICAgICAgICAgIC8vXHJcbiAgICAgICAgICAvLyBGb3Igb3V0LW9mLWtleSBkaXN0YW5jZSwgd2Ugc2NhbGUgdGhlIFggY29tcG9uZW50IGJ5IHRoZSBrZXlib2FyZCdzIGFzcGVjdCByYXRpb1xyXG4gICAgICAgICAgLy8gdG8gZ2V0IHRoZSBhY3R1YWwgb3V0LW9mLWtleSBkaXN0YW5jZSByYXRoZXIgdGhhbiBwcm9wb3J0aW9uYWwuXHJcbiAgICAgICAgICBkaXN0WCAqPSBrYmRTY2FsZVJhdGlvO1xyXG5cclxuICAgICAgICAgIC8vIFdoaWxlIHRoZSBrZXlzIGFyZSByYXJlbHkgcGVyZmVjdCBzcXVhcmVzLCB3ZSBtYXAgYWxsIHdpdGhpbi1rZXkgZGlzdGFuY2VcclxuICAgICAgICAgIC8vIHRvIGEgc3F1YXJlIHNoYXBlLiAgKEFMVC9DTUQgc2hvdWxkIHNlZW0gYXMgY2xvc2UgdG8gU1BBQ0UgYXMgYSAnQicuKVxyXG4gICAgICAgICAgLy9cclxuICAgICAgICAgIC8vIEZvciB0aGF0IHNxdWFyZSwgd2UgdGFrZSB0aGUgcm93SGVpZ2h0IGFzIGl0cyBlZGdlIGxlbmd0aHMuXHJcbiAgICAgICAgICBkaXN0WCArPSBkeCAqIGxheWVyLnJvd1Byb3BvcnRpb25hbEhlaWdodDtcclxuICAgICAgICAgIGRpc3RZICs9IGR5ICogbGF5ZXIucm93UHJvcG9ydGlvbmFsSGVpZ2h0O1xyXG5cclxuICAgICAgICAgIGxldCBkaXN0YW5jZSA9IGRpc3RYICogZGlzdFggKyBkaXN0WSAqIGRpc3RZO1xyXG4gICAgICAgICAga2V5RGlzdHNba2V5LmNvcmVJRF0gPSBkaXN0YW5jZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4ga2V5RGlzdHM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0S2V5KGtleUlkOiBzdHJpbmcpIHtcclxuICAgICAgLy8gS2V5cyB1c3VhbGx5IGFyZSBzcGVjaWZpZWQgaW4gYSBcImxvbmcgZm9ybVwiIHByZWZpeGVkIHdpdGggdGhlaXIgbGF5ZXIncyBJRC5cclxuICAgICAgaWYoa2V5SWQuaW5kZXhPZih0aGlzLmlkICsgJy0nKSA9PSAwKSB7XHJcbiAgICAgICAga2V5SWQgPSBrZXlJZC5yZXBsYWNlKHRoaXMuaWQgKyAnLScsICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGlkQ29tcG9uZW50cyA9IGtleUlkLnNwbGl0KCc6OicpO1xyXG4gICAgICBpZihpZENvbXBvbmVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIGxldCBiYXNlS2V5ID0gdGhpcy5rZXlNYXBbaWRDb21wb25lbnRzWzBdXTtcclxuICAgICAgICByZXR1cm4gYmFzZUtleS5nZXRTdWJrZXkoaWRDb21wb25lbnRzWzFdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXBba2V5SWRdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgQWN0aXZlTGF5b3V0IGltcGxlbWVudHMgTGF5b3V0Rm9ybUZhY3RvcntcclxuICAgIGxheWVyOiBBY3RpdmVMYXllcltdO1xyXG4gICAgZm9udDogc3RyaW5nO1xyXG4gICAga2V5TGFiZWxzOiBib29sZWFuO1xyXG4gICAgaXNEZWZhdWx0PzogYm9vbGVhbjtcclxuICAgIGtleWJvYXJkOiBLZXlib2FyZDtcclxuICAgIGZvcm1GYWN0b3I6IHV0aWxzLkZvcm1GYWN0b3I7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGYWNpbGl0YXRlcyBtYXBwaW5nIGxheWVyIGlkIHN0cmluZ3MgdG8gdGhlaXIgc3BlY2lmaWNhdGlvbiBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICBsYXllck1hcDoge1tsYXllcklkOiBzdHJpbmddOiBBY3RpdmVMYXllcn07XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TGF5ZXIobGF5ZXJJZDogc3RyaW5nKTogQWN0aXZlTGF5ZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5sYXllck1hcFtsYXllcklkXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5b3V0XHJcbiAgICAgKiBAcGFyYW0gZm9ybUZhY3RvclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcG9seWZpbGwobGF5b3V0OiBMYXlvdXRGb3JtRmFjdG9yLCBrZXlib2FyZDogS2V5Ym9hcmQsIGZvcm1GYWN0b3I6IHV0aWxzLkZvcm1GYWN0b3IpOiBBY3RpdmVMYXlvdXQge1xyXG4gICAgICBpZihsYXlvdXQgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBidWlsZCBhbiBBY3RpdmVMYXlvdXQgZm9yIGEgbnVsbCBzcGVjaWZpY2F0aW9uLlwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ3JlYXRlIGEgc2VwYXJhdGUgT1NLIGRpdiBmb3IgZWFjaCBPU0sgbGF5ZXIsIG9ubHkgb25lIG9mIHdoaWNoIHdpbGwgZXZlciBiZSB2aXNpYmxlXHJcbiAgICAgIHZhciBuOiBudW1iZXIsIGk6IG51bWJlcjtcclxuICAgICAgdmFyIGxheWVyczogTGF5b3V0TGF5ZXJbXSwgbGF5ZXI6IExheW91dExheWVyO1xyXG4gICAgICBsZXQgbGF5ZXJNYXA6IHtbbGF5ZXJJZDogc3RyaW5nXTogQWN0aXZlTGF5ZXJ9ID0ge307XHJcbiAgICAgIHZhciByb3dzOiBMYXlvdXRSb3dbXTtcclxuXHJcbiAgICAgIGxheWVycz1sYXlvdXRbJ2xheWVyJ107XHJcblxyXG4gICAgICAvLyAqKipEZWxldGUgYW55IGVtcHR5IHJvd3MgYXQgdGhlIGVuZCBhZGRlZCBieSBjb21waWxlciBidWcuLi5cclxuICAgICAgZm9yKG49MDsgbjxsYXllcnMubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICBsYXllcj1sYXllcnNbbl07IHJvd3M9bGF5ZXJbJ3JvdyddO1xyXG4gICAgICAgIGZvcihpPXJvd3MubGVuZ3RoOyBpPjA7IGktLSkge1xyXG4gICAgICAgICAgaWYocm93c1tpLTFdWydrZXknXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoaSA8IHJvd3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICByb3dzLnNwbGljZShpLXJvd3MubGVuZ3RoLHJvd3MubGVuZ3RoLWkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyAuLi5yZW1vdmUgdG8gaGVyZSB3aGVuIGNvbXBpbGVyIGJ1ZyBmaXhlZCAqKipcclxuXHJcbiAgICAgIC8vIEFkZCBjbGFzcyBmdW5jdGlvbnMgdG8gdGhlIGV4aXN0aW5nIGxheW91dCBvYmplY3QsIGFsbG93aW5nIGl0IHRvIGFjdCBhcyBhbiBBY3RpdmVMYXlvdXQuXHJcbiAgICAgIGxldCBkdW1teSA9IG5ldyBBY3RpdmVMYXlvdXQoKTtcclxuICAgICAgZm9yKGxldCBrZXkgaW4gZHVtbXkpIHtcclxuICAgICAgICBpZighbGF5b3V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgIGxheW91dFtrZXldID0gZHVtbXlba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBhTGF5b3V0ID0gbGF5b3V0IGFzIEFjdGl2ZUxheW91dDtcclxuICAgICAgYUxheW91dC5rZXlib2FyZCA9IGtleWJvYXJkO1xyXG4gICAgICBhTGF5b3V0LmZvcm1GYWN0b3IgPSBmb3JtRmFjdG9yO1xyXG5cclxuICAgICAgZm9yKG49MDsgbjxsYXllcnMubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICBBY3RpdmVMYXllci5wb2x5ZmlsbChsYXllcnNbbl0sIGFMYXlvdXQpO1xyXG4gICAgICAgIGxheWVyTWFwW2xheWVyc1tuXS5pZF0gPSBsYXllcnNbbl0gYXMgQWN0aXZlTGF5ZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFMYXlvdXQubGF5ZXJNYXAgPSBsYXllck1hcDtcclxuXHJcbiAgICAgIHJldHVybiBhTGF5b3V0O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBjb20ua2V5bWFuLnRleHQge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgY29tbW9uIGJlaGF2aW9ycyBhc3NvY2lhdGVkIHdpdGggc3lzdGVtIHN0b3Jlcy5cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU3lzdGVtU3RvcmUge1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGlkOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoaWQ6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgYWJzdHJhY3QgbWF0Y2hlcyh2YWx1ZTogc3RyaW5nKTogYm9vbGVhbjtcclxuXHJcbiAgICBzZXQodmFsdWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeXN0ZW0gc3RvcmUgd2l0aCBJRCBcIiArIHRoaXMuaWQgKyBcIiBtYXkgbm90IGJlIGRpcmVjdGx5IHNldC5cIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIGhhbmRsZXIgZGVzaWduZWQgdG8gcmVjZWl2ZSBmZWVkYmFjayB3aGVuZXZlciBhIHN5c3RlbSBzdG9yZSdzIHZhbHVlIGlzIGNoYW5nZWQuXHJcbiAgICogQHBhcmFtIHNvdXJjZSAgICBUaGUgc3lzdGVtIHN0b3JlIGJlaW5nIG11dGF0ZWQsIGJlZm9yZSB0aGUgdmFsdWUgY2hhbmdlIG9jY3Vycy5cclxuICAgKiBAcGFyYW0gbmV3VmFsdWUgIFRoZSBuZXcgdmFsdWUgYmVpbmcgc2V0XHJcbiAgICogQHJldHVybnMgICAgICAgICBgZmFsc2VgIC8gYHVuZGVmaW5lZGAgdG8gYWxsb3cgdGhlIGNoYW5nZSwgYHRydWVgIHRvIGJsb2NrIHRoZSBjaGFuZ2UuXHJcbiAgICovXHJcbiAgZXhwb3J0IHR5cGUgU3lzdGVtU3RvcmVNdXRhdGlvbkhhbmRsZXIgPSAoc291cmNlOiBNdXRhYmxlU3lzdGVtU3RvcmUsIG5ld1ZhbHVlOiBzdHJpbmcpID0+IGJvb2xlYW47XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBNdXRhYmxlU3lzdGVtU3RvcmUgZXh0ZW5kcyBTeXN0ZW1TdG9yZSB7XHJcbiAgICBwcml2YXRlIF92YWx1ZTogc3RyaW5nO1xyXG4gICAgaGFuZGxlcj86IFN5c3RlbVN0b3JlTXV0YXRpb25IYW5kbGVyID0gbnVsbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpZDogbnVtYmVyLCBkZWZhdWx0VmFsdWU6IHN0cmluZykge1xyXG4gICAgICBzdXBlcihpZCk7XHJcbiAgICAgIHRoaXMuX3ZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIG1hdGNoZXModmFsdWU6IHN0cmluZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPT0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0KHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgaWYodGhpcy5oYW5kbGVyKSB7XHJcbiAgICAgICAgaWYodGhpcy5oYW5kbGVyKHRoaXMsIHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgY2hlY2tzIGFnYWluc3QgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFBsYXRmb3JtU3lzdGVtU3RvcmUgZXh0ZW5kcyBTeXN0ZW1TdG9yZSB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGtiZEludGVyZmFjZTogS2V5Ym9hcmRJbnRlcmZhY2U7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioa2V5Ym9hcmRJbnRlcmZhY2U6IEtleWJvYXJkSW50ZXJmYWNlKSB7XHJcbiAgICAgIHN1cGVyKEtleWJvYXJkSW50ZXJmYWNlLlRTU19QTEFURk9STSk7XHJcblxyXG4gICAgICB0aGlzLmtiZEludGVyZmFjZSA9IGtleWJvYXJkSW50ZXJmYWNlO1xyXG4gICAgfVxyXG5cclxuICAgIG1hdGNoZXModmFsdWU6IHN0cmluZykge1xyXG4gICAgICB2YXIgaSxjb25zdHJhaW50LGNvbnN0cmFpbnRzPXZhbHVlLnNwbGl0KCcgJyk7XHJcbiAgICAgIGxldCBkZXZpY2UgPSB0aGlzLmtiZEludGVyZmFjZS5hY3RpdmVEZXZpY2U7XHJcblxyXG4gICAgICBmb3IoaT0wOyBpPGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3RyYWludD1jb25zdHJhaW50c1tpXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHN3aXRjaChjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICBjYXNlICd0b3VjaCc6XHJcbiAgICAgICAgICBjYXNlICdoYXJkd2FyZSc6XHJcbiAgICAgICAgICAgIGlmKGRldmljZS50b3VjaGFibGUgIT0gKGNvbnN0cmFpbnQgPT0gJ3RvdWNoJykpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnbWFjb3MnOlxyXG4gICAgICAgICAgY2FzZSAnbWFjJzpcclxuICAgICAgICAgICAgY29uc3RyYWludCA9ICdtYWNvc3gnO1xyXG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcclxuICAgICAgICAgIGNhc2UgJ21hY29zeCc6XHJcbiAgICAgICAgICBjYXNlICd3aW5kb3dzJzpcclxuICAgICAgICAgIGNhc2UgJ2FuZHJvaWQnOlxyXG4gICAgICAgICAgY2FzZSAnaW9zJzpcclxuICAgICAgICAgIGNhc2UgJ2xpbnV4JzpcclxuICAgICAgICAgICAgaWYoZGV2aWNlLk9TICE9IGNvbnN0cmFpbnQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAndGFibGV0JzpcclxuICAgICAgICAgIGNhc2UgJ3Bob25lJzpcclxuICAgICAgICAgIGNhc2UgJ2Rlc2t0b3AnOlxyXG4gICAgICAgICAgICBpZihkZXZpY2UuZm9ybUZhY3RvciAhPSBjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ3dlYic6XHJcbiAgICAgICAgICAgIGlmKGRldmljZS5icm93c2VyID09ICduYXRpdmUnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZWIgbWF0Y2hlcyBhbnl0aGluZyBvdGhlciB0aGFuICduYXRpdmUnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgY2FzZSAnbmF0aXZlJzpcclxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHJldHVybiB0cnVlIGZvciBlbWJlZGRlZCBLZXltYW5XZWJcclxuICAgICAgICAgIGNhc2UgJ2llJzpcclxuICAgICAgICAgIGNhc2UgJ2Nocm9tZSc6XHJcbiAgICAgICAgICBjYXNlICdmaXJlZm94JzpcclxuICAgICAgICAgIGNhc2UgJ3NhZmFyaSc6XHJcbiAgICAgICAgICBjYXNlICdlZGdlJzpcclxuICAgICAgICAgIGNhc2UgJ29wZXJhJzpcclxuICAgICAgICAgICAgaWYoZGV2aWNlLmJyb3dzZXIgIT0gY29uc3RyYWludCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFdmVyeXRoaW5nIHdlIGNoZWNrZWQgYWdhaW5zdCB3YXMgdmFsaWQgYW5kIGhhZCBtYXRjaGVzIC0gaXQncyBhIG1hdGNoIVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiZGVhZGtleXMudHNcIiAvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwicnVsZUJlaGF2aW9yLnRzXCIgLz5cclxuXHJcbi8vIERlZmluZXMgY2xhc3NlcyBmb3IgaGFuZGxpbmcgc3lzdGVtIHN0b3Jlc1xyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwic3lzdGVtU3RvcmVzLnRzXCIgLz5cclxuXHJcbi8qKipcclxuICAgS2V5bWFuV2ViIDExLjBcclxuICAgQ29weXJpZ2h0IDIwMTkgU0lMIEludGVybmF0aW9uYWxcclxuKioqL1xyXG5cclxubmFtZXNwYWNlIGNvbS5rZXltYW4udGV4dCB7XHJcbiAgLy8jcmVnaW9uIEhlbHBlciB0eXBlIGRlZmluaXRpb25zXHJcblxyXG4gIGV4cG9ydCBjbGFzcyBLZXlJbmZvcm1hdGlvbiB7XHJcbiAgICB2azogYm9vbGVhbjtcclxuICAgIGNvZGU6IG51bWJlcjtcclxuICAgIG1vZGlmaWVyczogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAqIFR5cGUgYWxpYXMgZGVmaW5pdGlvbnMgdG8gcmVmbGVjdCB0aGUgcGFyYW1ldGVycyBvZiB0aGUgZnVsbENvbnRleHRNYXRjaCgpIGNhbGxiYWNrIChLTVcgMTArKS5cclxuICAqIE5vIGNvbnN0cnVjdG9ycyBvciBtZXRob2RzIHNpbmNlIGtleWJvYXJkcyB3aWxsIG5vdCB1dGlsaXplIHRoZSBzYW1lIGJhY2tpbmcgcHJvdG90eXBlLCBhbmRcclxuICAqIHByb3BlcnR5IG5hbWVzIGFyZSBzaG9ydGhhbmRlZCB0byBwcm9tb3RlIG1pbmlmaWNhdGlvbi5cclxuICAqL1xyXG4gIHR5cGUgUGxhaW5LZXlib2FyZFN0b3JlID0gc3RyaW5nO1xyXG5cclxuICBleHBvcnQgdHlwZSBLZXlib2FyZFN0b3JlRWxlbWVudCA9IChzdHJpbmd8U3RvcmVOb25DaGFyRW50cnkpO1xyXG4gIGV4cG9ydCB0eXBlIENvbXBsZXhLZXlib2FyZFN0b3JlID0gS2V5Ym9hcmRTdG9yZUVsZW1lbnRbXTtcclxuXHJcbiAgdHlwZSBLZXlib2FyZFN0b3JlID0gUGxhaW5LZXlib2FyZFN0b3JlIHwgQ29tcGxleEtleWJvYXJkU3RvcmU7XHJcblxyXG4gIGV4cG9ydCB0eXBlIFZhcmlhYmxlU3RvcmUgPSB7W25hbWU6IHN0cmluZ106IHN0cmluZ307XHJcblxyXG4gIHR5cGUgUnVsZUNoYXIgPSBzdHJpbmc7XHJcblxyXG4gIGNsYXNzIFJ1bGVEZWFka2V5IHtcclxuICAgIC8qKiBEaXNjcmltaW5hbnQgZmllbGQgLSAnZCcgZm9yIERlYWRrZXkuXHJcbiAgICAgKi9cclxuICAgIFsndCddOiAnZCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWx1ZTogIHRoZSBkZWFka2V5J3MgSUQuXHJcbiAgICAgKi9cclxuICAgIFsnZCddOiBudW1iZXI7IC8vIEZvciAnZCdlYWRrZXk7IGFsc28gcmVmbGVjdHMgdGhlIERlYWRrZXkgY2xhc3MncyAnZCcgcHJvcGVydHkuXHJcbiAgfVxyXG5cclxuICBjbGFzcyBDb250ZXh0QW55IHtcclxuICAgIC8qKiBEaXNjcmltaW5hbnQgZmllbGQgLSAnYScgZm9yIGBhbnkoKWAuXHJcbiAgICAgKi9cclxuICAgIFsndCddOiAnYSc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWx1ZTogIHRoZSBzdG9yZSB0byBzZWFyY2guXHJcbiAgICAgKi9cclxuICAgIFsnYSddOiBLZXlib2FyZFN0b3JlOyAvLyBGb3IgJ2Enbnkgc3RhdGVtZW50LlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIHRydWUsIG5lZ2F0ZXMgdGhlICdhbnknLlxyXG4gICAgICovXHJcbiAgICBbJ24nXTogYm9vbGVhbnwwfDE7XHJcbiAgfVxyXG5cclxuICBjbGFzcyBSdWxlSW5kZXgge1xyXG4gICAgLyoqIERpc2NyaW1pbmFudCBmaWVsZCAtICdpJyBmb3IgYGluZGV4KClgLlxyXG4gICAgICovXHJcbiAgICBbJ3QnXTogJ2knO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsdWU6IHRoZSBTdG9yZSBmcm9tIHdoaWNoIHRvIG91dHB1dFxyXG4gICAgICovXHJcbiAgICBbJ2knXTogS2V5Ym9hcmRTdG9yZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9mZnNldDogdGhlIG9mZnNldCBpbiBjb250ZXh0IGZvciB0aGUgY29ycmVzcG9uZGluZyBgYW55KClgLlxyXG4gICAgICovXHJcbiAgICBbJ28nXTogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgY2xhc3MgQ29udGV4dEV4IHtcclxuICAgIC8qKiBEaXNjcmltaW5hbnQgZmllbGQgLSAnYycgZm9yIGBjb250ZXh0KClgLlxyXG4gICAgICovXHJcbiAgICBbJ3QnXTogJ2MnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsdWU6ICBUaGUgb2Zmc2V0IGludG8gdGhlIGN1cnJlbnQgcnVsZSdzIGNvbnRleHQgdG8gYmUgbWF0Y2hlZC5cclxuICAgICAqL1xyXG4gICAgWydjJ106IG51bWJlcjsgLy8gRm9yICdjJ29udGV4dCBzdGF0ZW1lbnQuXHJcbiAgfVxyXG5cclxuICBjbGFzcyBDb250ZXh0TnVsIHtcclxuICAgIC8qKiBEaXNjcmltaW5hbnQgZmllbGQgLSAnbicgZm9yIGBudWxgXHJcbiAgICAgKi9cclxuICAgIFsndCddOiAnbic7XHJcbiAgfVxyXG5cclxuICBjbGFzcyBTdG9yZUJlZXAge1xyXG4gICAgLyoqIERpc2NyaW1pbmFudCBmaWVsZCAtICdiJyBmb3IgYGJlZXBgXHJcbiAgICAgKi9cclxuICAgIFsndCddOiAnYic7XHJcbiAgfVxyXG5cclxuICB0eXBlIENvbnRleHROb25DaGFyRW50cnkgPSBSdWxlRGVhZGtleSB8IENvbnRleHRBbnkgfCBSdWxlSW5kZXggfCBDb250ZXh0RXggfCBDb250ZXh0TnVsO1xyXG4gIHR5cGUgQ29udGV4dEVudHJ5ID0gUnVsZUNoYXIgfCBDb250ZXh0Tm9uQ2hhckVudHJ5O1xyXG5cclxuICB0eXBlIFN0b3JlTm9uQ2hhckVudHJ5ID0gUnVsZURlYWRrZXkgfCBTdG9yZUJlZXA7XHJcblxyXG4gIC8qKlxyXG4gICAqIENhY2hlIG9mIGNvbnRleHQgc3RvcmluZyBhbmQgcmV0cmlldmluZyByZXR1cm4gdmFsdWVzIGZyb20gS0NcclxuICAgKiBNdXN0IGJlIHJlc2V0IHByaW9yIHRvIGVhY2gga2V5c3Ryb2tlIGFuZCBhZnRlciBhbnkgdGV4dCBjaGFuZ2VzXHJcbiAgICogTUNEIDMvMS8xNFxyXG4gICAqKi9cclxuICBjbGFzcyBDYWNoZWRDb250ZXh0IHtcclxuICAgIF9jYWNoZTogc3RyaW5nW11bXTtcclxuXHJcbiAgICByZXNldCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5fY2FjaGUgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQobjogbnVtYmVyLCBsbjogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgLy8gcmV0dXJuIG51bGw7IC8vIHVuY29tbWVudCB0aGlzIGxpbmUgdG8gZGlzYWJsZSBjb250ZXh0IGNhY2hpbmdcclxuICAgICAgaWYodHlwZW9mIHRoaXMuX2NhY2hlW25dID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH0gZWxzZSBpZih0eXBlb2YgdGhpcy5fY2FjaGVbbl1bbG5dID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW25dW2xuXTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQobjogbnVtYmVyLCBsbjogbnVtYmVyLCB2YWw6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBpZih0eXBlb2YgdGhpcy5fY2FjaGVbbl0gPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0aGlzLl9jYWNoZVtuXSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NhY2hlW25dW2xuXSA9IHZhbDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0eXBlIENhY2hlZEV4RW50cnkgPSB7dmFsQ29udGV4dDogKHN0cmluZ3xudW1iZXIpW10sIGRlYWRDb250ZXh0OiB0ZXh0LkRlYWRrZXlbXX07XHJcbiAgLyoqXHJcbiAgICogQW4gZXh0ZW5kZWQgdmVyc2lvbiBvZiBjYWNoZWQgY29udGV4dCBzdG9yaW5nIGRlc2lnbmVkIHRvIHdvcmsgd2l0aFxyXG4gICAqIGBmdWxsQ29udGV4dE1hdGNoYCBhbmQgaXRzIGhlbHBlciBmdW5jdGlvbnMuXHJcbiAgICovXHJcbiAgY2xhc3MgQ2FjaGVkQ29udGV4dEV4IHtcclxuICAgIF9jYWNoZTogQ2FjaGVkRXhFbnRyeVtdW107XHJcblxyXG4gICAgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuX2NhY2hlID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0KG46IG51bWJlciwgbG46IG51bWJlcik6IENhY2hlZEV4RW50cnkge1xyXG4gICAgICAvLyByZXR1cm4gbnVsbDsgLy8gdW5jb21tZW50IHRoaXMgbGluZSB0byBkaXNhYmxlIGNvbnRleHQgY2FjaGluZ1xyXG4gICAgICBpZih0eXBlb2YgdGhpcy5fY2FjaGVbbl0gPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfSBlbHNlIGlmKHR5cGVvZiB0aGlzLl9jYWNoZVtuXVtsbl0gPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVbbl1bbG5dO1xyXG4gICAgfVxyXG5cclxuICAgIHNldChuOiBudW1iZXIsIGxuOiBudW1iZXIsIHZhbDogQ2FjaGVkRXhFbnRyeSk6IHZvaWQge1xyXG4gICAgICBpZih0eXBlb2YgdGhpcy5fY2FjaGVbbl0gPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0aGlzLl9jYWNoZVtuXSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NhY2hlW25dW2xuXSA9IHZhbDtcclxuICAgIH1cclxuXHJcbiAgICBjbG9uZSgpOiBDYWNoZWRDb250ZXh0RXgge1xyXG4gICAgICBsZXQgciA9IG5ldyBDYWNoZWRDb250ZXh0RXgoKTtcclxuICAgICAgci5fY2FjaGUgPSB0aGlzLl9jYWNoZTtcclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8jZW5kcmVnaW9uXHJcblxyXG4gIGV4cG9ydCBjbGFzcyBLZXlib2FyZEludGVyZmFjZSB7XHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgR0xPQkFMX05BTUUgPSAnS2V5bWFuV2ViJztcclxuXHJcbiAgICBjYWNoZWRDb250ZXh0OiBDYWNoZWRDb250ZXh0ID0gbmV3IENhY2hlZENvbnRleHQoKTtcclxuICAgIGNhY2hlZENvbnRleHRFeDogQ2FjaGVkQ29udGV4dEV4ID0gbmV3IENhY2hlZENvbnRleHRFeCgpO1xyXG4gICAgcnVsZUNvbnRleHRFeDogQ2FjaGVkQ29udGV4dEV4O1xyXG5cclxuICAgIGFjdGl2ZVRhcmdldE91dHB1dDogT3V0cHV0VGFyZ2V0O1xyXG4gICAgcnVsZUJlaGF2aW9yOiBSdWxlQmVoYXZpb3I7XHJcblxyXG4gICAgc3RhdGljIHJlYWRvbmx5IFRTU19MQVlFUjogICAgbnVtYmVyID0gMzM7XHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgVFNTX1BMQVRGT1JNOiBudW1iZXIgPSAzMTtcclxuXHJcbiAgICBzeXN0ZW1TdG9yZXM6IHtbc3RvcmVJRDogbnVtYmVyXTogU3lzdGVtU3RvcmV9O1xyXG5cclxuICAgIF9BbnlJbmRpY2VzOiAgbnVtYmVyW10gPSBbXTsgICAgLy8gQW55SW5kZXggLSBhcnJheSBvZiBhbnkvaW5kZXggbWF0Y2ggaW5kaWNlc1xyXG5cclxuICAgIC8vIE11c3QgYmUgYWNjZXNzaWJsZSB0byBzb21lIG9mIHRoZSBrZXlib2FyZCBBUEkgbWV0aG9kcy5cclxuICAgIGFjdGl2ZUtleWJvYXJkOiBrZXlib2FyZHMuS2V5Ym9hcmQ7XHJcbiAgICBhY3RpdmVEZXZpY2U6IHV0aWxzLkRldmljZVNwZWM7XHJcblxyXG4gICAgdmFyaWFibGVTdG9yZVNlcmlhbGl6ZXI/OiBWYXJpYWJsZVN0b3JlU2VyaWFsaXplcjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZVN0b3JlU2VyaWFsaXplcjogVmFyaWFibGVTdG9yZVNlcmlhbGl6ZXIgPSBudWxsKSB7XHJcbiAgICAgIHRoaXMuc3lzdGVtU3RvcmVzID0ge307XHJcblxyXG4gICAgICB0aGlzLnN5c3RlbVN0b3Jlc1tLZXlib2FyZEludGVyZmFjZS5UU1NfUExBVEZPUk1dID0gbmV3IFBsYXRmb3JtU3lzdGVtU3RvcmUodGhpcyk7XHJcbiAgICAgIHRoaXMuc3lzdGVtU3RvcmVzW0tleWJvYXJkSW50ZXJmYWNlLlRTU19MQVlFUl0gPSBuZXcgTXV0YWJsZVN5c3RlbVN0b3JlKEtleWJvYXJkSW50ZXJmYWNlLlRTU19MQVlFUiwgJ2RlZmF1bHQnKTtcclxuXHJcbiAgICAgIHRoaXMudmFyaWFibGVTdG9yZVNlcmlhbGl6ZXIgPSB2YXJpYWJsZVN0b3JlU2VyaWFsaXplcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uICAgICBLU0ZcclxuICAgICAqIFNjb3BlICAgICAgICBQdWJsaWNcclxuICAgICAqXHJcbiAgICAgKiBTYXZlcyB0aGUgZG9jdW1lbnQncyBjdXJyZW50IGZvY3VzIHNldHRpbmdzIG9uIGJlaGFsZiBvZiB0aGUga2V5Ym9hcmQuICBPZnRlbiBwYWlyZWQgd2l0aCBpbnNlcnRUZXh0LlxyXG4gICAgICovXHJcbiAgICBzYXZlRm9jdXMoKTogdm9pZCB7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgdGV4dC1pbnNlcnRpb24gbWV0aG9kIHVzZWQgYnkgY3VzdG9tIE9TS3MgZm9yIGhlbHBIVE1MIGludGVyYWN0aW9uLCBsaWtlIHdpdGggc2lsX2V1cm9fbGF0aW4uXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBjdXJyZW50bHkgYnlwYXNzZXMgd2ViLWNvcmUncyBzdGFuZGFyZCB0ZXh0IGhhbmRsaW5nIGNvbnRyb2wgcGF0aCBhbmQgYWxsIHByZWRpY3RpdmUgdGV4dCBwcm9jZXNzaW5nLlxyXG4gICAgICogSXQgYWxzbyBoYXMgRE9NLWRlcGVuZGVuY2llcyB0aGF0IGhlbHAgZW5zdXJlIEtNVydzIGFjdGl2ZSBPdXRwdXRUYXJnZXQgcmV0YWlucyBmb2N1cyBkdXJpbmcgdXNlLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnRUZXh0PzogKFB0ZXh0OiBzdHJpbmcsIFBkZWFkS2V5OiBudW1iZXIpID0+IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiAgICAgcmVnaXN0ZXJLZXlib2FyZCAgS1JcclxuICAgICAqIFNjb3BlICAgICAgICBQdWJsaWNcclxuICAgICAqIEBwYXJhbSAgICAgICB7T2JqZWN0fSAgICAgIFBrICAgICAgS2V5Ym9hcmQgIG9iamVjdFxyXG4gICAgICogRGVzY3JpcHRpb24gIFJlZ2lzdGVycyBhIGtleWJvYXJkIHdpdGggS2V5bWFuV2ViIG9uY2UgaXRzIHNjcmlwdCBoYXMgZnVsbHkgbG9hZGVkLlxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgICAgICBJbiB3ZWItY29yZSwgdGhpcyBhbHNvIGFjdGl2YXRlcyB0aGUga2V5Ym9hcmQ7IGluIG90aGVyIG1vZHVsZXMsIHRoaXMgbWV0aG9kXHJcbiAgICAgKiAgICAgICAgICAgICAgbWF5IGJlIHJlcGxhY2VkIHdpdGggb3RoZXIgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICovXHJcbiAgICByZWdpc3RlcktleWJvYXJkKFBrKTogdm9pZCB7XHJcbiAgICAgIC8vIE5PVEU6ICBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHdlYi1jb3JlIHNwZWNpZmljIGFuZCBpcyBpbnRlbnRpb25hbGx5IHJlcGxhY2VkLCB3aG9sZS1zYWxlLFxyXG4gICAgICAvLyAgICAgICAgYnkgRE9NLWF3YXJlIGNvZGUuXHJcbiAgICAgIGxldCBrZXlib2FyZCA9IG5ldyBrZXlib2FyZHMuS2V5Ym9hcmQoUGspO1xyXG4gICAgICB0aGlzLmFjdGl2ZUtleWJvYXJkID0ga2V5Ym9hcmQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGJ5IERPTS1hd2FyZSBLZXltYW5XZWIgdG8gYWRkIGtleWJvYXJkIHN0dWJzLCB1c2VkIGJ5IHRoZSBgS2V5Ym9hcmRNYW5hZ2VyYCB0eXBlXHJcbiAgICAgKiB0byBvcHRpbWl6ZSByZXNvdXJjZSB1c2UuXHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVyU3R1Yj86IChQc3R1YikgPT4gbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0ICpjYWNoZWQgb3IgdW5jYWNoZWQqIGtleWJvYXJkIGNvbnRleHQgZm9yIGEgc3BlY2lmaWVkIHJhbmdlLCByZWxhdGl2ZSB0byBjYXJldFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgIG4gICAgICAgTnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gbW92ZSBiYWNrIGZyb20gY2FyZXRcclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgIGxuICAgICAgTnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gcmV0dXJuXHJcbiAgICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gICAgICBQZWxlbSAgIEVsZW1lbnQgdG8gd29yayB3aXRoIChtdXN0IGJlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQpXHJcbiAgICAgKiBAcmV0dXJuICAgICAge3N0cmluZ30gICAgICAgICAgICAgIENvbnRleHQgc3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogRXhhbXBsZSAgICAgW2FiY2RlZnxnaGldIGFzIElOUFVULCB3aXRoIHRoZSBjYXJldCBwb3NpdGlvbiBtYXJrZWQgYnkgfDpcclxuICAgICAqICAgICAgICAgICAgIEtDKDIsMSxQZWxlbSkgPT0gXCJlXCJcclxuICAgICAqICAgICAgICAgICAgIEtDKDMsMyxQZWxlbSkgPT0gXCJkZWZcIlxyXG4gICAgICogICAgICAgICAgICAgS0MoMTAsMTAsUGVsZW0pID09IFwiYWJjZGVmXCIgIGkuZS4gcmV0dXJuIGFzIG11Y2ggYXMgcG9zc2libGUgb2YgdGhlIHJlcXVlc3RlZCBzdHJpbmdcclxuICAgICAqL1xyXG5cclxuICAgIGNvbnRleHQobjogbnVtYmVyLCBsbjogbnVtYmVyLCBvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCk6IHN0cmluZyB7XHJcbiAgICAgIHZhciB2ID0gdGhpcy5jYWNoZWRDb250ZXh0LmdldChuLCBsbik7XHJcbiAgICAgIGlmKHYgIT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHIgPSB0aGlzLktDXyhuLCBsbiwgb3V0cHV0VGFyZ2V0KTtcclxuICAgICAgdGhpcy5jYWNoZWRDb250ZXh0LnNldChuLCBsbiwgcik7XHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0ICh1bmNhY2hlZCkga2V5Ym9hcmQgY29udGV4dCBmb3IgYSBzcGVjaWZpZWQgcmFuZ2UsIHJlbGF0aXZlIHRvIGNhcmV0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgbiAgICAgICBOdW1iZXIgb2YgY2hhcmFjdGVycyB0byBtb3ZlIGJhY2sgZnJvbSBjYXJldFxyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgbG4gICAgICBOdW1iZXIgb2YgY2hhcmFjdGVycyB0byByZXR1cm5cclxuICAgICAqIEBwYXJhbSAgICAgICB7T2JqZWN0fSAgICAgIFBlbGVtICAgRWxlbWVudCB0byB3b3JrIHdpdGggKG11c3QgYmUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudClcclxuICAgICAqIEByZXR1cm4gICAgICB7c3RyaW5nfSAgICAgICAgICAgICAgQ29udGV4dCBzdHJpbmdcclxuICAgICAqXHJcbiAgICAgKiBFeGFtcGxlICAgICBbYWJjZGVmfGdoaV0gYXMgSU5QVVQsIHdpdGggdGhlIGNhcmV0IHBvc2l0aW9uIG1hcmtlZCBieSB8OlxyXG4gICAgICogICAgICAgICAgICAgS0MoMiwxLFBlbGVtKSA9PSBcImVcIlxyXG4gICAgICogICAgICAgICAgICAgS0MoMywzLFBlbGVtKSA9PSBcImRlZlwiXHJcbiAgICAgKiAgICAgICAgICAgICBLQygxMCwxMCxQZWxlbSkgPT0gXCJYWFhYYWJjZGVmXCIgIGkuZS4gcmV0dXJuIGFzIG11Y2ggYXMgcG9zc2libGUgb2YgdGhlIHJlcXVlc3RlZCBzdHJpbmcsIHdoZXJlIFggPSBcXHVGRkZFXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgS0NfKG46IG51bWJlciwgbG46IG51bWJlciwgb3V0cHV0VGFyZ2V0OiBPdXRwdXRUYXJnZXQpOiBzdHJpbmcge1xyXG4gICAgICB2YXIgdGVtcENvbnRleHQgPSAnJztcclxuXHJcbiAgICAgIHRlbXBDb250ZXh0ID0gb3V0cHV0VGFyZ2V0LmdldFRleHRCZWZvcmVDYXJldCgpO1xyXG5cclxuICAgICAgaWYodGVtcENvbnRleHQuX2ttd0xlbmd0aCgpIDwgbikge1xyXG4gICAgICAgIHRlbXBDb250ZXh0ID0gQXJyYXkobi10ZW1wQ29udGV4dC5fa213TGVuZ3RoKCkrMSkuam9pbihcIlxcdUZGRkVcIikgKyB0ZW1wQ29udGV4dDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRlbXBDb250ZXh0Ll9rbXdTdWJzdHIoLW4pLl9rbXdTdWJzdHIoMCxsbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiAgICAgbnVsICAgICAgICAgICBLTlxyXG4gICAgICogU2NvcGUgICAgICAgIFB1YmxpY1xyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgbiAgICAgICBMZW5ndGggb2YgY29udGV4dCB0byBjaGVja1xyXG4gICAgICogQHBhcmFtICAgICAgIHtPYmplY3R9ICAgICAgUHRhcmcgICBFbGVtZW50IHRvIHdvcmsgd2l0aCAobXVzdCBiZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50KVxyXG4gICAgICogQHJldHVybiAgICAgIHtib29sZWFufSAgICAgICAgICAgICBUcnVlIGlmIGxlbmd0aCBvZiBjb250ZXh0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBuXHJcbiAgICAgKiBEZXNjcmlwdGlvbiAgVGVzdCBsZW5ndGggb2YgY29udGV4dCwgcmV0dXJuIHRydWUgaWYgdGhlIGxlbmd0aCBvZiB0aGUgY29udGV4dCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gblxyXG4gICAgICpcclxuICAgICAqIEV4YW1wbGUgICAgIFthYmN8ZGVmXSBhcyBJTlBVVCwgd2l0aCB0aGUgY2FyZXQgcG9zaXRpb24gbWFya2VkIGJ5IHw6XHJcbiAgICAgKiAgICAgICAgICAgICBLTigzLFBlbGVtKSA9PSBUUlVFXHJcbiAgICAgKiAgICAgICAgICAgICBLTigyLFBlbGVtKSA9PSBGQUxTRVxyXG4gICAgICogICAgICAgICAgICAgS04oNCxQZWxlbSkgPT0gVFJVRVxyXG4gICAgICovXHJcbiAgICBudWwobjogbnVtYmVyLCBvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCk6IGJvb2xlYW4ge1xyXG4gICAgICB2YXIgY3g9dGhpcy5jb250ZXh0KG4rMSwgMSwgb3V0cHV0VGFyZ2V0KTtcclxuXHJcbiAgICAgIC8vIFdpdGggIzMxLCB0aGUgcmVzdWx0IHdpbGwgYmUgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaWYgY29udGV4dCBpcyBlbXB0eS5cclxuICAgICAgcmV0dXJuIGN4ID09PSBcIlxcdUZGRkVcIjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uICAgICBjb250ZXh0TWF0Y2ggIEtDTVxyXG4gICAgICogU2NvcGUgICAgICAgIFB1YmxpY1xyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgbiAgICAgICBOdW1iZXIgb2YgY2hhcmFjdGVycyB0byBtb3ZlIGJhY2sgZnJvbSBjYXJldFxyXG4gICAgICogQHBhcmFtICAgICAgIHtPYmplY3R9ICAgICAgUHRhcmcgICBGb2N1c2VkIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICAgIHZhbCAgICAgU3RyaW5nIHRvIG1hdGNoXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBsbiAgICAgIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHJldHVyblxyXG4gICAgICogQHJldHVybiAgICAgIHtib29sZWFufSAgICAgICAgICAgICBUcnVlIGlmIHNlbGVjdGVkIGNvbnRleHQgbWF0Y2hlcyB2YWxcclxuICAgICAqIERlc2NyaXB0aW9uICBUZXN0IGtleWJvYXJkIGNvbnRleHQgZm9yIG1hdGNoXHJcbiAgICAgKi9cclxuICAgIGNvbnRleHRNYXRjaChuOiBudW1iZXIsIG91dHB1dFRhcmdldDogT3V0cHV0VGFyZ2V0LCB2YWw6IHN0cmluZywgbG46IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICB2YXIgY3g9dGhpcy5jb250ZXh0KG4sIGxuLCBvdXRwdXRUYXJnZXQpO1xyXG4gICAgICBpZihjeCA9PT0gdmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEkzMzE4XHJcbiAgICAgIH1cclxuICAgICAgb3V0cHV0VGFyZ2V0LmRlYWRrZXlzKCkucmVzZXRNYXRjaGVkKCk7IC8vIEkzMzE4XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyB0aGUgKmNhY2hlZCBvciB1bmNhY2hlZCoga2V5Ym9hcmQgY29udGV4dCBmb3IgYSBzcGVjaWZpZWQgcmFuZ2UsIHJlbGF0aXZlIHRvIGNhcmV0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgbiAgICAgICBOdW1iZXIgb2YgY2hhcmFjdGVycyB0byBtb3ZlIGJhY2sgZnJvbSBjYXJldFxyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgbG4gICAgICBOdW1iZXIgb2YgY2hhcmFjdGVycyB0byByZXR1cm5cclxuICAgICAqIEBwYXJhbSAgICAgICB7T2JqZWN0fSAgICAgIFBlbGVtICAgRWxlbWVudCB0byB3b3JrIHdpdGggKG11c3QgYmUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudClcclxuICAgICAqIEByZXR1cm4gICAgICB7QXJyYXl9ICAgICAgICAgICAgICAgQ29udGV4dCBhcnJheSAob2Ygc3RyaW5ncyBhbmQgbnVtYmVycylcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfQnVpbGRFeHRlbmRlZENvbnRleHQobjogbnVtYmVyLCBsbjogbnVtYmVyLCBvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCk6IENhY2hlZEV4RW50cnkge1xyXG4gICAgICB2YXIgY2FjaGU6IENhY2hlZEV4RW50cnkgPSB0aGlzLmNhY2hlZENvbnRleHRFeC5nZXQobiwgbG4pO1xyXG4gICAgICBpZihjYWNoZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBCeSBmYXIgdGhlIGVhc2llc3Qgd2F5IHRvIGNvcnJlY3RseSBidWlsZCB3aGF0IHdlIHdhbnQgaXMgdG8gc3RhcnQgZnJvbSB0aGUgcmlnaHQgYW5kIHdvcmsgdG8gd2hhdCB3ZSBuZWVkLlxyXG4gICAgICAgIC8vIFdlIG1heSBoYXZlIGRvbmUgaXQgZm9yIGEgc2ltaWxhciBjdXJzb3IgcG9zaXRpb24gYmVmb3JlLlxyXG4gICAgICAgIGNhY2hlID0gdGhpcy5jYWNoZWRDb250ZXh0RXguZ2V0KG4sIG4pO1xyXG4gICAgICAgIGlmKGNhY2hlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAvLyBGaXJzdCwgbGV0J3MgbWFrZSBzdXJlIHdlIGhhdmUgYSBjbG9uZWQsIHNvcnRlZCBjb3B5IG9mIHRoZSBkZWFka2V5IGFycmF5LlxyXG4gICAgICAgICAgbGV0IHVubWF0Y2hlZERlYWRrZXlzID0gb3V0cHV0VGFyZ2V0LmRlYWRrZXlzKCkudG9Tb3J0ZWRBcnJheSgpOyAvLyBJcyByZXZlcnNlLW9yZGVyIHNvcnRlZCBmb3IgdXMgYWxyZWFkeS5cclxuXHJcbiAgICAgICAgICAvLyBUaW1lIHRvIGJ1aWxkIGZyb20gc2NyYXRjaCFcclxuICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICBjYWNoZSA9IHsgdmFsQ29udGV4dDogW10sIGRlYWRDb250ZXh0OiBbXX07XHJcbiAgICAgICAgICB3aGlsZShjYWNoZS52YWxDb250ZXh0Lmxlbmd0aCA8IG4pIHtcclxuICAgICAgICAgICAgLy8gQXMgYWRhcHRlZCBmcm9tIGBkZWFka2V5TWF0Y2hgLlxyXG4gICAgICAgICAgICB2YXIgc3AgPSBvdXRwdXRUYXJnZXQuZ2V0RGVhZGtleUNhcmV0KCk7XHJcbiAgICAgICAgICAgIHZhciBkZWFkUG9zID0gc3AgLSBpbmRleDtcclxuICAgICAgICAgICAgaWYodW5tYXRjaGVkRGVhZGtleXMubGVuZ3RoID4gMCAmJiB1bm1hdGNoZWREZWFka2V5c1swXS5wID4gZGVhZFBvcykge1xyXG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgZGVhZGtleXMgYXQgdGhlIHJpZ2h0LWhhbmQgc2lkZSBvZiB0aGUgY2FyZXQhICBUaGV5IGRvbid0IGJlbG9uZyBpbiB0aGUgY29udGV4dCwgc28gcG9wICdlbSBvZmYuXHJcbiAgICAgICAgICAgICAgdW5tYXRjaGVkRGVhZGtleXMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYodW5tYXRjaGVkRGVhZGtleXMubGVuZ3RoID4gMCAmJiB1bm1hdGNoZWREZWFka2V5c1swXS5wID09IGRlYWRQb3MpIHtcclxuICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBkZWFka2V5LlxyXG4gICAgICAgICAgICAgIGNhY2hlLmRlYWRDb250ZXh0W24tY2FjaGUudmFsQ29udGV4dC5sZW5ndGgtMV0gPSB1bm1hdGNoZWREZWFka2V5c1swXTtcclxuICAgICAgICAgICAgICBjYWNoZS52YWxDb250ZXh0ID0gKFt1bm1hdGNoZWREZWFka2V5c1swXS5kXSBhcyAoc3RyaW5nfG51bWJlcilbXSkuY29uY2F0KGNhY2hlLnZhbENvbnRleHQpO1xyXG4gICAgICAgICAgICAgIHVubWF0Y2hlZERlYWRrZXlzLnNwbGljZSgwLCAxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBjaGFyYWN0ZXIuICBXZSBnZXQgXCJcXHVmZmZlXCIgaWYgaXQgZG9lc24ndCBleGlzdC5cclxuICAgICAgICAgICAgICB2YXIga2MgPSB0aGlzLmNvbnRleHQoKytpbmRleCwgMSwgb3V0cHV0VGFyZ2V0KTtcclxuICAgICAgICAgICAgICBjYWNoZS52YWxDb250ZXh0ID0gKFtrY10gYXMgKHN0cmluZ3xudW1iZXIpW10pLmNvbmNhdChjYWNoZS52YWxDb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5jYWNoZWRDb250ZXh0RXguc2V0KG4sIG4sIGNhY2hlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgdGhlIGNhY2hlLi4uXHJcbiAgICAgICAgdmFyIHN1YkNhY2hlID0gY2FjaGU7XHJcbiAgICAgICAgc3ViQ2FjaGUudmFsQ29udGV4dCA9IHN1YkNhY2hlLnZhbENvbnRleHQuc2xpY2UoMCwgbG4pO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwgc3ViQ2FjaGUudmFsQ29udGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYoc3ViQ2FjaGVbaV0gPT0gJ1xcdWZmZmUnKSB7XHJcbiAgICAgICAgICAgIHN1YkNhY2hlLnZhbENvbnRleHQuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgICAgICBzdWJDYWNoZS5kZWFkQ29udGV4dC5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihzdWJDYWNoZS52YWxDb250ZXh0Lmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICBzdWJDYWNoZS52YWxDb250ZXh0ID0gWydcXHVmZmZlJ107XHJcbiAgICAgICAgICBzdWJDYWNoZS5kZWFkQ29udGV4dCA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYWNoZWRDb250ZXh0RXguc2V0KG4sIGxuLCBzdWJDYWNoZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBzdWJDYWNoZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gICAgICAgZnVsbENvbnRleHRNYXRjaCAgICBLRkNNXHJcbiAgICAgKiBTY29wZSAgICAgICAgICBQcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gICAgICAgICB7bnVtYmVyfSAgICBuICAgICAgIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIG1vdmUgYmFjayBmcm9tIGNhcmV0XHJcbiAgICAgKiBAcGFyYW0gICAgICAgICB7T2JqZWN0fSAgICBQdGFyZyAgIEZvY3VzZWQgZWxlbWVudFxyXG4gICAgICogQHBhcmFtICAgICAgICAge0FycmF5fSAgICAgcnVsZSAgICBBbiBhcnJheSBvZiBDb250ZXh0RW50cmllcyB0byBtYXRjaC5cclxuICAgICAqIEByZXR1cm4gICAgICAgIHtib29sZWFufSAgICAgICAgICAgVHJ1ZSBpZiB0aGUgZnVsbHktc3BlY2lmaWVkIHJ1bGUgY29udGV4dCBtYXRjaGVzIHRoZSBjdXJyZW50IEtNVyBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBBIEtNVyAxMCsgZnVuY3Rpb24gZGVzaWduZWQgdG8gYnJpbmcgS01XIGNsb3NlciB0byBLZXltYW4gRGVza3RvcCBmdW5jdGlvbmFsaXR5LFxyXG4gICAgICogbmVhci1kaXJlY3RseSBtb2RlbGluZyAoZXh0ZXJuYWxseSkgdGhlIGNvbXBpbGVkIGZvcm0gb2YgRGVza3RvcCBydWxlcycgY29udGV4dCBzZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdWxsQ29udGV4dE1hdGNoKG46IG51bWJlciwgb3V0cHV0VGFyZ2V0OiBPdXRwdXRUYXJnZXQsIHJ1bGU6IENvbnRleHRFbnRyeVtdKTogYm9vbGVhbiB7XHJcbiAgICAgIC8vIFN0YWdlIG9uZTogIGJ1aWxkIHRoZSBjb250ZXh0IGluZGV4IG1hcC5cclxuICAgICAgdmFyIGZ1bGxDb250ZXh0ID0gdGhpcy5fQnVpbGRFeHRlbmRlZENvbnRleHQobiwgcnVsZS5sZW5ndGgsIG91dHB1dFRhcmdldCk7XHJcbiAgICAgIHRoaXMucnVsZUNvbnRleHRFeCA9IHRoaXMuY2FjaGVkQ29udGV4dEV4LmNsb25lKCk7XHJcbiAgICAgIHZhciBjb250ZXh0ID0gZnVsbENvbnRleHQudmFsQ29udGV4dDtcclxuICAgICAgdmFyIGRlYWRDb250ZXh0ID0gZnVsbENvbnRleHQuZGVhZENvbnRleHQ7XHJcblxyXG4gICAgICB2YXIgbWlzbWF0Y2ggPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIFRoaXMgc3ltYm9sIGludGVybmFsbHkgaW5kaWNhdGVzIGxhY2sgb2YgY29udGV4dCBpbiBhIHBvc2l0aW9uLiAgKFNlZSBLQ18pXHJcbiAgICAgIGNvbnN0IE5VTF9DT05URVhUID0gXCJcXHVGRkZFXCI7XHJcblxyXG4gICAgICB2YXIgYXNzZXJ0TmV2ZXIgPSBmdW5jdGlvbih4OiBuZXZlcik6IG5ldmVyIHtcclxuICAgICAgICAvLyBDb3VsZCBiZSBhY2Nlc3NlZCBieSBpbXByb3Blcmx5IGhhbmR3cml0dGVuIGNhbGxzIHRvIGBmdWxsQ29udGV4dE1hdGNoYC5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG9iamVjdCBpbiBmdWxsQ29udGV4dE1hdGNoIHNwZWNpZmljYXRpb246IFwiICsgeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFN0YWdlIHR3bzogIHRpbWUgdG8gbWF0Y2ggYWdhaW5zdCB0aGUgcnVsZSBzcGVjaWZpZWQuXHJcbiAgICAgIGZvcih2YXIgaT0wOyBpIDwgcnVsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmKHR5cGVvZiBydWxlW2ldID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICB2YXIgc3RyID0gcnVsZVtpXSBhcyBzdHJpbmc7XHJcbiAgICAgICAgICBpZihzdHIgIT09IGNvbnRleHRbaV0pIHtcclxuICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gVHlwZVNjcmlwdCBuZWVkcyBhIGNhc3QgdG8gdGhpcyBpbnRlcm1lZGlhdGUgdHlwZSB0byBkbyBpdHMgZGlzY3JpbWluYXRlZCB1bmlvbiBtYWdpYy5cclxuICAgICAgICAgIHZhciByID0gcnVsZVtpXSBhcyBDb250ZXh0Tm9uQ2hhckVudHJ5O1xyXG4gICAgICAgICAgc3dpdGNoKHIudCkge1xyXG4gICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgICAvLyBXZSBzdGlsbCBuZWVkIHRvIHNldCBhIGZsYWcgaGVyZTtcclxuICAgICAgICAgICAgICBpZihyWydkJ10gIT09IGNvbnRleHRbaV0pIHtcclxuICAgICAgICAgICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVhZENvbnRleHRbaV0uc2V0KCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdhJzpcclxuICAgICAgICAgICAgICB2YXIgbG9va3VwOiBLZXlib2FyZFN0b3JlRWxlbWVudDtcclxuXHJcbiAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnRleHRbaV0gPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGxvb2t1cCA9IGNvbnRleHRbaV0gYXMgc3RyaW5nO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb29rdXAgPSB7J3QnOiAnZCcsICdkJzogY29udGV4dFtpXSBhcyBudW1iZXJ9O1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYW55KGksIGxvb2t1cCwgci5hKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYoIXIubikgeyAvLyBJZiBpdCdzIGEgc3RhbmRhcmQgJ2FueScuLi5cclxuICAgICAgICAgICAgICAgIGlmKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGRlYWRDb250ZXh0W2ldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gSXQncyBhIGRlYWRrZXkgbWF0Y2gsIHNvIGluZGljYXRlIHRoYXQuXHJcbiAgICAgICAgICAgICAgICAgIGRlYWRDb250ZXh0W2ldLnNldCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gJ24nIGZvciAnbm90YW55Jy5cclxuICAgICAgICAgICAgICAgIC8vIC0gaWYgYHJlc3VsdCA9PT0gdHJ1ZWAsIGBhbnlgIHdvdWxkIG1hdGNoOiAgdGhpcyBzaG91bGQgdGh1cyBmYWlsLlxyXG4gICAgICAgICAgICAgICAgLy8gLSBpZiBgY29udGV4dFtpXSA9PT0gTlVMX0NPTlRFWFRgLCBgbm90YW55YCBzaG91bGQgbm90IG1hdGNoLlxyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihyLm4gJiYgKHJlc3VsdCB8fCBjb250ZXh0W2ldID09PSBOVUxfQ09OVEVYVCkpIHtcclxuICAgICAgICAgICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2knOlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBjb250ZXh0IHdpbGwgbmV2ZXIgaG9sZCBhICdiZWVwLidcclxuICAgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLl9JbmRleChyLmksIHIubykgYXMgc3RyaW5nIHwgUnVsZURlYWRrZXk7XHJcblxyXG4gICAgICAgICAgICAgIGlmKGNoICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZihjaCkgPT0gJ3N0cmluZycgPyBjaCA6IGNoLmQpICE9PSBjb250ZXh0W2ldKSB7XHJcbiAgICAgICAgICAgICAgICBtaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKGRlYWRDb250ZXh0W2ldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRlYWRDb250ZXh0W2ldLnNldCgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYyc6XHJcbiAgICAgICAgICAgICAgaWYoY29udGV4dFtyLmMgLSAxXSAhPT0gY29udGV4dFtpXSkge1xyXG4gICAgICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihkZWFkQ29udGV4dFtpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBkZWFkQ29udGV4dFtpXS5zZXQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ24nOlxyXG4gICAgICAgICAgICAgIC8vIFxcdUZGRkUgaXMgdGhlIGludGVybmFsICdubyBjb250ZXh0IGhlcmUgc2VudGluZWwnLlxyXG4gICAgICAgICAgICAgIGlmKGNvbnRleHRbaV0gIT0gTlVMX0NPTlRFWFQpIHtcclxuICAgICAgICAgICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgYXNzZXJ0TmV2ZXIocik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihtaXNtYXRjaCkge1xyXG4gICAgICAgIC8vIFJlc2V0IHRoZSBtYXRjaGVkICdhbnknIGluZGljZXMsIGlmIGFueS5cclxuICAgICAgICBvdXRwdXRUYXJnZXQuZGVhZGtleXMoKS5yZXNldE1hdGNoZWQoKTtcclxuICAgICAgICB0aGlzLl9BbnlJbmRpY2VzID0gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAhbWlzbWF0Y2g7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiAgICAgS0lLXHJcbiAgICAgKiBTY29wZSAgICAgICAgUHVibGljXHJcbiAgICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gIGUgICBrZXlzdHJva2UgZXZlbnRcclxuICAgICAqIEByZXR1cm4gICAgICB7Ym9vbGVhbn0gICAgIHRydWUgaWYga2V5cHJlc3MgZXZlbnRcclxuICAgICAqIERlc2NyaXB0aW9uICBUZXN0IGlmIGV2ZW50IGFzIGEga2V5cHJlc3MgZXZlbnRcclxuICAgICAqL1xyXG4gICAgaXNLZXlwcmVzcyhlOiBLZXlFdmVudCk6IGJvb2xlYW4ge1xyXG4gICAgICBpZih0aGlzLmFjdGl2ZUtleWJvYXJkLmlzTW5lbW9uaWMpIHsgICAvLyBJMTM4MCAtIHN1cHBvcnQgS0lLIGZvciBwb3NpdGlvbmFsIGxheW91dHNcclxuICAgICAgICByZXR1cm4gIWUuTGlzVmlydHVhbEtleTsgICAgICAgICAgICAgLy8gd2lsbCBub3cgcmV0dXJuIHRydWUgZm9yIFVfeHh4eCBrZXlzLCBidXQgbm90IGZvciBUX3h4eHgga2V5c1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBLZXlNYXBwaW5nLl9VU0tleUNvZGVUb0NoYXJDb2RlKGUpID8gdHJ1ZSA6IGZhbHNlOyAvLyBJMTM4MCAtIHN1cHBvcnQgS0lLIGZvciBwb3NpdGlvbmFsIGxheW91dHNcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gICAgIGtleU1hdGNoICAgICAgS0tNXHJcbiAgICAgKiBTY29wZSAgICAgICAgUHVibGljXHJcbiAgICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gICAgICBlICAgICAgICAgICBrZXlzdHJva2UgZXZlbnRcclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgIExydWxlc2hpZnRcclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgIExydWxla2V5XHJcbiAgICAgKiBAcmV0dXJuICAgICAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBUcnVlIGlmIGtleSBtYXRjaGVzIHJ1bGVcclxuICAgICAqIERlc2NyaXB0aW9uICBUZXN0IGtleXN0cm9rZSB3aXRoIG1vZGlmaWVycyBhZ2FpbnN0IHJ1bGVcclxuICAgICAqL1xyXG4gICAga2V5TWF0Y2goZTogS2V5RXZlbnQsIExydWxlc2hpZnQ6bnVtYmVyLCBMcnVsZWtleTpudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgdmFyIHJldFZhbCA9IGZhbHNlOyAvLyBJMzMxOFxyXG4gICAgICB2YXIga2V5Q29kZSA9IChlLkxjb2RlID09IDE3MyA/IDE4OSA6IGUuTGNvZGUpOyAgLy9JMzU1NSAoRmlyZWZveCBoeXBoZW4gaXNzdWUpXHJcblxyXG4gICAgICBsZXQgYml0bWFzayA9IHRoaXMuYWN0aXZlS2V5Ym9hcmQubW9kaWZpZXJCaXRtYXNrO1xyXG4gICAgICBsZXQgQ29kZXMgPSBjb20ua2V5bWFuLnRleHQuQ29kZXM7XHJcbiAgICAgIHZhciBtb2RpZmllckJpdG1hc2sgPSBiaXRtYXNrICYgQ29kZXMubW9kaWZpZXJCaXRtYXNrc1tcIkFMTFwiXTtcclxuICAgICAgdmFyIHN0YXRlQml0bWFzayA9IGJpdG1hc2sgJiBDb2Rlcy5zdGF0ZUJpdG1hc2tzW1wiQUxMXCJdO1xyXG5cclxuICAgICAgaWYoZS52a0NvZGUgPiAyNTUpIHtcclxuICAgICAgICBrZXlDb2RlID0gZS52a0NvZGU7IC8vIGFkZGVkIHRvIHN1cHBvcnQgZXh0ZW5kZWQgKHRvdWNoLWhvbGQpIGtleXMgZm9yIG1uZW1vbmljIGxheW91dHNcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoZS5MaXNWaXJ0dWFsS2V5IHx8IGtleUNvZGUgPiAyNTUpIHtcclxuICAgICAgICBpZigoTHJ1bGVzaGlmdCAmIDB4NDAwMCkgPT0gMHg0MDAwIHx8IChrZXlDb2RlID4gMjU1KSkgeyAvLyBhZGRlZCBrZXlDb2RlIHRlc3QgdG8gc3VwcG9ydCBleHRlbmRlZCBrZXlzXHJcbiAgICAgICAgICByZXRWYWwgPSAoKExydWxla2V5ID09IGtleUNvZGUpICYmICgoTHJ1bGVzaGlmdCAmIG1vZGlmaWVyQml0bWFzaykgPT0gZS5MbW9kaWZpZXJzKSk7IC8vSTMzMTgsIEkzNTU1XHJcbiAgICAgICAgICByZXRWYWwgPSByZXRWYWwgJiYgdGhpcy5zdGF0ZU1hdGNoKGUsIExydWxlc2hpZnQgJiBzdGF0ZUJpdG1hc2spO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmKChMcnVsZXNoaWZ0ICYgMHg0MDAwKSA9PSAwKSB7XHJcbiAgICAgICAgcmV0VmFsID0gKGtleUNvZGUgPT0gTHJ1bGVrZXkpOyAvLyBJMzMxOCwgSTM1NTVcclxuICAgICAgfVxyXG4gICAgICBpZighcmV0VmFsKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRPdXRwdXQuZGVhZGtleXMoKS5yZXNldE1hdGNoZWQoKTsgIC8vIEkzMzE4XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJldFZhbDsgLy8gSTMzMThcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiAgICAgc3RhdGVNYXRjaCAgICBLU01cclxuICAgICAqIFNjb3BlICAgICAgICBQdWJsaWNcclxuICAgICAqIEBwYXJhbSAgICAgICB7T2JqZWN0fSAgICAgIGUgICAgICAga2V5c3Ryb2tlIGV2ZW50XHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBMc3RhdGVcclxuICAgICAqIERlc2NyaXB0aW9uICBUZXN0IGtleXN0cm9rZSBhZ2FpbnN0IHN0YXRlIGtleSBydWxlc1xyXG4gICAgICovXHJcbiAgICBzdGF0ZU1hdGNoKGU6IEtleUV2ZW50LCBMc3RhdGU6IG51bWJlcikge1xyXG4gICAgICByZXR1cm4gKChMc3RhdGUgJiBlLkxzdGF0ZXMpID09IExzdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiAgICAga2V5SW5mb3JtYXRpb24gIEtLSVxyXG4gICAgICogU2NvcGUgICAgICAgIFB1YmxpY1xyXG4gICAgICogQHBhcmFtICAgICAgIHtPYmplY3R9ICAgICAgZVxyXG4gICAgICogQHJldHVybiAgICAgIHtPYmplY3R9ICAgICAgICAgICAgICBPYmplY3Qgd2l0aCBldmVudCdzIHZpcnR1YWwga2V5IGZsYWcsIGtleSBjb2RlLCBhbmQgbW9kaWZpZXJzXHJcbiAgICAgKiBEZXNjcmlwdGlvbiAgR2V0IG9iamVjdCB3aXRoIGV4dGVuZGVkIGtleSBldmVudCBpbmZvcm1hdGlvblxyXG4gICAgICovXHJcbiAgICBrZXlJbmZvcm1hdGlvbihlOiBLZXlFdmVudCk6IEtleUluZm9ybWF0aW9uIHtcclxuICAgICAgdmFyIGVpID0gbmV3IEtleUluZm9ybWF0aW9uKCk7XHJcbiAgICAgIGVpWyd2ayddID0gZS5MaXNWaXJ0dWFsS2V5O1xyXG4gICAgICBlaVsnY29kZSddID0gZS5MY29kZTtcclxuICAgICAgZWlbJ21vZGlmaWVycyddID0gZS5MbW9kaWZpZXJzO1xyXG4gICAgICByZXR1cm4gZWk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gICAgIGRlYWRrZXlNYXRjaCAgS0RNXHJcbiAgICAgKiBTY29wZSAgICAgICAgUHVibGljXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBuICAgICAgIG9mZnNldCBmcm9tIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gICAgICBQdGFyZyAgIHRhcmdldCBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBkICAgICAgIGRlYWRrZXlcclxuICAgICAqIEByZXR1cm4gICAgICB7Ym9vbGVhbn0gICAgICAgICAgICAgVHJ1ZSBpZiBkZWFka2V5IGZvdW5kIHNlbGVjdGVkIGNvbnRleHQgbWF0Y2hlcyB2YWxcclxuICAgICAqIERlc2NyaXB0aW9uICBNYXRjaCBkZWFka2V5IGF0IGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIGRlYWRrZXlNYXRjaChuOiBudW1iZXIsIG91dHB1dFRhcmdldDogT3V0cHV0VGFyZ2V0LCBkOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIG91dHB1dFRhcmdldC5oYXNEZWFka2V5TWF0Y2gobiwgZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiAgICAgYmVlcCAgICAgICAgICBLQlxyXG4gICAgICogU2NvcGUgICAgICAgIFB1YmxpY1xyXG4gICAgICogQHBhcmFtICAgICAgIHtPYmplY3R9ICAgICAgUGVsZW0gICAgIGVsZW1lbnQgdG8gZmxhc2hcclxuICAgICAqIERlc2NyaXB0aW9uICBGbGFzaCBib2R5IGFzIHN1YnN0aXR1dGUgZm9yIGF1ZGlibGUgYmVlcDsgbm90aWZ5IGVtYmVkZGVkIGRldmljZSB0byB2aWJyYXRlXHJcbiAgICAgKi9cclxuICAgIGJlZXAob3V0cHV0VGFyZ2V0OiBPdXRwdXRUYXJnZXQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yZXNldENvbnRleHRDYWNoZSgpO1xyXG5cclxuICAgICAgLy8gRGVub3RlIGFzIHBhcnQgb2YgdGhlIG1hdGNoZWQgcnVsZSdzIGJlaGF2aW9yLlxyXG4gICAgICB0aGlzLnJ1bGVCZWhhdmlvci5iZWVwID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBfRXhwbG9kZVN0b3JlKHN0b3JlOiBLZXlib2FyZFN0b3JlKTogQ29tcGxleEtleWJvYXJkU3RvcmUge1xyXG4gICAgICBpZih0eXBlb2Yoc3RvcmUpID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgbGV0IGNhY2hlZFN0b3JlcyA9IHRoaXMuYWN0aXZlS2V5Ym9hcmQuZXhwbG9kZWRTdG9yZXM7XHJcblxyXG4gICAgICAgIC8vIElzIHRoZSByZXN1bHQgY2FjaGVkP1xyXG4gICAgICAgIGlmKGNhY2hlZFN0b3Jlc1tzdG9yZV0pIHtcclxuICAgICAgICAgIHJldHVybiBjYWNoZWRTdG9yZXNbc3RvcmVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm9wZSwgc28gbGV0J3MgYnVpbGQgaXRzIGNhY2hlLlxyXG4gICAgICAgIHZhciByZXN1bHQ6IENvbXBsZXhLZXlib2FyZFN0b3JlID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBzdG9yZS5fa213TGVuZ3RoKCk7IGkrKykge1xyXG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RvcmUuX2ttd0NoYXJBdChpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0IGZvciBsYXRlciFcclxuICAgICAgICBjYWNoZWRTdG9yZXNbc3RvcmVdID0gcmVzdWx0O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiAgICAgYW55ICAgICAgICAgICBLQVxyXG4gICAgICogU2NvcGUgICAgICAgIFB1YmxpY1xyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgbiAgICAgY2hhcmFjdGVyIHBvc2l0aW9uIChpbmRleClcclxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICAgIGNoICAgIGNoYXJhY3RlciB0byBmaW5kIGluIHN0cmluZ1xyXG4gICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgICAgcyAgICAgJ2FueScgc3RyaW5nXHJcbiAgICAgKiBAcmV0dXJuICAgICAge2Jvb2xlYW59ICAgICAgICAgICBUcnVlIGlmIGNoYXJhY3RlciBmb3VuZCBpbiAnYW55JyBzdHJpbmcsIHNldHMgaW5kZXggYWNjb3JkaW5nbHlcclxuICAgICAqIERlc2NyaXB0aW9uICBUZXN0IGZvciBjaGFyYWN0ZXIgbWF0Y2hpbmdcclxuICAgICAqL1xyXG4gICAgYW55KG46IG51bWJlciwgY2g6IEtleWJvYXJkU3RvcmVFbGVtZW50LCBzOiBLZXlib2FyZFN0b3JlKTogYm9vbGVhbiB7XHJcbiAgICAgIGlmKGNoID09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzID0gdGhpcy5fRXhwbG9kZVN0b3JlKHMpO1xyXG4gICAgICB2YXIgTGl4ID0gLTE7XHJcbiAgICAgIGZvcih2YXIgaT0wOyBpIDwgcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmKHR5cGVvZihzW2ldKSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgaWYoc1tpXSA9PSBjaCkge1xyXG4gICAgICAgICAgICBMaXggPSBpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYoc1tpXVsnZCddID09PSBjaFsnZCddKSB7XHJcbiAgICAgICAgICBMaXggPSBpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX0FueUluZGljZXNbbl0gPSBMaXg7XHJcbiAgICAgIHJldHVybiBMaXggPj0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uICAgICBfSW5kZXhcclxuICAgICAqIFNjb3BlICAgICAgICBQdWJsaWNcclxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICAgIFBzICAgICAgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBQbiAgICAgIGluZGV4XHJcbiAgICAgKiBEZXNjcmlwdGlvbiAgUmV0dXJucyB0aGUgY2hhcmFjdGVyIGZyb20gYSBzdG9yZSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBvZmZzZXQgaW4gdGhlIGluZGV4IGFycmF5XHJcbiAgICAgKi9cclxuICAgIF9JbmRleChQczogS2V5Ym9hcmRTdG9yZSwgUG46IG51bWJlcik6IEtleWJvYXJkU3RvcmVFbGVtZW50IHtcclxuICAgICAgUHMgPSB0aGlzLl9FeHBsb2RlU3RvcmUoUHMpO1xyXG5cclxuICAgICAgaWYodGhpcy5fQW55SW5kaWNlc1tQbi0xXSA8IFBzLmxlbmd0aCkgeyAgIC8vSTMzMTlcclxuICAgICAgICByZXR1cm4gUHNbdGhpcy5fQW55SW5kaWNlc1tQbi0xXV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLyogU2hvdWxkIG5vdCBiZSBwb3NzaWJsZSBmb3IgYSBjb21waWxlZCBrZXlib2FyZCwgYnV0IG1heSBhcmlzZVxyXG4gICAgICAgICogZHVyaW5nIHRoZSBkZXZlbG9wbWVudCBvZiBoYW5kd3JpdHRlbiBrZXlib2FyZHMuXHJcbiAgICAgICAgKi9cclxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbm1hdGNoZWQgY29udGV4dHVhbCBpbmRleCgpIHN0YXRlbWVudCBkZXRlY3RlZCBpbiBydWxlIHdpdGggaW5kZXggXCIgKyBQbiArIFwiIVwiKTtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gICAgIGluZGV4T3V0cHV0ICAgS0lPXHJcbiAgICAgKiBTY29wZSAgICAgICAgUHVibGljXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBQZG4gICAgIG5vIG9mIGNoYXJhY3RlciB0byBvdmVyd3JpdGUgKGRlbGV0ZSlcclxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICAgIFBzICAgICAgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBQbiAgICAgIGluZGV4XHJcbiAgICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gICAgICBQZWxlbSAgIGVsZW1lbnQgdG8gb3V0cHV0IHRvXHJcbiAgICAgKiBEZXNjcmlwdGlvbiAgT3V0cHV0IGEgY2hhcmFjdGVyIHNlbGVjdGVkIGZyb20gdGhlIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIG9mZnNldCBpbiB0aGUgaW5kZXggYXJyYXlcclxuICAgICAqL1xyXG4gICAgaW5kZXhPdXRwdXQoUGRuOiBudW1iZXIsIFBzOiBLZXlib2FyZFN0b3JlLCBQbjogbnVtYmVyLCBvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnJlc2V0Q29udGV4dENhY2hlKCk7XHJcblxyXG4gICAgICB2YXIgYXNzZXJ0TmV2ZXIgPSBmdW5jdGlvbih4OiBuZXZlcik6IG5ldmVyIHtcclxuICAgICAgICAvLyBDb3VsZCBiZSBhY2Nlc3NlZCBieSBpbXByb3Blcmx5IGhhbmR3cml0dGVuIGNhbGxzIHRvIGBmdWxsQ29udGV4dE1hdGNoYC5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG9iamVjdCBpbiBmdWxsQ29udGV4dE1hdGNoIHNwZWNpZmljYXRpb246IFwiICsgeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpbmRleENoYXIgPSB0aGlzLl9JbmRleChQcywgUG4pO1xyXG4gICAgICBpZihpbmRleENoYXIgIT09IFwiXCIpIHtcclxuICAgICAgICBpZih0eXBlb2YgaW5kZXhDaGFyID09ICdzdHJpbmcnICkge1xyXG4gICAgICAgICAgdGhpcy5vdXRwdXQoUGRuLCBvdXRwdXRUYXJnZXQsIGluZGV4Q2hhcik7ICAvL0kzMzE5XHJcbiAgICAgICAgfSBlbHNlIGlmKGluZGV4Q2hhclsndCddKSB7XHJcbiAgICAgICAgICB2YXIgc3RvcmVFbnRyeSA9IGluZGV4Q2hhciBhcyBTdG9yZU5vbkNoYXJFbnRyeTtcclxuXHJcbiAgICAgICAgICBzd2l0Y2goc3RvcmVFbnRyeS50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2InOiAvLyBCZWVwIGNvbW1hbmRzIG1heSBhcHBlYXIgd2l0aGluIHN0b3Jlcy5cclxuICAgICAgICAgICAgICB0aGlzLmJlZXAob3V0cHV0VGFyZ2V0KTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgICAgdGhpcy5kZWFka2V5T3V0cHV0KFBkbiwgb3V0cHV0VGFyZ2V0LCBpbmRleENoYXJbJ2QnXSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgYXNzZXJ0TmV2ZXIoc3RvcmVFbnRyeSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHsgLy8gRm9yIGtleWJvYXJkcyBkZXZlbG9wZWQgZHVyaW5nIDEwLjAncyBhbHBoYSBwaGFzZSAtIHQ6J2QnIHdhcyBhc3N1bWVkLlxyXG4gICAgICAgICAgdGhpcy5kZWFka2V5T3V0cHV0KFBkbiwgb3V0cHV0VGFyZ2V0LCBpbmRleENoYXJbJ2QnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gICAgIGRlbGV0ZUNvbnRleHQgS0RDXHJcbiAgICAgKiBTY29wZSAgICAgICAgUHVibGljXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBkbiAgICAgIG51bWJlciBvZiBjb250ZXh0IGVudHJpZXMgdG8gb3ZlcndyaXRlXHJcbiAgICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gICAgICBQZWxlbSAgIGVsZW1lbnQgdG8gb3V0cHV0IHRvXHJcbiAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgICBzICAgICAgIHN0cmluZyB0byBvdXRwdXRcclxuICAgICAqIERlc2NyaXB0aW9uICBLZXlib2FyZCBvdXRwdXRcclxuICAgICAqL1xyXG4gICAgZGVsZXRlQ29udGV4dChkbjogbnVtYmVyLCBvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCk6IHZvaWQge1xyXG4gICAgICB2YXIgY29udGV4dDogQ2FjaGVkRXhFbnRyeTtcclxuXHJcbiAgICAgIC8vIFdlIHdhbnQgdG8gY29udHJvbCBleGFjdGx5IHdoaWNoIGRlYWRrZXlzIGdldCByZW1vdmVkLlxyXG4gICAgICBpZihkbiA+IDApIHtcclxuICAgICAgICBjb250ZXh0ID0gdGhpcy5fQnVpbGRFeHRlbmRlZENvbnRleHQoZG4sIGRuLCBvdXRwdXRUYXJnZXQpO1xyXG4gICAgICAgIGxldCBudWxDb3VudCA9IDA7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwgY29udGV4dC52YWxDb250ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgZGsgPSBjb250ZXh0LmRlYWRDb250ZXh0W2ldO1xyXG5cclxuICAgICAgICAgIGlmKGRrKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBkZWFka2V5IGluIGNvbnRleHQuXHJcbiAgICAgICAgICAgIG91dHB1dFRhcmdldC5kZWFka2V5cygpLnJlbW92ZShkayk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWR1Y2Ugb3VyIHJlcG9ydGVkIGNvbnRleHQgc2l6ZS5cclxuICAgICAgICAgICAgZG4tLTtcclxuICAgICAgICAgIH0gZWxzZSBpZihjb250ZXh0LnZhbENvbnRleHRbaV0gPT0gXCJcXHVGRkZFXCIpIHtcclxuICAgICAgICAgICAgLy8gQ291bnQgYW55IGBudWxgIHNlbnRpbmVscyB0aGF0IHdvdWxkIGNvbnRyaWJ1dGUgdG8gb3VyIGRlbGV0aW9uIGNvdW50LlxyXG4gICAgICAgICAgICBudWxDb3VudCsrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBhdHRlbXB0cyB0byBkZWxldGUgbnVsIHNlbnRpbmVscywgYXMgdGhleSBkb24ndCBleGlzdCBpbiB0aGUgYWN0dWFsIGNvbnRleHQuXHJcbiAgICAgICAgLy8gKEFkZHJlc3NlcyByZWdyZXNzaW9uIGZyb20gS01XIHYgMTIuMCBwYWlyZWQgd2l0aCBEZXZlbG9wZXIgYnVnIHRocm91Z2ggc2FtZSB2ZXJzaW9uKVxyXG4gICAgICAgIGxldCBjb250ZXh0TGVuZ3RoID0gY29udGV4dC52YWxDb250ZXh0Lmxlbmd0aCAtIG51bENvdW50O1xyXG4gICAgICAgIGlmKGRuID4gY29udGV4dExlbmd0aCkge1xyXG4gICAgICAgICAgZG4gPSBjb250ZXh0TGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgYSBtYXRjaGVkIGRlYWRrZXkgaGFzbid0IGJlZW4gZGVsZXRlZCwgd2UgZG9uJ3QgV0FOVCB0byBkZWxldGUgaXQuXHJcbiAgICAgIG91dHB1dFRhcmdldC5kZWFka2V5cygpLnJlc2V0TWF0Y2hlZCgpO1xyXG5cclxuICAgICAgLy8gV2h5IHJlaW52ZW50IHRoZSB3aGVlbD8gIERlbGV0ZSB0aGUgcmVtYWluaW5nIGNoYXJhY3RlcnMgYnkgJ2luc2VydGluZyBhIGJsYW5rIHN0cmluZycuXHJcbiAgICAgIHRoaXMub3V0cHV0KGRuLCBvdXRwdXRUYXJnZXQsICcnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uICAgICBvdXRwdXQgICAgICAgIEtPXHJcbiAgICAgKiBTY29wZSAgICAgICAgUHVibGljXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBkbiAgICAgIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIG92ZXJ3cml0ZVxyXG4gICAgICogQHBhcmFtICAgICAgIHtPYmplY3R9ICAgICAgUGVsZW0gICBlbGVtZW50IHRvIG91dHB1dCB0b1xyXG4gICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgICAgcyAgICAgICBzdHJpbmcgdG8gb3V0cHV0XHJcbiAgICAgKiBEZXNjcmlwdGlvbiAgS2V5Ym9hcmQgb3V0cHV0XHJcbiAgICAgKi9cclxuICAgIG91dHB1dChkbjogbnVtYmVyLCBvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCwgczpzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yZXNldENvbnRleHRDYWNoZSgpO1xyXG5cclxuICAgICAgb3V0cHV0VGFyZ2V0LnNhdmVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgIG91dHB1dFRhcmdldC5jbGVhclNlbGVjdGlvbigpO1xyXG4gICAgICBvdXRwdXRUYXJnZXQuZGVhZGtleXMoKS5kZWxldGVNYXRjaGVkKCk7IC8vIEkzMzE4XHJcbiAgICAgIGlmKGRuID49IDApIHtcclxuICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IG1hbmFnZXMgYWZmZWN0ZWQgZGVhZGtleSBwb3NpdGlvbnMuICBEb2VzIG5vdCBkZWxldGUgZGVhZGtleXMgYi9jIGxlZ2FjeSBiZWhhdmlvciBzdXBwb3J0LlxyXG4gICAgICAgIG91dHB1dFRhcmdldC5kZWxldGVDaGFyc0JlZm9yZUNhcmV0KGRuKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IG1hbmFnZXMgYWZmZWN0ZWQgZGVhZGtleSBwb3NpdGlvbnMuXHJcbiAgICAgIG91dHB1dFRhcmdldC5pbnNlcnRUZXh0QmVmb3JlQ2FyZXQocyk7XHJcbiAgICAgIG91dHB1dFRhcmdldC5yZXN0b3JlUHJvcGVydGllcygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYGNvbnRleHRFeE91dHB1dGAgZnVuY3Rpb24gZW1pdHMgdGhlIGNoYXJhY3RlciBvciBvYmplY3QgYXQgYGNvbnRleHRPZmZzZXRgIGZyb20gdGhlXHJcbiAgICAgKiBjdXJyZW50IG1hdGNoZWQgcnVsZSdzIGNvbnRleHQuIEludHJvZHVjZWQgaW4gS2V5bWFuIDE0LjAsIGluIG9yZGVyIHRvIHJlc29sdmUgYVxyXG4gICAgICogZ2FwIGJldHdlZW4gZGVza3RvcCBhbmQgd2ViIGNvcmUgZnVuY3Rpb25hbGl0eSBmb3IgY29udGV4dChuKSBtYXRjaGluZyBvbiBub3RhbnkoKS5cclxuICAgICAqIFNlZSAjOTE3IGZvciBhZGRpdGlvbmFsIGRldGFpbC5cclxuICAgICAqIEBhbGlhcyAgICAgICBLQ1hPXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICAgIFBkbiAgICAgICAgICAgIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGRlbGV0ZSBsZWZ0IG9mIGN1cnNvclxyXG4gICAgICogQHBhcmFtICAgICAgIHtPdXRwdXRUYXJnZXR9ICBvdXRwdXRUYXJnZXQgICB0YXJnZXQgdG8gb3V0cHV0IHRvXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICAgIGNvbnRleHRMZW5ndGggIGxlbmd0aCBvZiBjdXJyZW50IHJ1bGUgY29udGV4dCB0byByZXRyaWV2ZVxyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgICBjb250ZXh0T2Zmc2V0ICBvZmZzZXQgZnJvbSBzdGFydCBvZiBjdXJyZW50IHJ1bGUgY29udGV4dCwgMS1iYXNlZFxyXG4gICAgICovXHJcbiAgICBjb250ZXh0RXhPdXRwdXQoUGRuOiBudW1iZXIsIG91dHB1dFRhcmdldDogT3V0cHV0VGFyZ2V0LCBjb250ZXh0TGVuZ3RoOiBudW1iZXIsIGNvbnRleHRPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnJlc2V0Q29udGV4dENhY2hlKCk7XHJcblxyXG4gICAgICBpZihQZG4gPj0gMCkge1xyXG4gICAgICAgIHRoaXMub3V0cHV0KFBkbiwgb3V0cHV0VGFyZ2V0LCBcIlwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMucnVsZUNvbnRleHRFeC5nZXQoY29udGV4dExlbmd0aCwgY29udGV4dExlbmd0aCk7XHJcbiAgICAgIGNvbnN0IGRrID0gY29udGV4dC5kZWFkQ29udGV4dFtjb250ZXh0T2Zmc2V0LTFdLCB2YyA9IGNvbnRleHQudmFsQ29udGV4dFtjb250ZXh0T2Zmc2V0LTFdO1xyXG4gICAgICBpZihkaykge1xyXG4gICAgICAgIG91dHB1dFRhcmdldC5pbnNlcnREZWFka2V5QmVmb3JlQ2FyZXQoZGsuZCk7XHJcbiAgICAgIH0gZWxzZSBpZih0eXBlb2YgdmMgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aGlzLm91dHB1dCgtMSwgb3V0cHV0VGFyZ2V0LCB2Yyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29udGV4dEV4T3V0cHV0OiBzaG91bGQgbmV2ZXIgYmUgYSBudW1lcmljIHZhbENvbnRleHQgd2l0aCBubyBjb3JyZXNwb25kaW5nIGRlYWRDb250ZXh0XCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiAgICAgZGVhZGtleU91dHB1dCBLRE9cclxuICAgICAqIFNjb3BlICAgICAgICBQdWJsaWNcclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgIFBkbiAgICAgbm8gb2YgY2hhcmFjdGVyIHRvIG92ZXJ3cml0ZSAoZGVsZXRlKVxyXG4gICAgICogQHBhcmFtICAgICAgIHtPYmplY3R9ICAgICAgUGVsZW0gICBlbGVtZW50IHRvIG91dHB1dCB0b1xyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgUGQgICAgICBkZWFka2V5IGlkXHJcbiAgICAgKiBEZXNjcmlwdGlvbiAgUmVjb3JkIGEgZGVhZGtleSBhdCBjdXJyZW50IGN1cnNvciBwb3NpdGlvbiwgZGVsZXRpbmcgUGRuIGNoYXJhY3RlcnMgZmlyc3RcclxuICAgICAqL1xyXG4gICAgZGVhZGtleU91dHB1dChQZG46IG51bWJlciwgb3V0cHV0VGFyZ2V0OiBPdXRwdXRUYXJnZXQsIFBkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yZXNldENvbnRleHRDYWNoZSgpO1xyXG5cclxuICAgICAgaWYoUGRuID49IDApIHtcclxuICAgICAgICB0aGlzLm91dHB1dChQZG4sIG91dHB1dFRhcmdldCxcIlwiKTsgIC8vSTMzMTggY29ycmVjdGVkIHRvID49XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG91dHB1dFRhcmdldC5pbnNlcnREZWFka2V5QmVmb3JlQ2FyZXQoUGQpO1xyXG4gICAgICAvLyAgICBfRGVidWdEZWFkS2V5cyhQZWxlbSwgJ0tEZWFkS2V5T3V0cHV0OiBkbj0nK1BkbisnOyBkZWFkS2V5PScrUGQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogS0lGUyBjb21wYXJlcyB0aGUgY29udGVudCBvZiBhIHN5c3RlbSBzdG9yZSB3aXRoIGEgc3RyaW5nIHZhbHVlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgc3lzdGVtSWQgICAgSUQgb2YgdGhlIHN5c3RlbSBzdG9yZSB0byB0ZXN0IChvbmx5IFRTU19MQVlFUiBjdXJyZW50bHkgc3VwcG9ydGVkKVxyXG4gICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgICAgc3RyVmFsdWUgICAgU3RyaW5nIHZhbHVlIHRvIGNvbXBhcmUgdG9cclxuICAgICAqIEBwYXJhbSAgICAgICB7T2JqZWN0fSAgICAgIFBlbGVtICAgICAgIEN1cnJlbnRseSBhY3RpdmUgZWxlbWVudCAobWF5IGJlIG5lZWRlZCBieSBmdXR1cmUgdGVzdHMpXHJcbiAgICAgKiBAcmV0dXJuICAgICAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBUcnVlIGlmIHRoZSB0ZXN0IHN1Y2NlZWRzXHJcbiAgICAgKi9cclxuICAgIGlmU3RvcmUoc3lzdGVtSWQ6IG51bWJlciwgc3RyVmFsdWU6IHN0cmluZywgb3V0cHV0VGFyZ2V0OiBPdXRwdXRUYXJnZXQpOiBib29sZWFuIHtcclxuICAgICAgdmFyIHJlc3VsdD10cnVlO1xyXG4gICAgICBsZXQgc3RvcmUgPSB0aGlzLnN5c3RlbVN0b3Jlc1tzeXN0ZW1JZF07XHJcbiAgICAgIGlmKHN0b3JlKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gc3RvcmUubWF0Y2hlcyhzdHJWYWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDsgLy9Nb3ZlZCBmcm9tIHByZXZpb3VzIGxpbmUsIG5vdyBzdXBwb3J0cyBsYXllciBzZWxlY3Rpb24sIEJ1aWxkIDM1MFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogS1NFVFMgc2V0cyB0aGUgdmFsdWUgb2YgYSBzeXN0ZW0gc3RvcmUgdG8gYSBzdHJpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBzeXN0ZW1JZCAgICBJRCBvZiB0aGUgc3lzdGVtIHN0b3JlIHRvIHNldCAob25seSBUU1NfTEFZRVIgY3VycmVudGx5IHN1cHBvcnRlZClcclxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICAgIHN0clZhbHVlICAgIFN0cmluZyB0byBzZXQgYXMgdGhlIHN5c3RlbSBzdG9yZSBjb250ZW50XHJcbiAgICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gICAgICBQZWxlbSAgICAgICBDdXJyZW50bHkgYWN0aXZlIGVsZW1lbnQgKG1heSBiZSBuZWVkZWQgaW4gZnV0dXJlIHRlc3RzKVxyXG4gICAgICogQHJldHVybiAgICAgIHtib29sZWFufSAgICAgICAgICAgICAgICAgVHJ1ZSBpZiBjb21tYW5kIHN1Y2NlZWRzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaS5lLiBmb3IgVFNTX0xBWUVSLCBpZiB0aGUgbGF5ZXIgaXMgc3VjY2Vzc2Z1bGx5IHNlbGVjdGVkKVxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBvcHRpb24vdmFyaWFibGUgc3RvcmVzIGFyZSBpbnN0ZWFkIHNldCB3aXRoaW4ga2V5Ym9hcmQgc2NyaXB0IGNvZGUsIGFzIHRoZXkgb25seVxyXG4gICAgICogYWZmZWN0IGtleWJvYXJkIGJlaGF2aW9yLlxyXG4gICAgICovXHJcbiAgICBzZXRTdG9yZShzeXN0ZW1JZDogbnVtYmVyLCBzdHJWYWx1ZTogc3RyaW5nLCBvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCk6IGJvb2xlYW4ge1xyXG4gICAgICB0aGlzLnJlc2V0Q29udGV4dENhY2hlKCk7XHJcbiAgICAgIGlmKHN5c3RlbUlkID09IEtleWJvYXJkSW50ZXJmYWNlLlRTU19MQVlFUikge1xyXG4gICAgICAgIC8vIERlbm90ZSB0aGUgY2hhbmdlZCBzdG9yZSBhcyBwYXJ0IG9mIHRoZSBtYXRjaGVkIHJ1bGUncyBiZWhhdmlvci5cclxuICAgICAgICB0aGlzLnJ1bGVCZWhhdmlvci5zZXRTdG9yZVtzeXN0ZW1JZF0gPSBzdHJWYWx1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYW4gb3B0aW9uIHN0b3JlIHZhbHVlIGZyb20gYSBjb29raWUgb3IgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICAgIGtiZE5hbWUgICAgIGtleWJvYXJkIGludGVybmFsIG5hbWVcclxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICAgIHN0b3JlTmFtZSAgIHN0b3JlIChvcHRpb24pIG5hbWUsIGVtYmVkZGVkIGluIGNvb2tpZSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgICBkZmx0VmFsdWUgICBkZWZhdWx0IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuICAgICAge3N0cmluZ30gICAgICAgICAgICAgICAgICBjdXJyZW50IG9yIGRlZmF1bHQgb3B0aW9uIHZhbHVlXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyB3aWxsIG9ubHkgZXZlciBiZSBjYWxsZWQgd2hlbiB0aGUga2V5Ym9hcmQgaXMgbG9hZGVkLCBhcyBpdCBpcyB1c2VkIGJ5IGtleWJvYXJkc1xyXG4gICAgICogdG8gaW5pdGlhbGl6ZSBhIHN0b3JlIHZhbHVlIG9uIHRoZSBrZXlib2FyZCdzIHNjcmlwdCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGxvYWRTdG9yZShrYmROYW1lOiBzdHJpbmcsIHN0b3JlTmFtZTpzdHJpbmcsIGRmbHRWYWx1ZTpzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICB0aGlzLnJlc2V0Q29udGV4dENhY2hlKCk7XHJcbiAgICAgIGlmKHRoaXMudmFyaWFibGVTdG9yZVNlcmlhbGl6ZXIpIHtcclxuICAgICAgICBsZXQgY1ZhbHVlID0gdGhpcy52YXJpYWJsZVN0b3JlU2VyaWFsaXplci5sb2FkU3RvcmUoa2JkTmFtZSwgc3RvcmVOYW1lKTtcclxuICAgICAgICByZXR1cm4gY1ZhbHVlW3N0b3JlTmFtZV0gfHwgZGZsdFZhbHVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkZmx0VmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNhdmUgYW4gb3B0aW9uIHN0b3JlIHZhbHVlIHRvIGEgY29va2llXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgICAgc3RvcmVOYW1lICAgc3RvcmUgKG9wdGlvbikgbmFtZSwgZW1iZWRkZWQgaW4gY29va2llIG5hbWVcclxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICAgIG9wdFZhbHVlICAgIG9wdGlvbiB2YWx1ZSB0byBzYXZlXHJcbiAgICAgKiBAcmV0dXJuICAgICAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICB0cnVlIGlmIHNhdmUgc3VjY2Vzc2Z1bFxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBhIGtleWJvYXJkIHdpbGwgZnJlZWx5IG1hbmlwdWxhdGUgdGhlIHZhbHVlIG9mIGl0cyB2YXJpYWJsZSBzdG9yZXMgb24gdGhlXHJcbiAgICAgKiBzY3JpcHQgb2JqZWN0IHdpdGhpbiBpdHMgb3duIGNvZGUuICBUaGlzIGZ1bmN0aW9uJ3MgdXNlIGlzIG1lcmVseSB0byBfcGVyc2lzdF8gdGhhdFxyXG4gICAgICogdmFsdWUgYWNyb3NzIHNlc3Npb25zLCBwcm92aWRpbmcgYSBjdXN0b20gdXNlciBkZWZhdWx0IGZvciBsYXRlciB1c2VzIG9mIHRoZSBrZXlib2FyZC5cclxuICAgICAqL1xyXG4gICAgc2F2ZVN0b3JlKHN0b3JlTmFtZTpzdHJpbmcsIG9wdFZhbHVlOnN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICB0aGlzLnJlc2V0Q29udGV4dENhY2hlKCk7XHJcbiAgICAgIHZhciBrYmQ9dGhpcy5hY3RpdmVLZXlib2FyZDtcclxuICAgICAgaWYoIWtiZCB8fCB0eXBlb2Yga2JkLmlkID09ICd1bmRlZmluZWQnIHx8IGtiZC5pZCA9PSAnJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQW5kIHRoZSBsb29rdXAgdW5kZXIgdGhhdCBlbnRyeSBsb29rcyBmb3IgdGhlIHZhbHVlIHVuZGVyIHRoZSBzdG9yZSBuYW1lLCBhZ2Fpbi5cclxuICAgICAgbGV0IHZhbHVlT2JqOiBWYXJpYWJsZVN0b3JlID0ge307XHJcbiAgICAgIHZhbHVlT2JqW3N0b3JlTmFtZV0gPSBvcHRWYWx1ZTtcclxuXHJcbiAgICAgIC8vIE51bGwtY2hlY2sgaW4gY2FzZSBvZiBpbnZvY2F0aW9uIGR1cmluZyB1bml0LXRlc3RcclxuICAgICAgaWYodGhpcy5ydWxlQmVoYXZpb3IpIHtcclxuICAgICAgICB0aGlzLnJ1bGVCZWhhdmlvci5zYXZlU3RvcmVbc3RvcmVOYW1lXSA9IHZhbHVlT2JqO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFdlJ3JlIGluIGEgdW5pdC10ZXN0IGVudmlyb25tZW50LCBkaXJlY3RseSBpbnZva2luZyB0aGlzIG1ldGhvZCBmcm9tIG91dHNpZGUgb2YgYSBrZXlib2FyZC5cclxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIHNob3VsZCBpbW1lZGlhdGVseSBjb21taXQgdGhlIGNoYW5nZS5cclxuICAgICAgICB0aGlzLnZhcmlhYmxlU3RvcmVTZXJpYWxpemVyLnNhdmVTdG9yZSh0aGlzLmFjdGl2ZUtleWJvYXJkLmlkLCBzdG9yZU5hbWUsIHZhbHVlT2JqKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXNldENvbnRleHRDYWNoZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5jYWNoZWRDb250ZXh0LnJlc2V0KCk7XHJcbiAgICAgIHRoaXMuY2FjaGVkQ29udGV4dEV4LnJlc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdEJhY2tzcGFjZShvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCkge1xyXG4gICAgICB0aGlzLm91dHB1dCgxLCBvdXRwdXRUYXJnZXQsIFwiXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gICAgIHByb2Nlc3NLZXlzdHJva2VcclxuICAgICAqIFNjb3BlICAgICAgICBQcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gICAgICAgIGVsZW1lbnQgICAgIFRoZSBwYWdlIGVsZW1lbnQgcmVjZWl2aW5nIGlucHV0XHJcbiAgICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gICAgICAgIGtleXN0cm9rZSAgIFRoZSBpbnB1dCBrZXlzdHJva2UgKHdpdGggaXRzIHByb3BlcnRpZXMpIHRvIGJlIG1hcHBlZCBieSB0aGUga2V5Ym9hcmQuXHJcbiAgICAgKiBEZXNjcmlwdGlvbiAgRW5jYXBzdWxhdGVzIGNhbGxzIHRvIGtleWJvYXJkIGlucHV0IHByb2Nlc3NpbmcuXHJcbiAgICAgKiBAcmV0dXJucyAgICAge251bWJlcn0gICAgICAgIDAgaWYgbm8gbWF0Y2ggaXMgbWFkZSwgb3RoZXJ3aXNlIDEuXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3NLZXlzdHJva2Uob3V0cHV0VGFyZ2V0OiBPdXRwdXRUYXJnZXQsIGtleXN0cm9rZTogS2V5RXZlbnQpOiBSdWxlQmVoYXZpb3Ige1xyXG4gICAgICAvLyBDbGVhciBpbnRlcm5hbCBzdGF0ZSB0cmFja2luZyBkYXRhIGZyb20gcHJpb3Iga2V5c3Ryb2tlcy5cclxuICAgICAgaWYoIW91dHB1dFRhcmdldCkge1xyXG4gICAgICAgIHRocm93IFwiTm8gdGFyZ2V0IHNwZWNpZmllZCBmb3Iga2V5Ym9hcmQgb3V0cHV0IVwiO1xyXG4gICAgICB9IGVsc2UgaWYoIXRoaXMuYWN0aXZlS2V5Ym9hcmQpIHtcclxuICAgICAgICB0aHJvdyBcIk5vIGFjdGl2ZSBrZXlib2FyZCBmb3Iga2V5c3Ryb2tlIHByb2Nlc3NpbmchXCI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG91dHB1dFRhcmdldC5pbnZhbGlkYXRlU2VsZWN0aW9uKCk7XHJcblxyXG4gICAgICBvdXRwdXRUYXJnZXQuZGVhZGtleXMoKS5yZXNldE1hdGNoZWQoKTsgICAgICAgLy8gSTMzMThcclxuICAgICAgdGhpcy5yZXNldENvbnRleHRDYWNoZSgpO1xyXG5cclxuICAgICAgLy8gQ2FwdHVyZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgT3V0cHV0VGFyZ2V0IGJlZm9yZSBhbnkgcnVsZXMgYXJlIG1hdGNoZWQuXHJcbiAgICAgIGxldCBwcmVJbnB1dCA9IE1vY2suZnJvbShvdXRwdXRUYXJnZXQpO1xyXG5cclxuICAgICAgLy8gRXN0YWJsaXNoZXMgdGhlIHJlc3VsdHMgb2JqZWN0LCBhbGxvd2luZyBjb3JyZXNwb25kaW5nIGNvbW1hbmRzIHRvIHNldCB2YWx1ZXMgaGVyZSBhcyBhcHByb3ByaWF0ZS5cclxuICAgICAgdGhpcy5ydWxlQmVoYXZpb3IgPSBuZXcgUnVsZUJlaGF2aW9yKCk7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgdGhlIHNldHRpbmdzIGFyZSBpbiBwbGFjZSBzbyB0aGF0IEtJRlMvaWZTdGF0ZSBhY3RpdmF0ZXMgYW5kIGRlYWN0aXZhdGVzXHJcbiAgICAgIC8vIHRoZSBhcHByb3ByaWF0ZSBydWxlKHMpIGZvciB0aGUgbW9kZWxlZCBkZXZpY2UuXHJcbiAgICAgIHRoaXMuYWN0aXZlRGV2aWNlID0ga2V5c3Ryb2tlLmRldmljZTtcclxuXHJcbiAgICAgIC8vIENhbGxzIHRoZSBzdGFydC1ncm91cCBvZiB0aGUgYWN0aXZlIGtleWJvYXJkLlxyXG4gICAgICB0aGlzLmFjdGl2ZVRhcmdldE91dHB1dCA9IG91dHB1dFRhcmdldDtcclxuICAgICAgdmFyIG1hdGNoZWQgPSB0aGlzLmFjdGl2ZUtleWJvYXJkLnByb2Nlc3Mob3V0cHV0VGFyZ2V0LCBrZXlzdHJva2UpO1xyXG4gICAgICB0aGlzLmFjdGl2ZVRhcmdldE91dHB1dCA9IG51bGw7XHJcblxyXG4gICAgICBpZighbWF0Y2hlZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGaW5hbGl6ZSB0aGUgcnVsZSdzIHJlc3VsdHMuXHJcbiAgICAgIHRoaXMucnVsZUJlaGF2aW9yLnRyYW5zY3JpcHRpb24gPSBvdXRwdXRUYXJnZXQuYnVpbGRUcmFuc2NyaXB0aW9uRnJvbShwcmVJbnB1dCwga2V5c3Ryb2tlKTtcclxuXHJcbiAgICAgIC8vIENsZWFyIG91ciByZXN1bHQtdHJhY2tpbmcgdmFyaWFibGUgdG8gcHJldmVudCBhbnkgcG9zc2libGUgcG9sbHV0aW9uIGZvciBmdXR1cmUgcHJvY2Vzc2luZy5cclxuICAgICAgbGV0IGJlaGF2aW9yID0gdGhpcy5ydWxlQmVoYXZpb3I7XHJcbiAgICAgIHRoaXMucnVsZUJlaGF2aW9yID0gbnVsbDtcclxuXHJcbiAgICAgIHJldHVybiBiZWhhdmlvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFB1Ymxpc2hlcyB0aGUgS2V5Ym9hcmRJbnRlcmZhY2UncyBzaG9ydGhhbmQgQVBJIG5hbWVzLiAgQXMgdGhpcyBhc3NpZ25zIHRoZSBjdXJyZW50IGZ1bmN0aW9uc1xyXG4gICAgICogaGVsZCBieSB0aGUgbG9uZ2Zvcm0gdmVyc2lvbnMsIG5vdGUgdGhhdCB0aGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgcmVwbGFjaW5nIGFueSBvZiB0aGVtIHZpYVxyXG4gICAgICogSlMgbWV0aG9kIGV4dGVuc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBET00tYXdhcmUgS2V5bWFuV2ViIHNob3VsZCBjYWxsIHRoaXMgYWZ0ZXIgaXRzIGRvbUtiZEludGVyZmFjZS50cyBjb2RlIGlzIGxvYWRlZCwgYXMgaXQgcmVwbGFjZXNcclxuICAgICAqIGEgZmV3LiAgKFRoaXMgaXMgY3VycmVudGx5IGRvbmUgd2l0aGluIGl0cyBrbXdhcGkudHMuKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgX19wdWJsaXNoU2hvcnRoYW5kQVBJKCkge1xyXG4gICAgICAvLyBLZXlib2FyZCBjYWxsYmFja3NcclxuICAgICAgbGV0IHByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuICAgICAgdmFyIGV4cG9ydEtCQ2FsbGJhY2sgPSBmdW5jdGlvbihtaW5pTmFtZTogc3RyaW5nLCBsb25nTmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgcHJvdG90eXBlW21pbmlOYW1lXSA9IHByb3RvdHlwZVtsb25nTmFtZV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGV4cG9ydEtCQ2FsbGJhY2soJ0tTRicsICdzYXZlRm9jdXMnKTtcclxuICAgICAgZXhwb3J0S0JDYWxsYmFjaygnS0JSJywgJ2JlZXBSZXNldCcpO1xyXG4gICAgICBleHBvcnRLQkNhbGxiYWNrKCdLVCcsICdpbnNlcnRUZXh0Jyk7XHJcbiAgICAgIGV4cG9ydEtCQ2FsbGJhY2soJ0tSJywgJ3JlZ2lzdGVyS2V5Ym9hcmQnKTtcclxuICAgICAgZXhwb3J0S0JDYWxsYmFjaygnS1JTJywgJ3JlZ2lzdGVyU3R1YicpO1xyXG4gICAgICBleHBvcnRLQkNhbGxiYWNrKCdLQycsICdjb250ZXh0Jyk7XHJcbiAgICAgIGV4cG9ydEtCQ2FsbGJhY2soJ0tOJywgJ251bCcpO1xyXG4gICAgICBleHBvcnRLQkNhbGxiYWNrKCdLQ00nLCAnY29udGV4dE1hdGNoJyk7XHJcbiAgICAgIGV4cG9ydEtCQ2FsbGJhY2soJ0tGQ00nLCAnZnVsbENvbnRleHRNYXRjaCcpO1xyXG4gICAgICBleHBvcnRLQkNhbGxiYWNrKCdLSUsnLCAnaXNLZXlwcmVzcycpO1xyXG4gICAgICBleHBvcnRLQkNhbGxiYWNrKCdLS00nLCAna2V5TWF0Y2gnKTtcclxuICAgICAgZXhwb3J0S0JDYWxsYmFjaygnS1NNJywgJ3N0YXRlTWF0Y2gnKTtcclxuICAgICAgZXhwb3J0S0JDYWxsYmFjaygnS0tJJywgJ2tleUluZm9ybWF0aW9uJyk7XHJcbiAgICAgIGV4cG9ydEtCQ2FsbGJhY2soJ0tETScsICdkZWFka2V5TWF0Y2gnKTtcclxuICAgICAgZXhwb3J0S0JDYWxsYmFjaygnS0InLCAnYmVlcCcpO1xyXG4gICAgICBleHBvcnRLQkNhbGxiYWNrKCdLQScsICdhbnknKTtcclxuICAgICAgZXhwb3J0S0JDYWxsYmFjaygnS0RDJywgJ2RlbGV0ZUNvbnRleHQnKTtcclxuICAgICAgZXhwb3J0S0JDYWxsYmFjaygnS08nLCAnb3V0cHV0Jyk7XHJcbiAgICAgIGV4cG9ydEtCQ2FsbGJhY2soJ0tETycsICdkZWFka2V5T3V0cHV0Jyk7XHJcbiAgICAgIGV4cG9ydEtCQ2FsbGJhY2soJ0tDWE8nLCAnY29udGV4dEV4T3V0cHV0Jyk7XHJcbiAgICAgIGV4cG9ydEtCQ2FsbGJhY2soJ0tJTycsICdpbmRleE91dHB1dCcpO1xyXG4gICAgICBleHBvcnRLQkNhbGxiYWNrKCdLSUZTJywgJ2lmU3RvcmUnKTtcclxuICAgICAgZXhwb3J0S0JDYWxsYmFjaygnS1NFVFMnLCAnc2V0U3RvcmUnKTtcclxuICAgICAgZXhwb3J0S0JDYWxsYmFjaygnS0xPQUQnLCAnbG9hZFN0b3JlJyk7XHJcbiAgICAgIGV4cG9ydEtCQ2FsbGJhY2soJ0tTQVZFJywgJ3NhdmVTdG9yZScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gVGhpcyB3aWxsIGJlIHRoZSBvbmx5IGNhbGwgd2l0aGluIHRoZSBrZXlib2FyZC1wcm9jZXNzb3IgbW9kdWxlLlxyXG4gICAgS2V5Ym9hcmRJbnRlcmZhY2UuX19wdWJsaXNoU2hvcnRoYW5kQVBJKCk7XHJcbiAgfSgpKTtcclxufSIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJkZWZhdWx0TGF5b3V0cy50c1wiIC8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJhY3RpdmVMYXlvdXQudHNcIiAvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vdGV4dC9rYmRJbnRlcmZhY2UudHNcIiAvPlxyXG5cclxubmFtZXNwYWNlIGNvbS5rZXltYW4ua2V5Ym9hcmRzIHtcclxuICAvKipcclxuICAgKiBTdG9yZXMgcHJlcHJvY2Vzc2VkIHByb3BlcnRpZXMgb2YgYSBrZXlib2FyZCBmb3IgcXVpY2sgcmV0cmlldmFsIGxhdGVyLlxyXG4gICAqL1xyXG4gIGNsYXNzIENhY2hlVGFnIHtcclxuICAgIHN0b3Jlczoge1tzdG9yZU5hbWU6IHN0cmluZ106IHRleHQuQ29tcGxleEtleWJvYXJkU3RvcmV9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICB0aGlzLnN0b3JlcyA9IHt9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gTGF5b3V0U3RhdGUge1xyXG4gICAgTk9UX0xPQURFRCA9IHVuZGVmaW5lZCxcclxuICAgIFBPTFlGSUxMRUQgPSAxLFxyXG4gICAgQ0FMSUJSQVRFRCA9IDJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFjdHMgYXMgYSB3cmFwcGVyIGNsYXNzIGZvciBLZXltYW4ga2V5Ym9hcmRzIGNvbXBpbGVkIHRvIEpTLCBwcm92aWRpbmcgdHlwZSBpbmZvcm1hdGlvblxyXG4gICAqIGFuZCBrZXlib2FyZC1jZW50ZXJlZCBmdW5jdGlvbmFsaXR5IGluIGFuIG9iamVjdC1vcmllbnRlZCB3YXkgd2l0aG91dCBtb2RpZnlpbmcgdGhlIFxyXG4gICAqIHdyYXBwZWQga2V5Ym9hcmQgaXRzZWxmLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBLZXlib2FyZCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIERFRkFVTFRfU0NSSVBUX09CSkVDVCA9IHtcclxuICAgICAgJ2dzJzogZnVuY3Rpb24ob3V0cHV0VGFyZ2V0LCBrZXlzdHJva2UpIHsgcmV0dXJuIGZhbHNlOyB9LCAvLyBubyBtYXRjaGluZyBydWxlczsgcmVseSBvbiBkZWZhdWx0UnVsZU91dHB1dCBlbnRpcmVseVxyXG4gICAgICAnS0knOiAnJywgLy8gVGhlIGN1cnJlbnRseS1leGlzdGluZyBkZWZhdWx0IGtleWJvYXJkIElEOyB3ZSBhbHJlYWR5IGhhdmUgY2hlY2tzIHRoYXQgZm9jdXMgYWdhaW5zdCB0aGlzLlxyXG4gICAgICAnS04nOiAnJyxcclxuICAgICAgJ0tWJzogTGF5b3V0cy5ERUZBVUxUX1JBV19TUEVDLFxyXG4gICAgICAnS00nOiAwIC8vIE1heSBub3QgYmUgdGhlIGJlc3QgZGVmYXVsdCwgYnV0IHRoaXMgbWF0Y2hlcyBjdXJyZW50IGJlaGF2aW9yIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlS2V5Ym9hcmQuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBvYmplY3QgcHJvdmlkZWQgdG8gS2V5Ym9hcmRJbnRlcmZhY2UucmVnaXN0ZXJLZXlib2FyZCAtIHRoYXQgaXMsIHRoZSBrZXlib2FyZFxyXG4gICAgICogYmVpbmcgd3JhcHBlZC5cclxuICAgICAqIFxyXG4gICAgICogVE9ETzogIE1ha2UgdGhpcyBwcml2YXRlIGluc3RlYWQuICBCdXQgdGhlcmUgYXJlIGEgTE9UIG9mIHJlZmVyZW5jZXMgdGhhdCBtdXN0IGJlIHJvb3RlZCBvdXQgZmlyc3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBzY3JpcHRPYmplY3Q6IGFueTtcclxuICAgIHByaXZhdGUgbGF5b3V0U3RhdGVzOiB7W2xheW91dDogc3RyaW5nXTogTGF5b3V0U3RhdGV9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGtleWJvYXJkU2NyaXB0OiBhbnkpIHtcclxuICAgICAgaWYoa2V5Ym9hcmRTY3JpcHQpIHtcclxuICAgICAgICB0aGlzLnNjcmlwdE9iamVjdCA9IGtleWJvYXJkU2NyaXB0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2NyaXB0T2JqZWN0ID0gS2V5Ym9hcmQuREVGQVVMVF9TQ1JJUFRfT0JKRUNUO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGF5b3V0U3RhdGVzID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyB0aGUga2V5Ym9hcmQncyBgZ3NgIGZ1bmN0aW9uLCB3aGljaCByZXByZXNlbnRzIHRoZSBrZXlib2FyZCBzb3VyY2UncyBncm91cChtYWluKS5cclxuICAgICAqL1xyXG4gICAgcHJvY2VzcyhvdXRwdXRUYXJnZXQ6IHRleHQuT3V0cHV0VGFyZ2V0LCBrZXlzdHJva2U6IHRleHQuS2V5RXZlbnQpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2NyaXB0T2JqZWN0WydncyddKG91dHB1dFRhcmdldCwga2V5c3Ryb2tlKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgaXNIb2xsb3coKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjcmlwdE9iamVjdCA9PSBLZXlib2FyZC5ERUZBVUxUX1NDUklQVF9PQkpFQ1Q7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGlkKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjcmlwdE9iamVjdFsnS0knXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgbmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY3JpcHRPYmplY3RbJ0tOJ107XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogIEJldHRlciB0eXBpbmcuXHJcbiAgICBwcml2YXRlIGdldCBfbGVnYWN5TGF5b3V0U3BlYygpOiBhbnkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY3JpcHRPYmplY3RbJ0tWJ107ICAvLyB1c2VkIHdpdGggYnVpbGREZWZhdWx0TGF5b3V0OyBsYXlvdXQgbXVzdCBiZSBjb25zdHJ1Y3RlZCBhdCBydW50aW1lLlxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1heSByZXR1cm4gbnVsbCBpZiBubyBsYXlvdXRzIGV4aXN0IG9yIGhhdmUgYmVlbiBpbml0aWFsaXplZC5cclxuICAgIHByaXZhdGUgZ2V0IF9sYXlvdXRzKCk6IHtbZm9ybUZhY3Rvcjogc3RyaW5nXTogTGF5b3V0Rm9ybUZhY3Rvcn0ge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY3JpcHRPYmplY3RbJ0tWS0wnXTsgIC8vIFRoaXMgb25lIGlzIGNvbXBpbGVkIGJ5IERldmVsb3BlcidzIHZpc3VhbCBrZXlib2FyZCBsYXlvdXQgZWRpdG9yLlxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2V0IF9sYXlvdXRzKHZhbHVlKSB7XHJcbiAgICAgIHRoaXMuc2NyaXB0T2JqZWN0WydLVktMJ10gPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY29tcGlsZXJWZXJzaW9uKCk6IHV0aWxzLlZlcnNpb24ge1xyXG4gICAgICByZXR1cm4gbmV3IHV0aWxzLlZlcnNpb24odGhpcy5zY3JpcHRPYmplY3RbJ0tWRVInXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGlzTW5lbW9uaWMoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuc2NyaXB0T2JqZWN0WydLTSddO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBkZWZpbmVzUG9zaXRpb25hbE9yTW5lbW9uaWMoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5zY3JpcHRPYmplY3RbJ0tNJ10gIT0gJ3VuZGVmaW5lZCc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIVE1MIGhlbHAgdGV4dCB3aGljaCBpcyBhIG9uZSBsaW5lciBpbnRlbmRlZCBmb3IgdGhlIHN0YXR1cyBiYXIgb2YgdGhlIGRlc2t0b3AgT1NLIG9yaWdpbmFsbHkuXHJcbiAgICAgKiBcclxuICAgICAqIFJlZmVyZW5jZTogaHR0cHM6Ly9oZWxwLmtleW1hbi5jb20vZGV2ZWxvcGVyL2xhbmd1YWdlL3JlZmVyZW5jZS9rbXdfaGVscHRleHRcclxuICAgICAqL1xyXG4gICAgZ2V0IGhlbHBUZXh0KCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjcmlwdE9iamVjdFsnS0gnXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgaGFzSGVscEhUTUwoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuc2NyaXB0T2JqZWN0WydLSEYnXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcGxhY2VzIHRoZSBPU0sgd2l0aCBjdXN0b20gSFRNTCwgd2hpY2ggbWF5IGJlIGludGVyYWN0aXZlIChsaWtlIHdpdGggc2lsX2V1cm9fbGF0aW4pLlxyXG4gICAgICogXHJcbiAgICAgKiBSZWZlcmVuY2U6IGh0dHBzOi8vaGVscC5rZXltYW4uY29tL2RldmVsb3Blci9sYW5ndWFnZS9yZWZlcmVuY2Uva213X2hlbHBmaWxlXHJcbiAgICAgKi9cclxuICAgIGluc2VydEhlbHBIVE1MKGU6IGFueSkge1xyXG4gICAgICAvLyBlOiAgRXhwZWN0cyB0aGUgT1NLTWFuYWdlcidzIF9Cb3ggZWxlbWVudC4gIFdlIGRvbid0IGFkZCB0eXBlIGluZm8gaGVyZSBiL2MgaXQgd291bGRcclxuICAgICAgLy8gICAgIHJlZmVyZW5jZSB0aGUgRE9NLlxyXG4gICAgICB0aGlzLnNjcmlwdE9iamVjdFsnS0hGJ10oZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG9za1N0eWxpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2NyaXB0T2JqZWN0WydLQ1NTJ107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0cnVlIGlmIHRoaXMga2V5Ym9hcmQgdXNlcyBhIChsZWdhY3kpIHBpY2sgbGlzdCAoQ2hpbmVzZSwgSmFwYW5lc2UsIEtvcmVhbiwgZXRjLilcclxuICAgICAqIFxyXG4gICAgICogVE9ETzogIE1ha2UgYSBwcm9wZXJ0eSBvbiBrZXlib2FyZHMgKHNheSwgYGlzUGlja0xpc3RgIC8gYEtQTGApIHRvIHNpZ25hbCB0aGlzIHdoZW4gd2VcclxuICAgICAqICAgICAgICBnZXQgYXJvdW5kIHRvIGJldHRlciwgZ2VuZXJhbGl6ZWQgcGlja2VyLWxpc3Qgc3VwcG9ydC5cclxuICAgICAqLyAgICBcclxuICAgIGdldCBpc0NKSygpOiBib29sZWFuIHsgLy8gSTMzNjMgKEJ1aWxkIDMwMSlcclxuICAgICAgdmFyIGxnOiBzdHJpbmc7XHJcbiAgICAgIGlmKHR5cGVvZih0aGlzLnNjcmlwdE9iamVjdFsnS0xDJ10pICE9ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgbGcgPSB0aGlzLnNjcmlwdE9iamVjdFsnS0xDJ107XHJcbiAgICAgIH0gZWxzZSBpZih0eXBlb2YodGhpcy5zY3JpcHRPYmplY3RbJ0xhbmd1YWdlQ29kZSddKSAhPSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGxnID0gdGhpcy5zY3JpcHRPYmplY3RbJ0xhbmd1YWdlQ29kZSddO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBXaGlsZSBzb21lIG9mIHRoZXNlIGFyZW4ndCBwcm9wZXIgQkNQLTQ3IGxhbmd1YWdlIGNvZGVzLCB0aGUgQ0pLIGtleWJvYXJkcyBwcmVkYXRlIG91ciB1c2Ugb2YgQkNQLTQ3LlxyXG4gICAgICAvLyBTbywgd2UgcHJlc2VydmUgdGhlIG9sZCBJU08gNjM5LTMgY29kZXMsIGFzIHRoYXQncyB3aGF0IHRoZSBrZXlib2FyZHMgYXJlIG1hdGNoaW5nIGFnYWluc3QuXHJcbiAgICAgIHJldHVybiAoKGxnID09ICdjbW4nKSB8fCAobGcgPT0gJ2pwbicpIHx8IChsZyA9PSAna29yJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBpc1JUTCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5zY3JpcHRPYmplY3RbJ0tSVEwnXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIGN1cnJlbnRseS1hY3RpdmUgbW9kaWZpZXIgYml0bWFzayBmb3IgdGhlIGFjdGl2ZSBrZXlib2FyZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IG1vZGlmaWVyQml0bWFzaygpOiBudW1iZXIge1xyXG4gICAgICAvLyBOT05fQ0hJUkFMIGlzIHRoZSBkZWZhdWx0IGJpdG1hc2sgaWYgS01CTSBpcyBub3QgZGVmaW5lZC5cclxuICAgICAgLy8gV2UgYWx3YXlzIG5lZWQgYSBiaXRtYXNrIHRvIGNvbXBhcmUgYWdhaW5zdCwgYXMgc2VlbiBpbiBgaXNDaGlyYWxgLlxyXG4gICAgICByZXR1cm4gdGhpcy5zY3JpcHRPYmplY3RbJ0tNQk0nXSB8fCB0ZXh0LkNvZGVzLm1vZGlmaWVyQml0bWFza3NbJ05PTl9DSElSQUwnXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgaXNDaGlyYWwoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAhISh0aGlzLm1vZGlmaWVyQml0bWFzayAmIHRleHQuQ29kZXMubW9kaWZpZXJCaXRtYXNrc1snSVNfQ0hJUkFMJ10pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBkZXNrdG9wRm9udCgpOiBzdHJpbmcge1xyXG4gICAgICBpZih0aGlzLnNjcmlwdE9iamVjdFsnS1YnXSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdE9iamVjdFsnS1YnXVsnRiddO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXQgY2FjaGVUYWcoKTogQ2FjaGVUYWcge1xyXG4gICAgICBsZXQgdGFnID0gdGhpcy5zY3JpcHRPYmplY3RbJ19rbXcnXTtcclxuXHJcbiAgICAgIGlmKCF0YWcpIHtcclxuICAgICAgICB0YWcgPSBuZXcgQ2FjaGVUYWcoKTtcclxuICAgICAgICB0aGlzLnNjcmlwdE9iamVjdFsnX2ttdyddID0gdGFnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGFnOyBcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZXhwbG9kZWRTdG9yZXMoKToge1tzdG9yZU5hbWU6IHN0cmluZ106IHRleHQuQ29tcGxleEtleWJvYXJkU3RvcmV9IHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVUYWcuc3RvcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmlmaWVzIHdoZXRoZXIgb3Igbm90IGEgbGF5b3V0IG9yIE9TSyBzaG91bGQgaW5jbHVkZSBBbHRHciAvIFJpZ2h0LWFsdCBlbXVsYXRpb24gZm9yIHRoaXMga2V5Ym9hcmQuXHJcbiAgICAgKiBAcGFyYW0gICB7T2JqZWN0PX0gICBrZXlMYWJlbHNcclxuICAgICAqIEByZXR1cm4gIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBnZXQgZW11bGF0ZXNBbHRHcigpOiBib29sZWFuIHtcclxuICAgICAgbGV0IG1vZGlmaWVyQ29kZXMgPSB0ZXh0LkNvZGVzLm1vZGlmaWVyQ29kZXM7XHJcblxyXG4gICAgICAvLyBJZiB3ZSdyZSBub3QgY2hpcmFsLCB3ZSdyZSBub3QgZW11bGF0aW5nLlxyXG4gICAgICBpZighdGhpcy5pc0NoaXJhbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYodGhpcy5fbGVnYWN5TGF5b3V0U3BlYyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBPbmx5IGV4aXN0cyBpbiBLTVcgMTAuMCssIGJ1dCBiZWZvcmUgdGhhdCBXZWIgaGFkIG5vIGNoaXJhbGl0eSBzdXBwb3J0LCBzby4uLiByZXR1cm4gZmFsc2UuXHJcbiAgICAgIGxldCBsYXllcnMgPSB0aGlzLl9sZWdhY3lMYXlvdXRTcGVjWydLTFMnXTtcclxuICAgICAgaWYoIWxheWVycykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGVtdWxhdGlvbk1hc2sgPSBtb2RpZmllckNvZGVzWydMQ1RSTCddIHwgbW9kaWZpZXJDb2Rlc1snTEFMVCddO1xyXG4gICAgICB2YXIgdW5zaGlmdGVkRW11bGF0aW9uTGF5ZXIgPSBsYXllcnNbTGF5b3V0cy5nZXRMYXllcklkKGVtdWxhdGlvbk1hc2spXTtcclxuICAgICAgdmFyIHNoaWZ0ZWRFbXVsYXRpb25MYXllciA9IGxheWVyc1tMYXlvdXRzLmdldExheWVySWQobW9kaWZpZXJDb2Rlc1snU0hJRlQnXSB8IGVtdWxhdGlvbk1hc2spXTtcclxuICAgICAgXHJcbiAgICAgIC8vIGJ1aWxkRGVmYXVsdExheW91dCBlbnN1cmVzIHRoYXQgdGhlc2UgYXJlIGFsaWFzZWQgdG8gdGhlIG9yaWdpbmFsIG1vZGlmaWVyIHNldCBiZWluZyBlbXVsYXRlZC5cclxuICAgICAgLy8gQXMgYSByZXN1bHQsIHdlIGNhbiBkaXJlY3RseSB0ZXN0IGZvciByZWZlcmVuY2UgZXF1YWxpdHkuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHN0aWxsIHJldHVybiBgdHJ1ZWAgYWZ0ZXIgY3JlYXRpbmcgdGhlIGxheWVycyBmb3IgZW11bGF0aW9uOyBkdXJpbmcga2V5Ym9hcmRcclxuICAgICAgLy8gY29uc3RydWN0aW9uLCB0aGUgdHdvIGxheWVycyBzaG91bGQgYmUgbnVsbCBmb3IgQWx0R3IgZW11bGF0aW9uIHRvIHN1Y2NlZWQuXHJcbiAgICAgIGlmKHVuc2hpZnRlZEVtdWxhdGlvbkxheWVyICE9IG51bGwgJiYgXHJcbiAgICAgICAgICB1bnNoaWZ0ZWRFbXVsYXRpb25MYXllciAhPSBsYXllcnNbTGF5b3V0cy5nZXRMYXllcklkKG1vZGlmaWVyQ29kZXNbJ1JBTFQnXSldKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihzaGlmdGVkRW11bGF0aW9uTGF5ZXIgIT0gbnVsbCAmJiBcclxuICAgICAgICAgIHNoaWZ0ZWRFbXVsYXRpb25MYXllciAhPSBsYXllcnNbTGF5b3V0cy5nZXRMYXllcklkKG1vZGlmaWVyQ29kZXNbJ1JBTFQnXSB8IG1vZGlmaWVyQ29kZXNbJ1NISUZUJ10pXSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSXQncyB0ZWNobmljYWxseSBwb3NzaWJsZSBmb3IgdGhlIE9TSyB0byBub3Qgc3BlY2lmeSBhbnl0aGluZyB3aGlsZSBhbGxvd2luZyBjaGlyYWwgaW5wdXQuICBBIGxhc3QtZGl0Y2ggY2F0Y2g6XHJcbiAgICAgIHZhciBiaXRtYXNrID0gdGhpcy5tb2RpZmllckJpdG1hc2s7XHJcbiAgICAgIGlmKChiaXRtYXNrICYgZW11bGF0aW9uTWFzaykgIT0gZW11bGF0aW9uTWFzaykge1xyXG4gICAgICAgIC8vIEF0IGxlYXN0IG9uZSBvZiB0aGUgZW11bGF0aW9uIG1vZGlmaWVycyBpcyBuZXZlciB1c2VkIGJ5IHRoZSBrZXlib2FyZCEgIFdlIGNhbiBjb25maXJtIGV2ZXJ5dGhpbmcncyBzYWZlLlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZih1bnNoaWZ0ZWRFbXVsYXRpb25MYXllciA9PSBudWxsICYmIHNoaWZ0ZWRFbXVsYXRpb25MYXllciA9PSBudWxsKSB7XHJcbiAgICAgICAgLy8gV2UndmUgcnVuIG91dCBvZiB0aGluZ3MgdG8gZ28gb247IHdlIGNhbid0IGRldGVjdCBpZiBjaGlyYWwgQWx0R3IgZW11bGF0aW9uIGlzIGludGVuZGVkIG9yIG5vdC5cclxuICAgICAgICAvLyBUT0RPOiAgaGFuZGxlIHRoaXMgYWdhaW4hXHJcbiAgICAgICAgLy8gaWYoIW9zay5hbHRHcldhcm5pbmcpIHtcclxuICAgICAgICAvLyAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBkZXRlY3QgaWYgQWx0R3IgZW11bGF0aW9uIGlzIHNhZmUsIGJ1dCBkZWZhdWx0aW5nIHRvIGFjdGl2ZSBlbXVsYXRpb24hXCIpXHJcbiAgICAgICAgLy8gICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSB3aXRoIHdhcm5pbmdzIG9uIGV2ZXJ5IGNhbGwgb2YgdGhlIG1ldGhvZC5cclxuICAgICAgICAvLyAgIG9zay5hbHRHcldhcm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgdXNlc1N1cHBsZW1lbnRhcnlQbGFuZUNoYXJzKCk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQga2JkID0gdGhpcy5zY3JpcHRPYmplY3Q7XHJcbiAgICAgIC8vIEkzMzE5IC0gU01QIGV4dGVuc2lvbiwgSTMzNjMgKEJ1aWxkIDMwMSlcclxuICAgICAgcmV0dXJuIGtiZCAmJiAoKGtiZFsnS1MnXSAmJiBrYmRbJ0tTJ10gPT0gMSkgfHwga2JkWydLTiddID09ICdIaWVyb2dseXBoaWMnKTtcclxuICAgIH1cclxuXHJcbiAgICB1c2VzRGVza3RvcExheW91dE9uRGV2aWNlKGRldmljZTogdXRpbHMuRGV2aWNlU3BlYykge1xyXG4gICAgICBpZih0aGlzLnNjcmlwdE9iamVjdFsnS1ZLTCddKSB7XHJcbiAgICAgICAgLy8gQSBjdXN0b20gbW9iaWxlIGxheW91dCBpcyBkZWZpbmVkLi4uIGJ1dCBhcmUgd2UgdXNpbmcgaXQ/XHJcbiAgICAgICAgcmV0dXJuIGRldmljZS5mb3JtRmFjdG9yID09IHV0aWxzLkZvcm1GYWN0b3IuRGVza3RvcDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgIF9QQ29tbWFuZCAgICAgZXZlbnQgY29kZSAoMTYsMTcsMTgpIG9yIDBcclxuICAgICAqIEBwYXJhbSAgICAgICB7T2JqZWN0fSAgICBfUFRhcmdldCAgICAgIHRhcmdldCBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgX1BEYXRhICAgICAgICAxIG9yIDAgICAgXHJcbiAgICAgKiBOb3RpZmllcyBrZXlib2FyZCBvZiBrZXlzdHJva2Ugb3Igb3RoZXIgZXZlbnRcclxuICAgICAqLyAgICBcclxuICAgIG5vdGlmeShfUENvbW1hbmQ6IG51bWJlciwgX1BUYXJnZXQ6IHRleHQuT3V0cHV0VGFyZ2V0LCBfUERhdGE6IG51bWJlcikgeyAvLyBJMjE4N1xyXG4gICAgICAvLyBHb29kIGV4YW1wbGUgdXNlIGNhc2UgLSB0aGUgSmFwYW5lc2UgQ0pLLXBpY2tlciBrZXlib2FyZFxyXG4gICAgICBpZih0eXBlb2YodGhpcy5zY3JpcHRPYmplY3RbJ0tOUyddKSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhpcy5zY3JpcHRPYmplY3RbJ0tOUyddKF9QQ29tbWFuZCwgX1BUYXJnZXQsIF9QRGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGZpbmRPckNvbnN0cnVjdExheW91dChmb3JtRmFjdG9yOiB1dGlscy5Gb3JtRmFjdG9yKTogTGF5b3V0Rm9ybUZhY3RvciB7XHJcbiAgICAgIGlmKHRoaXMuX2xheW91dHMpIHtcclxuICAgICAgICAvLyBTZWFyY2ggZm9yIHZpYWJsZSBsYXlvdXRzLiAgYG51bGxgIGlzIGFsbG93ZWQgZm9yIGRlc2t0b3AgZm9ybSBmYWN0b3JzIHdoZW4gaGVscCB0ZXh0IGlzIGF2YWlsYWJsZSxcclxuICAgICAgICAvLyBzbyB3ZSBjaGVjayBleHBsaWNpdGx5IGFnYWluc3QgYHVuZGVmaW5lZGAuXHJcbiAgICAgICAgaWYodGhpcy5fbGF5b3V0c1tmb3JtRmFjdG9yXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0c1tmb3JtRmFjdG9yXTtcclxuICAgICAgICB9IGVsc2UgaWYoZm9ybUZhY3RvciA9PSB1dGlscy5Gb3JtRmFjdG9yLlBob25lICYmIHRoaXMuX2xheW91dHNbdXRpbHMuRm9ybUZhY3Rvci5UYWJsZXRdKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0c1t1dGlscy5Gb3JtRmFjdG9yLlBob25lXSA9IHRoaXMuX2xheW91dHNbdXRpbHMuRm9ybUZhY3Rvci5UYWJsZXRdO1xyXG4gICAgICAgIH0gZWxzZSBpZihmb3JtRmFjdG9yID09IHV0aWxzLkZvcm1GYWN0b3IuVGFibGV0ICYmIHRoaXMuX2xheW91dHNbdXRpbHMuRm9ybUZhY3Rvci5QaG9uZV0pIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXRzW3V0aWxzLkZvcm1GYWN0b3IuVGFibGV0XSA9IHRoaXMuX2xheW91dHNbdXRpbHMuRm9ybUZhY3Rvci5QaG9uZV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBwcmUtYnVpbHQgbGF5b3V0IGF2YWlsYWJsZTsgdGltZSB0byBzdGFydCBjb25zdHJ1Y3RpbmcgaXQgdmlhIGRlZmF1bHRzLlxyXG4gICAgICAvLyBGaXJzdCwgaWYgd2UgaGF2ZSBub24tZGVmYXVsdCBrZXlzIHNwZWNpZmllZCBieSB0aGUgWydCSyddIGFycmF5LCB3ZSd2ZSBnb3RcclxuICAgICAgLy8gZW5vdWdoIHRvIHdvcmsgd2l0aCB0byBidWlsZCBhIGRlZmF1bHQgbGF5b3V0LlxyXG4gICAgICBsZXQgcmF3U3BlY2lmaWNhdGlvbnM6IGFueSA9IG51bGw7ICAvLyBUT0RPOiAgYmV0dGVyIHR5cGluZywgc2FtZSB0eXBlIGFzIHRoaXMuX2xlZ2FjeUxheW91dFNwZWMuXHJcbiAgICAgIGlmKHRoaXMuX2xlZ2FjeUxheW91dFNwZWMgIT0gbnVsbCAmJiB0aGlzLl9sZWdhY3lMYXlvdXRTcGVjWydLTFMnXSkgeyAvLyBLTFMgaXMgb25seSBzcGVjaWZpZWQgd2hlbmV2ZXIgdGhlcmUgYXJlIG5vbi1kZWZhdWx0IGtleXMuXHJcbiAgICAgICAgcmF3U3BlY2lmaWNhdGlvbnMgPSB0aGlzLl9sZWdhY3lMYXlvdXRTcGVjO1xyXG4gICAgICB9IGVsc2UgaWYodGhpcy5fbGVnYWN5TGF5b3V0U3BlYyAhPSBudWxsICYmIHRoaXMuX2xlZ2FjeUxheW91dFNwZWNbJ0JLJ10gIT0gbnVsbCkge1xyXG4gICAgICAgIHZhciBrZXlDYXBzPXRoaXMuX2xlZ2FjeUxheW91dFNwZWNbJ0JLJ107XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8a2V5Q2Fwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYoa2V5Q2Fwc1tpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJhd1NwZWNpZmljYXRpb25zID0gdGhpcy5fbGVnYWN5TGF5b3V0U3BlYztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGtleSBkZWZpbml0aW9ucyB0byB1c2UgZm9yIGEgbGF5b3V0IGJ1dCBhbHNvIGxhY2sgaGVscCB0ZXh0IG9yIGFyZSBhIHRvdWNoLWJhc2VkIGxheW91dCxcclxuICAgICAgLy8gd2UgbWFrZSBhIGRlZmF1bHQgbGF5b3V0IGFueXdheS4gIFdlIGhhdmUgdG8gc2hvdyBkaXNwbGF5IHNvbWV0aGluZyB1c2FibGUuXHJcbiAgICAgIGlmKCFyYXdTcGVjaWZpY2F0aW9ucyAmJiAodGhpcy5oZWxwVGV4dCA9PSAnJyB8fCBmb3JtRmFjdG9yICE9IHV0aWxzLkZvcm1GYWN0b3IuRGVza3RvcCkpIHtcclxuICAgICAgICByYXdTcGVjaWZpY2F0aW9ucyA9IHsnRic6J1RhaG9tYScsICdCSyc6IExheW91dHMuZGZsdFRleHR9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZWdhcmRsZXNzIG9mIHN1Y2Nlc3MsIHdlJ2xsIHdhbnQgdG8gaW5pdGlhbGl6ZSB0aGUgZmllbGQgdGhhdCBiYWNrcyB0aGUgcHJvcGVydHk7IFxyXG4gICAgICAvLyBtYXkgYXMgd2VsbCBjYWNoZSB0aGUgZGVmYXVsdCBsYXlvdXQgd2UganVzdCBidWlsdCwgb3IgYSAnbnVsbCcgaWYgaXQgc2hvdWxkbid0IGV4aXN0Li5cclxuICAgICAgaWYoIXRoaXMuX2xheW91dHMpIHtcclxuICAgICAgICB0aGlzLl9sYXlvdXRzID0ge307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZpbmFsIGNoZWNrIC0gZG8gd2UgY29uc3RydWN0IGEgbGF5b3V0LCBvciBpcyB0aGlzIGEgY2FzZSB3aGVyZSBoZWxwVGV4dCAvIGluc2VydEhlbHBIVE1MIHNob3VsZCB0YWtlIG92ZXI/XHJcbiAgICAgIGlmKHJhd1NwZWNpZmljYXRpb25zKSB7XHJcbiAgICAgICAgLy8gTm93IHRvIGdlbmVyYXRlIGEgbGF5b3V0IGZyb20gb3VyIHJhdyBzcGVjaWZpY2F0aW9ucy5cclxuICAgICAgICBsZXQgbGF5b3V0ID0gdGhpcy5fbGF5b3V0c1tmb3JtRmFjdG9yXSA9IExheW91dHMuYnVpbGREZWZhdWx0TGF5b3V0KHJhd1NwZWNpZmljYXRpb25zLCB0aGlzLCBmb3JtRmFjdG9yKTtcclxuICAgICAgICBsYXlvdXQuaXNEZWZhdWx0ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gbGF5b3V0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBmYWN0IHRoYXQgaXQgZG9lc24ndCBleGlzdCB3aWxsIGluZGljYXRlIHRoYXQgaGVscCB0ZXh0L0hUTUwgc2hvdWxkIGJlIGluc2VydGVkIGluc3RlYWQuXHJcbiAgICAgICAgdGhpcy5fbGF5b3V0c1tmb3JtRmFjdG9yXSA9IG51bGw7IC8vIHByb3ZpZGVzIGEgY2FjaGVkIHZhbHVlIGZvciB0aGUgY2hlY2sgYXQgdGhlIHRvcCBvZiB0aGlzIG1ldGhvZC5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBBY3RpdmVMYXlvdXQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUga2V5Ym9hcmQncyBsYXlvdXQgZm9yIHRoaXMgZm9ybSBmYWN0b3IuICBNYXkgcmV0dXJuIG51bGwgaWYgYSBjdXN0b20gZGVza3RvcCBcImhlbHBcIiBPU0sgaXMgZGVmaW5lZCwgYXMgd2l0aCBzaWxfZXVyb19sYXRpbi5cclxuICAgICAqIFxyXG4gICAgICogSW4gc3VjaCBjYXNlcywgcGxlYXNlIHVzZSBlaXRoZXIgYGhlbHBUZXh0YCBvciBgaW5zZXJ0SGVscEhUTUxgIGluc3RlYWQuXHJcbiAgICAgKiBAcGFyYW0gZm9ybUZhY3RvciB7c3RyaW5nfSBUaGUgZGVzaXJlZCBmb3JtIGZhY3RvciBmb3IgdGhlIGxheW91dC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGxheW91dChmb3JtRmFjdG9yOiB1dGlscy5Gb3JtRmFjdG9yKTogQWN0aXZlTGF5b3V0IHtcclxuICAgICAgbGV0IHJhd0xheW91dCA9IHRoaXMuZmluZE9yQ29uc3RydWN0TGF5b3V0KGZvcm1GYWN0b3IpO1xyXG5cclxuICAgICAgaWYocmF3TGF5b3V0KSB7XHJcbiAgICAgICAgLy8gUHJldmVudHMgYWNjaWRlbnRhbGx5IHJlcHJvY2Vzc2luZyBsYXlvdXRzOyBpdCdzIGEgc2ltcGxlIGVub3VnaCBjaGVjay5cclxuICAgICAgICBpZih0aGlzLmxheW91dFN0YXRlc1tmb3JtRmFjdG9yXSA9PSBMYXlvdXRTdGF0ZS5OT1RfTE9BREVEKSB7XHJcbiAgICAgICAgICByYXdMYXlvdXQgPSBBY3RpdmVMYXlvdXQucG9seWZpbGwocmF3TGF5b3V0LCB0aGlzLCBmb3JtRmFjdG9yKTtcclxuICAgICAgICAgIHRoaXMubGF5b3V0U3RhdGVzW2Zvcm1GYWN0b3JdID0gTGF5b3V0U3RhdGUuUE9MWUZJTExFRDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByYXdMYXlvdXQgYXMgQWN0aXZlTGF5b3V0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlZnJlc2hMYXlvdXRzKCkge1xyXG4gICAgICBsZXQgZm9ybUZhY3RvcnMgPSBbIHV0aWxzLkZvcm1GYWN0b3IuRGVza3RvcCwgdXRpbHMuRm9ybUZhY3Rvci5QaG9uZSwgdXRpbHMuRm9ybUZhY3Rvci5UYWJsZXQgXTtcclxuXHJcbiAgICAgIGxldCBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICBmb3JtRmFjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGZvcm0pIHtcclxuICAgICAgICAvLyBDdXJyZW50bHkgZG9lc24ndCB3b3JrIGlmIHdlIHJlc2V0IGl0IHRvIFBPTFlGSUxMRUQsIGxpa2VseSBkdWUgdG8gaG93ICdjYWxpYnJhdGlvbidcclxuICAgICAgICAvLyBjdXJyZW50bHkgd29ya3MuXHJcbiAgICAgICAgX3RoaXMubGF5b3V0U3RhdGVzW2Zvcm1dID0gTGF5b3V0U3RhdGUuTk9UX0xPQURFRDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG1hcmtMYXlvdXRDYWxpYnJhdGVkKGZvcm1GYWN0b3I6IHV0aWxzLkZvcm1GYWN0b3IpIHtcclxuICAgICAgaWYodGhpcy5sYXlvdXRTdGF0ZXNbZm9ybUZhY3Rvcl0gIT0gTGF5b3V0U3RhdGUuTk9UX0xPQURFRCkge1xyXG4gICAgICAgIHRoaXMubGF5b3V0U3RhdGVzW2Zvcm1GYWN0b3JdID0gTGF5b3V0U3RhdGUuQ0FMSUJSQVRFRDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRMYXlvdXRTdGF0ZShmb3JtRmFjdG9yOiB1dGlscy5Gb3JtRmFjdG9yKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmxheW91dFN0YXRlc1tmb3JtRmFjdG9yXTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvKioqXHJcbiAgIEtleW1hbldlYiAxMS4wXHJcbiAgIENvcHlyaWdodCAyMDE5IFNJTCBJbnRlcm5hdGlvbmFsXHJcbioqKi9cclxubmFtZXNwYWNlIGNvbS5rZXltYW4ge1xyXG5cclxuICBjbGFzcyBLZXlNYXAge1xyXG4gICAgW2tleWNvZGU6IHN0cmluZ106IG51bWJlcjtcclxuICB9XHJcblxyXG4gIGNsYXNzIEJyb3dzZXJLZXlNYXBzIHtcclxuICAgIEZGOiAgICAgS2V5TWFwID0gbmV3IEtleU1hcCgpO1xyXG4gICAgU2FmYXJpOiBLZXlNYXAgPSBuZXcgS2V5TWFwKCk7XHJcbiAgICBPcGVyYTogIEtleU1hcCA9IG5ldyBLZXlNYXAoKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgLy8gQWxsIHRocmVlIGhhdmUgYmVlbiBhcm91bmQgc2luY2UgYXQgbGVhc3QgTWF5IDIwMTQgLyBGRiAyOS5cclxuICAgICAgLy8gSXQnZCBoYXJkIHRvIGZpbmQgcHJlY2lzZSBoaXN0b3J5LCBidXQgYXQgbGVhc3QgdGhhdCBtdWNoIGhhcyBiZWVuIGNvbmZpcm1lZC5cclxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5Q29kZSwgb24gRmViIDI2IDIwMjEuXHJcbiAgICAgIHRoaXMuRkZbJ2s2MSddID0gMTg3OyAgLy8gPSAgIC8vIEZGIDIuMFxyXG4gICAgICB0aGlzLkZGWydrNTknXSA9IDE4NjsgIC8vIDtcclxuICAgICAgdGhpcy5GRlsnazE3MyddID0gMTg5OyAvLyAtL19cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNsYXNzIExhbmd1YWdlS2V5TWFwcyB7XHJcbiAgICBbbGFuZ3VhZ2VDb2RlOiBzdHJpbmddOiBLZXlNYXA7XHJcblxyXG4gICAgLy8gLy8gSGVyZSBhcmUgc29tZSBvbGQgbGVnYWN5IGRlZmluaXRpb25zIHRoYXQgd2VyZSBubyBsb25nZXIgcmVmZXJlbmNlZCBidXQgYXJlIGxpa2VseSByZWxhdGVkOlxyXG4gICAgLy8gc3RhdGljIF9CYXNlTGF5b3V0RXVybzoge1tjb2RlOiBzdHJpbmddOiBzdHJpbmd9ID0ge1xyXG4gICAgLy8gICAnc2UnOiAnXFx1MDBhNzEyMzQ1Njc4OTArwrR+fn5RV0VSVFlVSU9QXFx1MDBjNVxcdTAwYThcXCd+fn5BU0RGR0hKS0xcXHUwMGQ2XFx1MDBjNH5+fn5+PFpYQ1ZCTk0sLi1+fn5+fiAnLCAgLy8gU3dlZGlzaFxyXG4gICAgLy8gICAndWsnOiAnYDEyMzQ1Njc4OTAtPX5+flFXRVJUWVVJT1BbXSN+fn5BU0RGR0hKS0w7XFwnfn5+fn5cXFxcWlhDVkJOTSwuL35+fn5+ICcgLy8gVUtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgLyogSTczMiBTVEFSVCAtIDEzLzAzLzIwMDcgTUNEOiBTd2VkaXNoOiBTdGFydCBtYXBwaW5nIG9mIGtleXN0cm9rZSB0byBVUyBrZXlib2FyZCAjMiAqL1xyXG4gICAgICAvLyBTd2VkaXNoIGtleSBtYXBcclxuICAgICAgdGhpc1snc2UnXSA9IG5ldyBLZXlNYXAoKTtcclxuICAgICAgdGhpc1snc2UnXVsnazIyMCddID0gIDE5MjsgLy8gYFxyXG4gICAgICB0aGlzWydzZSddWydrMTg3J10gPSAgMTg5OyAvLyAtXHJcbiAgICAgIHRoaXNbJ3NlJ11bJ2syMTknXSA9ICAxODc7IC8vID1cclxuICAgICAgdGhpc1snc2UnXVsnazIyMSddID0gIDIxOTsgLy8gW1xyXG4gICAgICB0aGlzWydzZSddWydrMTg2J10gPSAgMjIxOyAvLyBdXHJcbiAgICAgIHRoaXNbJ3NlJ11bJ2sxOTEnXSA9ICAyMjA7IC8vIFxcXHJcbiAgICAgIHRoaXNbJ3NlJ11bJ2sxOTInXSA9ICAxODY7IC8vIDtcclxuICAgICAgdGhpc1snc2UnXVsnazE4OSddID0gIDE5MTsgLy8gL1xyXG5cclxuICAgICAgdGhpc1sndWsnXSA9IG5ldyBLZXlNYXAoKTsgIC8vIEkxMjk5XHJcbiAgICAgIHRoaXNbJ3VrJ11bJ2syMjMnXSA9ICAxOTI7IC8vIC8vIGAgVSswMEFDIChsb2dpY2FsIG5vdCkgPT4gIGAgflxyXG4gICAgICB0aGlzWyd1ayddWydrMTkyJ10gPSAgMjIyOyAvLyAnIEAgID0+ICAnIFwiXHJcbiAgICAgIHRoaXNbJ3VrJ11bJ2syMjInXSA9ICAyMjY7IC8vICMgfiAgPT4gS19vRTIgICAgIC8vIEkxNTA0IC0gVUsga2V5Ym9hcmQgbWl4dXAgIywgXFxcclxuICAgICAgdGhpc1sndWsnXVsnazIyMCddID0gIDIyMDsgLy8gXFwgfCAgPT4gXFwgfCAgICAgICAvLyBJMTUwNCAtIFVLIGtleWJvYXJkIG1peHVwICMsIFxcXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgS2V5TWFwcGluZyB7XHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgYnJvd3Nlck1hcDogQnJvd3NlcktleU1hcHMgPSBuZXcgQnJvd3NlcktleU1hcHMoKTtcclxuICAgIHN0YXRpYyByZWFkb25seSBsYW5ndWFnZU1hcDogTGFuZ3VhZ2VLZXlNYXBzID0gbmV3IExhbmd1YWdlS2V5TWFwcygpO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF91c0NoYXJDb2RlczogS2V5TWFwW107XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgLy8gRG8gbm90IGNvbnN0cnVjdCB0aGlzIGNsYXNzLlxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF91c0NvZGVJbml0KCkge1xyXG4gICAgICB2YXIgczA9bmV3IEtleU1hcCgpLHMxPW5ldyBLZXlNYXAoKTtcclxuXHJcbiAgICAgIHMwWydrMTkyJ10gPSA5NjtcclxuICAgICAgczBbJ2s0OSddID0gNDk7XHJcbiAgICAgIHMwWydrNTAnXSA9IDUwO1xyXG4gICAgICBzMFsnazUxJ10gPSA1MTtcclxuICAgICAgczBbJ2s1MiddID0gNTI7XHJcbiAgICAgIHMwWydrNTMnXSA9IDUzO1xyXG4gICAgICBzMFsnazU0J10gPSA1NDtcclxuICAgICAgczBbJ2s1NSddID0gNTU7XHJcbiAgICAgIHMwWydrNTYnXSA9IDU2O1xyXG4gICAgICBzMFsnazU3J10gPSA1NztcclxuICAgICAgczBbJ2s0OCddID0gNDg7XHJcbiAgICAgIHMwWydrMTg5J10gPSA0NTtcclxuICAgICAgczBbJ2sxODcnXSA9IDYxO1xyXG4gICAgICBzMFsnazgxJ10gPSAxMTM7XHJcbiAgICAgIHMwWydrODcnXSA9IDExOTtcclxuICAgICAgczBbJ2s2OSddID0gMTAxO1xyXG4gICAgICBzMFsnazgyJ10gPSAxMTQ7XHJcbiAgICAgIHMwWydrODQnXSA9IDExNjtcclxuICAgICAgczBbJ2s4OSddID0gMTIxO1xyXG4gICAgICBzMFsnazg1J10gPSAxMTc7XHJcbiAgICAgIHMwWydrNzMnXSA9IDEwNTtcclxuICAgICAgczBbJ2s3OSddID0gMTExO1xyXG4gICAgICBzMFsnazgwJ10gPSAxMTI7XHJcbiAgICAgIHMwWydrMjE5J10gPSA5MTtcclxuICAgICAgczBbJ2syMjEnXSA9IDkzO1xyXG4gICAgICBzMFsnazIyMCddID0gOTI7XHJcbiAgICAgIHMwWydrNjUnXSA9IDk3O1xyXG4gICAgICBzMFsnazgzJ10gPSAxMTU7XHJcbiAgICAgIHMwWydrNjgnXSA9IDEwMDtcclxuICAgICAgczBbJ2s3MCddID0gMTAyO1xyXG4gICAgICBzMFsnazcxJ10gPSAxMDM7XHJcbiAgICAgIHMwWydrNzInXSA9IDEwNDtcclxuICAgICAgczBbJ2s3NCddID0gMTA2O1xyXG4gICAgICBzMFsnazc1J10gPSAxMDc7XHJcbiAgICAgIHMwWydrNzYnXSA9IDEwODtcclxuICAgICAgczBbJ2sxODYnXSA9IDU5O1xyXG4gICAgICBzMFsnazIyMiddID0gMzk7XHJcbiAgICAgIHMwWydrOTAnXSA9IDEyMjtcclxuICAgICAgczBbJ2s4OCddID0gMTIwO1xyXG4gICAgICBzMFsnazY3J10gPSA5OTtcclxuICAgICAgczBbJ2s4NiddID0gMTE4O1xyXG4gICAgICBzMFsnazY2J10gPSA5ODtcclxuICAgICAgczBbJ2s3OCddID0gMTEwO1xyXG4gICAgICBzMFsnazc3J10gPSAxMDk7XHJcbiAgICAgIHMwWydrMTg4J10gPSA0NDtcclxuICAgICAgczBbJ2sxOTAnXSA9IDQ2O1xyXG4gICAgICBzMFsnazE5MSddID0gNDc7XHJcblxyXG4gICAgICBzMVsnazE5MiddID0gMTI2O1xyXG4gICAgICBzMVsnazQ5J10gPSAzMztcclxuICAgICAgczFbJ2s1MCddID0gNjQ7XHJcbiAgICAgIHMxWydrNTEnXSA9IDM1O1xyXG4gICAgICBzMVsnazUyJ10gPSAzNjtcclxuICAgICAgczFbJ2s1MyddID0gMzc7XHJcbiAgICAgIHMxWydrNTQnXSA9IDk0O1xyXG4gICAgICBzMVsnazU1J10gPSAzODtcclxuICAgICAgczFbJ2s1NiddID0gNDI7XHJcbiAgICAgIHMxWydrNTcnXSA9IDQwO1xyXG4gICAgICBzMVsnazQ4J10gPSA0MTtcclxuICAgICAgczFbJ2sxODknXSA9IDk1O1xyXG4gICAgICBzMVsnazE4NyddID0gNDM7XHJcbiAgICAgIHMxWydrODEnXSA9IDgxO1xyXG4gICAgICBzMVsnazg3J10gPSA4NztcclxuICAgICAgczFbJ2s2OSddID0gNjk7XHJcbiAgICAgIHMxWydrODInXSA9IDgyO1xyXG4gICAgICBzMVsnazg0J10gPSA4NDtcclxuICAgICAgczFbJ2s4OSddID0gODk7XHJcbiAgICAgIHMxWydrODUnXSA9IDg1O1xyXG4gICAgICBzMVsnazczJ10gPSA3MztcclxuICAgICAgczFbJ2s3OSddID0gNzk7XHJcbiAgICAgIHMxWydrODAnXSA9IDgwO1xyXG4gICAgICBzMVsnazIxOSddID0gMTIzO1xyXG4gICAgICBzMVsnazIyMSddID0gMTI1O1xyXG4gICAgICBzMVsnazIyMCddID0gMTI0O1xyXG4gICAgICBzMVsnazY1J10gPSA2NTtcclxuICAgICAgczFbJ2s4MyddID0gODM7XHJcbiAgICAgIHMxWydrNjgnXSA9IDY4O1xyXG4gICAgICBzMVsnazcwJ10gPSA3MDtcclxuICAgICAgczFbJ2s3MSddID0gNzE7XHJcbiAgICAgIHMxWydrNzInXSA9IDcyO1xyXG4gICAgICBzMVsnazc0J10gPSA3NDtcclxuICAgICAgczFbJ2s3NSddID0gNzU7XHJcbiAgICAgIHMxWydrNzYnXSA9IDc2O1xyXG4gICAgICBzMVsnazE4NiddID0gNTg7XHJcbiAgICAgIHMxWydrMjIyJ10gPSAzNDtcclxuICAgICAgczFbJ2s5MCddID0gOTA7XHJcbiAgICAgIHMxWydrODgnXSA9IDg4O1xyXG4gICAgICBzMVsnazY3J10gPSA2NztcclxuICAgICAgczFbJ2s4NiddID0gODY7XHJcbiAgICAgIHMxWydrNjYnXSA9IDY2O1xyXG4gICAgICBzMVsnazc4J10gPSA3ODtcclxuICAgICAgczFbJ2s3NyddID0gNzc7XHJcbiAgICAgIHMxWydrMTg4J10gPSA2MDtcclxuICAgICAgczFbJ2sxOTAnXSA9IDYyO1xyXG4gICAgICBzMVsnazE5MSddID0gNjM7XHJcblxyXG4gICAgICBLZXlNYXBwaW5nLl91c0NoYXJDb2RlcyA9IFtzMCxzMV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiAgICAgX1VTS2V5Q29kZVRvQ2hhckNvZGVcclxuICAgICAqIFNjb3BlICAgICAgICBQcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gICAgICAge0V2ZW50fSAgICAgTGV2ZW50ICAgICAgS01XIGV2ZW50IG9iamVjdFxyXG4gICAgICogQHJldHVybiAgICAgIHtudW1iZXJ9ICAgICAgICAgICAgICAgIENoYXJhY3RlciBjb2RlIFxyXG4gICAgICogRGVzY3JpcHRpb24gVHJhbnNsYXRlIGtleWJvYXJkIGNvZGVzIHRvIHN0YW5kYXJkIFVTIGxheW91dCBjb2Rlc1xyXG4gICAgICovICAgIFxyXG4gICAgc3RhdGljIF9VU0tleUNvZGVUb0NoYXJDb2RlKExldmVudDogY29tLmtleW1hbi50ZXh0LktleUV2ZW50KSB7XHJcbiAgICAgIHJldHVybiBLZXlNYXBwaW5nLnVzQ2hhckNvZGVzW0xldmVudC5MbW9kaWZpZXJzICYgMHgxMCA/IDEgOiAwXVsnaycrTGV2ZW50Lkxjb2RlXTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgdXNDaGFyQ29kZXMoKSB7XHJcbiAgICAgIGlmKCFLZXlNYXBwaW5nLl91c0NoYXJDb2Rlcykge1xyXG4gICAgICAgIEtleU1hcHBpbmcuX3VzQ29kZUluaXQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIEtleU1hcHBpbmcuX3VzQ2hhckNvZGVzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIEVzdGFibGlzaGVzIGtleS1jb2RlIGRlZmluaXRpb25zLlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiY29kZXMudHNcIiAvPlxyXG4vLyBEZWZpbmVzIG91ciBnZW5lcmFsaXplZCBcIktleUV2ZW50XCIgY2xhc3MuXHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJrZXlFdmVudC50c1wiIC8+XHJcbi8vIERlZmluZXMgdGhlIFJ1bGVCZWhhdmlvciBrZXlib2FyZC1wcm9jZXNzaW5nIHJldHVybiBvYmplY3QuXHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJydWxlQmVoYXZpb3IudHNcIiAvPlxyXG4vLyBEZWZpbmVzIGRlZmF1bHQga2V5IGhhbmRsaW5nIGJlaGF2aW9ycy5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cImRlZmF1bHRPdXRwdXQudHNcIiAvPlxyXG4vLyBEZWZpbmVzIHRoZSBrZXlib2FyZCB3cmFwcGVyIG9iamVjdC5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2tleWJvYXJkcy9rZXlib2FyZC50c1wiIC8+XHJcbi8vIERlZmluZXMgYnVpbHQtaW4ga2V5bWFwcGluZy5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cImtleU1hcHBpbmcudHNcIiAvPlxyXG5cclxuLy8gQWxzbyByZWxpZXMgb24gQGtleW1hbmFwcC93ZWItdXRpbHMsIHdoaWNoIGlzIGluY2x1ZGVkIHZpYSB0c2NvbmZpZy5qc29uLlxyXG5cclxubmFtZXNwYWNlIGNvbS5rZXltYW4udGV4dCB7XHJcbiAgZXhwb3J0IHR5cGUgQmVlcEhhbmRsZXIgPSAob3V0cHV0VGFyZ2V0OiBPdXRwdXRUYXJnZXQpID0+IHZvaWQ7XHJcbiAgZXhwb3J0IHR5cGUgTG9nTWVzc2FnZUhhbmRsZXIgPSAoc3RyOiBzdHJpbmcpID0+IHZvaWQ7XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgVmFyaWFibGVTdG9yZVNlcmlhbGl6ZXIge1xyXG4gICAgbG9hZFN0b3JlKGtleWJvYXJkSUQ6IHN0cmluZywgc3RvcmVOYW1lOiBzdHJpbmcpOiBWYXJpYWJsZVN0b3JlO1xyXG4gICAgc2F2ZVN0b3JlKGtleWJvYXJkSUQ6IHN0cmluZywgc3RvcmVOYW1lOiBzdHJpbmcsIHN0b3JlTWFwOiBWYXJpYWJsZVN0b3JlKTtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc29ySW5pdE9wdGlvbnMge1xyXG4gICAgYmFzZUxheW91dD86IHN0cmluZztcclxuICAgIHZhcmlhYmxlU3RvcmVTZXJpYWxpemVyPzogVmFyaWFibGVTdG9yZVNlcmlhbGl6ZXI7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgS2V5Ym9hcmRQcm9jZXNzb3Ige1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUZBVUxUX09QVElPTlM6IFByb2Nlc3NvckluaXRPcHRpb25zID0ge1xyXG4gICAgICBiYXNlTGF5b3V0OiAndXMnXHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJhY2tzIHRoZSBzaW11bGF0ZWQgdmFsdWUgZm9yIHN1cHBvcnRlZCBzdGF0ZSBrZXlzLCBhbGxvd2luZyB0aGUgT1NLIHRvIG1pcnJvciBhIHBoeXNpY2FsIGtleWJvYXJkIGZvciB0aGVtLlxyXG4gICAgLy8gVXNpbmcgdGhlIGV4YWN0IGtleUNvZGUgbmFtZSBmcm9tIHRoZSBDb2RlcyBkZWZpbml0aW9ucyB3aWxsIGFsbG93IGZvciBjZXJ0YWluIG9wdGltaXphdGlvbnMgZWxzZXdoZXJlIGluIHRoZSBjb2RlLlxyXG4gICAgc3RhdGVLZXlzID0ge1xyXG4gICAgICBcIktfQ0FQU1wiOmZhbHNlLFxyXG4gICAgICBcIktfTlVNTE9DS1wiOmZhbHNlLFxyXG4gICAgICBcIktfU0NST0xMXCI6ZmFsc2VcclxuICAgIH07XHJcblxyXG4gICAgLy8gVHJhY2tzIHRoZSBtb3N0IHJlY2VudCBtb2RpZmllciBzdGF0ZSBpbmZvcm1hdGlvbiBpbiBvcmRlciB0byBxdWlja2x5IGRldGVjdCBjaGFuZ2VzXHJcbiAgICAvLyBpbiBrZXlib2FyZCBzdGF0ZSBub3Qgb3RoZXJ3aXNlIGNhcHR1cmVkIGJ5IHRoZSBob3N0aW5nIHBhZ2UgaW4gdGhlIGJyb3dzZXIuXHJcbiAgICAvLyBOZWVkZWQgZm9yIEFsdEdyIHNpbXVsYXRpb24uXHJcbiAgICBtb2RTdGF0ZUZsYWdzOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGtleWJvYXJkSW50ZXJmYWNlOiBLZXlib2FyZEludGVyZmFjZTtcclxuXHJcbiAgICBiYXNlTGF5b3V0OiBzdHJpbmc7XHJcblxyXG4gICAgLy8gQ2FsbGJhY2tzIGZvciB2YXJpb3VzIGZlZWRiYWNrIHR5cGVzXHJcbiAgICBiZWVwSGFuZGxlcj86IEJlZXBIYW5kbGVyO1xyXG4gICAgd2FybmluZ0xvZ2dlcj86IExvZ01lc3NhZ2VIYW5kbGVyO1xyXG4gICAgZXJyb3JMb2dnZXI/OiBMb2dNZXNzYWdlSGFuZGxlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zPzogUHJvY2Vzc29ySW5pdE9wdGlvbnMpIHtcclxuICAgICAgaWYoIW9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gS2V5Ym9hcmRQcm9jZXNzb3IuREVGQVVMVF9PUFRJT05TO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmJhc2VMYXlvdXQgPSBvcHRpb25zLmJhc2VMYXlvdXQgfHwgS2V5Ym9hcmRQcm9jZXNzb3IuREVGQVVMVF9PUFRJT05TLmJhc2VMYXlvdXQ7XHJcbiAgICAgIHRoaXMua2V5Ym9hcmRJbnRlcmZhY2UgPSBuZXcgS2V5Ym9hcmRJbnRlcmZhY2Uob3B0aW9ucy52YXJpYWJsZVN0b3JlU2VyaWFsaXplcik7XHJcbiAgICAgIHRoaXMuaW5zdGFsbEludGVyZmFjZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5zdGFsbEludGVyZmFjZSgpIHtcclxuICAgICAgLy8gV2UgbXVzdCBlbnN1cmUgdGhhdCB0aGUga2V5Ym9hcmQgY2FuIGZpbmQgdGhlIEFQSSBmdW5jdGlvbnMgYXQgdGhlIGV4cGVjdGVkIHBsYWNlLlxyXG4gICAgICBsZXQgZ2xvYmFsVGhpcyA9IHV0aWxzLmdldEdsb2JhbE9iamVjdCgpO1xyXG4gICAgICBnbG9iYWxUaGlzW0tleWJvYXJkSW50ZXJmYWNlLkdMT0JBTF9OQU1FXSA9IHRoaXMua2V5Ym9hcmRJbnRlcmZhY2U7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgYWN0aXZlIGtleWJvYXJkIGlzIHNldCBvbiB0aGUga2V5Ym9hcmQgaW50ZXJmYWNlIG9iamVjdC5cclxuICAgICAgaWYodGhpcy5hY3RpdmVLZXlib2FyZCkge1xyXG4gICAgICAgIHRoaXMua2V5Ym9hcmRJbnRlcmZhY2UuYWN0aXZlS2V5Ym9hcmQgPSB0aGlzLmFjdGl2ZUtleWJvYXJkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBhY3RpdmVLZXlib2FyZCgpOiBrZXlib2FyZHMuS2V5Ym9hcmQge1xyXG4gICAgICByZXR1cm4gdGhpcy5rZXlib2FyZEludGVyZmFjZS5hY3RpdmVLZXlib2FyZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGFjdGl2ZUtleWJvYXJkKGtleWJvYXJkOiBrZXlib2FyZHMuS2V5Ym9hcmQpIHtcclxuICAgICAgdGhpcy5rZXlib2FyZEludGVyZmFjZS5hY3RpdmVLZXlib2FyZCA9IGtleWJvYXJkO1xyXG5cclxuICAgICAgLy8gQWxsIG9sZCBkZWFka2V5cyBhbmQga2V5Ym9hcmQtc3BlY2lmaWMgY2FjaGUgc2hvdWxkIGltbWVkaWF0ZWx5IGJlIGludmFsaWRhdGVkXHJcbiAgICAgIC8vIG9uIGEga2V5Ym9hcmQgY2hhbmdlLlxyXG4gICAgICB0aGlzLnJlc2V0Q29udGV4dCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBsYXllclN0b3JlKCk6IE11dGFibGVTeXN0ZW1TdG9yZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmtleWJvYXJkSW50ZXJmYWNlLnN5c3RlbVN0b3Jlc1tLZXlib2FyZEludGVyZmFjZS5UU1NfTEFZRVJdIGFzIE11dGFibGVTeXN0ZW1TdG9yZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGxheWVySWQoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMubGF5ZXJTdG9yZS52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3RlOiAgd2lsbCB0cmlnZ2VyIGFuICdldmVudCcgY2FsbGJhY2sgZGVzaWduZWQgdG8gbm90aWZ5IHRoZSBPU0sgb2YgbGF5ZXIgY2hhbmdlcy5cclxuICAgIHB1YmxpYyBzZXQgbGF5ZXJJZCh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICAgIHRoaXMubGF5ZXJTdG9yZS5zZXQodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkZWZhdWx0IFJ1bGVCZWhhdmlvciBmb3IgdGhlIHNwZWNpZmllZCBrZXksIGF0dGVtcHRpbmcgdG8gbWltaWMgc3RhbmRhcmQgYnJvd3NlciBkZWZhdWx0cyBcclxuICAgICAqIHdoZXJlIGFuZCB3aGVuIGFwcHJvcHJpYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICBMa2MgICAgICAgICAgIFRoZSBwcmUtYW5hbHl6ZWQgS2V5RXZlbnQgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gb3V0cHV0VGFyZ2V0ICBUaGUgT3V0cHV0VGFyZ2V0IHJlY2VpdmluZyB0aGUgS2V5RXZlbnRcclxuICAgICAqIEByZXR1cm4gIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRSdWxlQmVoYXZpb3IoTGtjOiBLZXlFdmVudCwgb3V0cHV0VGFyZ2V0OiBPdXRwdXRUYXJnZXQpOiBSdWxlQmVoYXZpb3Ige1xyXG4gICAgICBsZXQgcHJlSW5wdXQgPSBNb2NrLmZyb20ob3V0cHV0VGFyZ2V0KTtcclxuICAgICAgbGV0IHJ1bGVCZWhhdmlvciA9IG5ldyBSdWxlQmVoYXZpb3IoKTtcclxuXHJcbiAgICAgIGxldCBtYXRjaGVkID0gZmFsc2U7XHJcbiAgICAgIHZhciBjaGFyID0gJyc7XHJcbiAgICAgIHZhciBzcGVjaWFsOiBFbXVsYXRpb25LZXlzdHJva2VzO1xyXG4gICAgICBpZihMa2MuaXNTeW50aGV0aWMgfHwgb3V0cHV0VGFyZ2V0LmlzU3ludGhldGljKSB7XHJcbiAgICAgICAgbWF0Y2hlZCA9IHRydWU7ICAvLyBBbGwgdGhlIGNvbmRpdGlvbnMgYmVsb3cgcmVzdWx0IGluIG1hdGNoZXMgdW50aWwgdGhlIGZpbmFsIGVsc2UsIHdoaWNoIHJlc3RvcmVzIHRoZSBleHBlY3RlZCBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBtYXRjaCBvY2N1cnMuXHJcblxyXG4gICAgICAgIGlmKERlZmF1bHRPdXRwdXQuaXNDb21tYW5kKExrYykpIHtcclxuICAgICAgICAgIC8vIE5vdGUgdGhpcyBpbiB0aGUgcnVsZSBiZWhhdmlvciwgcmV0dXJuIHN1Y2Nlc3NmdWxseS4gIFdlJ2xsIGNvbnNpZGVyIGFwcGx5aW5nIGl0IGxhdGVyLlxyXG4gICAgICAgICAgcnVsZUJlaGF2aW9yLnRyaWdnZXJzRGVmYXVsdENvbW1hbmQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIC8vIFdlJ2QgcmF0aGVyIGxldCB0aGUgYnJvd3NlciBoYW5kbGUgdGhlc2Uga2V5cywgYnV0IHdlJ3JlIHVzaW5nIGVtdWxhdGVkIGtleXN0cm9rZXMsIGZvcmNpbmcgS01XXHJcbiAgICAgICAgICAvLyB0byBlbXVsYXRlIGRlZmF1bHQgYmVoYXZpb3IgaGVyZS5cclxuICAgICAgICB9IGVsc2UgaWYoKHNwZWNpYWwgPSBEZWZhdWx0T3V0cHV0LmZvclNwZWNpYWxFbXVsYXRpb24oTGtjKSkgIT0gbnVsbCkgeyBcclxuICAgICAgICAgIHN3aXRjaChzcGVjaWFsKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRW11bGF0aW9uS2V5c3Ryb2tlcy5CYWNrc3BhY2U6XHJcbiAgICAgICAgICAgICAgdGhpcy5rZXlib2FyZEludGVyZmFjZS5kZWZhdWx0QmFja3NwYWNlKG91dHB1dFRhcmdldCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRW11bGF0aW9uS2V5c3Ryb2tlcy5FbnRlcjpcclxuICAgICAgICAgICAgICBvdXRwdXRUYXJnZXQuaGFuZGxlTmV3bGluZUF0Q2FyZXQoKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLy8gY2FzZSAnXFx1MDA3Zic6IC8vIEtfREVMXHJcbiAgICAgICAgICAgICAgLy8gLy8gRm9yIChwb3NzaWJsZSkgZnV0dXJlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgICAgICAgIC8vIC8vIFdvdWxkIHJlY29tbWVuZCAoY29uY2VwdHVhbGx5KSBlcXVhbGluZyBLX1JJR0hUICsgS19CS1NQLCB0aGUgZm9ybWVyIG9mIHdoaWNoIHdvdWxkIHRlY2huaWNhbGx5IGJlIGEgJ2NvbW1hbmQnLlxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIC8vIEluIGNhc2Ugd2UgZXh0ZW5kIHRoZSBhbGxvd2VkIHNldCwgYnV0IGZvcmdldCB0byBpbXBsZW1lbnQgaXRzIGhhbmRsaW5nIGNhc2UgYWJvdmUuXHJcbiAgICAgICAgICAgICAgcnVsZUJlaGF2aW9yLmVycm9yTG9nID0gXCJVbmV4cGVjdGVkICdzcGVjaWFsIGVtdWxhdGlvbicgY2hhcmFjdGVyIChcXFxcdVwiICsgKHNwZWNpYWwgYXMgU3RyaW5nKS5rbXdDaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSArIFwiKSB3ZW50IHVuaGFuZGxlZCFcIjtcclxuICAgICAgICAgIH0gXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEJhY2sgdG8gdGhlIHN0YW5kYXJkIGRlZmF1bHQsIHBlbmRpbmcgbm9ybWFsIG1hdGNoaW5nLlxyXG4gICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBcclxuXHJcbiAgICAgIGxldCBpc01uZW1vbmljID0gdGhpcy5hY3RpdmVLZXlib2FyZCAmJiB0aGlzLmFjdGl2ZUtleWJvYXJkLmlzTW5lbW9uaWM7XHJcblxyXG4gICAgICBpZighbWF0Y2hlZCkge1xyXG4gICAgICAgIGlmKChjaGFyID0gRGVmYXVsdE91dHB1dC5mb3JBbnkoTGtjLCBpc01uZW1vbmljKSkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgc3BlY2lhbCA9IERlZmF1bHRPdXRwdXQuZm9yU3BlY2lhbEVtdWxhdGlvbihMa2MpXHJcbiAgICAgICAgICBpZihzcGVjaWFsID09IEVtdWxhdGlvbktleXN0cm9rZXMuQmFja3NwYWNlKSB7XHJcbiAgICAgICAgICAgIC8vIEEgYnJvd3NlcidzIGRlZmF1bHQgYmFja3NwYWNlIG1heSBmYWlsIHRvIGRlbGV0ZSBib3RoIHBhcnRzIG9mIGFuIFNNUCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRJbnRlcmZhY2UuZGVmYXVsdEJhY2tzcGFjZShvdXRwdXRUYXJnZXQpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmKHNwZWNpYWwgfHwgRGVmYXVsdE91dHB1dC5pc0NvbW1hbmQoTGtjKSkgeyAvLyBGaWx0ZXJzIG91dCAnY29tbWFuZHMnIGxpa2UgVEFCLlxyXG4gICAgICAgICAgICAvLyBXZSBvbmx5IGRvIHRoZSBcImZvciBzcGVjaWFsIGVtdWxhdGlvblwiIGNhc2VzIHVuZGVyIHRoZSBjb25kaXRpb24gYWJvdmUuLi4gYXNpZGUgZnJvbSBiYWNrc3BhY2VcclxuICAgICAgICAgICAgLy8gTGV0IHRoZSBicm93c2VyIGhhbmRsZSB0aG9zZS5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmtleWJvYXJkSW50ZXJmYWNlLm91dHB1dCgwLCBvdXRwdXRUYXJnZXQsIGNoYXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBObyBtYXRjaCwgbm8gZGVmYXVsdCBSdWxlQmVoYXZpb3IuXHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNob3J0Y3V0IHRoaW5ncyBpbW1lZGlhdGVseSBpZiB0aGVyZSB3ZXJlIGlzc3VlcyBnZW5lcmF0aW5nIHRoaXMgcnVsZSBiZWhhdmlvci5cclxuICAgICAgaWYocnVsZUJlaGF2aW9yLmVycm9yTG9nKSB7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGVCZWhhdmlvcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHRyYW5zY3JpcHRpb24gPSBvdXRwdXRUYXJnZXQuYnVpbGRUcmFuc2NyaXB0aW9uRnJvbShwcmVJbnB1dCwgTGtjKTtcclxuICAgICAgcnVsZUJlaGF2aW9yLnRyYW5zY3JpcHRpb24gPSB0cmFuc2NyaXB0aW9uO1xyXG5cclxuICAgICAgcmV0dXJuIHJ1bGVCZWhhdmlvcjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRTeW50aGV0aWNFdmVudERlZmF1bHRzKExrYzogdGV4dC5LZXlFdmVudCkge1xyXG4gICAgICAvLyBTZXQgdGhlIGZsYWdzIGZvciB0aGUgc3RhdGUga2V5cy5cclxuICAgICAgTGtjLkxzdGF0ZXMgfD0gdGhpcy5zdGF0ZUtleXNbJ0tfQ0FQUyddICAgID8gQ29kZXMubW9kaWZpZXJDb2Rlc1snQ0FQUyddIDogQ29kZXMubW9kaWZpZXJDb2Rlc1snTk9fQ0FQUyddO1xyXG4gICAgICBMa2MuTHN0YXRlcyB8PSB0aGlzLnN0YXRlS2V5c1snS19OVU1MT0NLJ10gPyBDb2Rlcy5tb2RpZmllckNvZGVzWydOVU1fTE9DSyddIDogQ29kZXMubW9kaWZpZXJDb2Rlc1snTk9fTlVNX0xPQ0snXTtcclxuICAgICAgTGtjLkxzdGF0ZXMgfD0gdGhpcy5zdGF0ZUtleXNbJ0tfU0NST0xMJ10gID8gQ29kZXMubW9kaWZpZXJDb2Rlc1snU0NST0xMX0xPQ0snXSA6IENvZGVzLm1vZGlmaWVyQ29kZXNbJ05PX1NDUk9MTF9MT0NLJ107XHJcblxyXG4gICAgICAvLyBTZXQgTGlzVmlydHVhbEtleSB0byBmYWxzZSB0byBlbnN1cmUgdGhhdCBub21hdGNoIHJ1bGUgZG9lcyBmaXJlIGZvciBVX3h4eHgga2V5c1xyXG4gICAgICBpZihMa2Mua05hbWUgJiYgTGtjLmtOYW1lLnN1YnN0cigwLDIpID09ICdVXycpIHtcclxuICAgICAgICBMa2MuTGlzVmlydHVhbEtleT1mYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gR2V0IGNvZGUgZm9yIG5vbi1waHlzaWNhbCBrZXlzIChUX0tPS0FJLCBVXzA1QUIgZXRjKVxyXG4gICAgICBpZih0eXBlb2YgTGtjLkxjb2RlID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgTGtjLkxjb2RlID0gdGhpcy5nZXRWS0RpY3Rpb25hcnlDb2RlKExrYy5rTmFtZSk7Ly8gVXBkYXRlZCBmb3IgQnVpbGQgMzQ3XHJcbiAgICAgICAgaWYoIUxrYy5MY29kZSkge1xyXG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBVX3h4eHgga2V5cy4gVGhpcyB2ayBjb2RlIHdpbGwgbmV2ZXIgYmUgdXNlZFxyXG4gICAgICAgICAgLy8gaW4gYSBrZXlib2FyZCwgc28gd2UgdXNlIHRoaXMgdG8gZW5zdXJlIHRoYXQga2V5c3Ryb2tlIHByb2Nlc3NpbmdcclxuICAgICAgICAgIC8vIG9jY3VycyBmb3IgdGhlIGtleS5cclxuICAgICAgICAgIExrYy5MY29kZSA9IDE7IFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSGFuZGxlcyBtb2RpZmllciBzdGF0ZXMgd2hlbiB0aGUgT1NLIGlzIGVtdWxhdGluZyByaWdodGFsdCB0aHJvdWdoIHRoZSBsZWZ0Y3RybC1sZWZ0YWx0IGxheWVyLlxyXG4gICAgICBpZigoTGtjLkxtb2RpZmllcnMgJiBDb2Rlcy5tb2RpZmllckJpdG1hc2tzWydBTFRfR1JfU0lNJ10pID09IENvZGVzLm1vZGlmaWVyQml0bWFza3NbJ0FMVF9HUl9TSU0nXSAmJiB0aGlzLmFjdGl2ZUtleWJvYXJkLmVtdWxhdGVzQWx0R3IpIHtcclxuICAgICAgICBMa2MuTG1vZGlmaWVycyAmPSB+Q29kZXMubW9kaWZpZXJCaXRtYXNrc1snQUxUX0dSX1NJTSddO1xyXG4gICAgICAgIExrYy5MbW9kaWZpZXJzIHw9IENvZGVzLm1vZGlmaWVyQ29kZXNbJ1JBTFQnXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb2Nlc3NLZXlzdHJva2Uoa2V5RXZlbnQ6IEtleUV2ZW50LCBvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCk6IFJ1bGVCZWhhdmlvciB7XHJcbiAgICAgIHZhciBtYXRjaEJlaGF2aW9yOiBSdWxlQmVoYXZpb3I7XHJcblxyXG4gICAgICAvLyBQYXNzIHRoaXMga2V5IGNvZGUgYW5kIHN0YXRlIHRvIHRoZSBrZXlib2FyZCBwcm9ncmFtXHJcbiAgICAgIGlmKHRoaXMuYWN0aXZlS2V5Ym9hcmQgJiYga2V5RXZlbnQuTGNvZGUgIT0gMCkge1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVGhlIGB0aGlzLmluc3RhbGxJbnRlcmZhY2UoKWAgY2FsbCBpcyBpbnN1cmFuY2UgYWdhaW5zdCBzb21ldGhpbmcgSSd2ZSBzZWVuIGluIHVuaXQgdGVzdHMgd2hlbiB0aGluZ3MgYnJlYWsgYSBiaXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBDdXJyZW50bHksIHdoZW4gYSBLTVcgc2h1dGRvd24gZG9lc24ndCBnbyB0aHJvdWdoIHByb3Blcmx5IG9yIGNvbXBsZXRlbHksIHNvbWV0aW1lcyB3ZSBlbmQgdXAgd2l0aCBwYXJhbGxlbFxyXG4gICAgICAgICAqIHZlcnNpb25zIG9mIEtNVyBydW5uaW5nLCBhbmQgYW4gb2xkLCBwYXJ0aWFsbHktc2h1dGRvd24gb25lIHdpbGwgXCJzbmlwZVwiIGEgY29tbWFuZCBtZWFudCBmb3IgdGhlIG1vc3QtcmVjZW50IFxyXG4gICAgICAgICAqIG9uZSdzIHRlc3QuIFNvLCBpbnN0YWxsaW5nIGhlcmUgZW5zdXJlcyB0aGF0IHRoZSBhY3RpdmUgUHJvY2Vzc29yIGhhcyBpdHMgbWF0Y2hpbmcgS2V5Ym9hcmRJbnRlcmZhY2UgcmVhZHksIFxyXG4gICAgICAgICAqIGV2ZW4gc2hvdWxkIHRoYXQgb2NjdXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbnN0YWxsSW50ZXJmYWNlKCk7XHJcbiAgICAgICAgbWF0Y2hCZWhhdmlvciA9IHRoaXMua2V5Ym9hcmRJbnRlcmZhY2UucHJvY2Vzc0tleXN0cm9rZShvdXRwdXRUYXJnZXQsIGtleUV2ZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoIW1hdGNoQmVoYXZpb3IpIHtcclxuICAgICAgICAvLyBSZXN0b3JlIHRoZSB2aXJ0dWFsIGtleSBjb2RlIGlmIGEgbW5lbW9uaWMga2V5Ym9hcmQgaXMgYmVpbmcgdXNlZFxyXG4gICAgICAgIC8vIElmIG5vIHZrQ29kZSB2YWx1ZSB3YXMgc3RvcmVkLCBtYWludGFpbiB0aGUgb3JpZ2luYWwgTGNvZGUgdmFsdWUuXHJcbiAgICAgICAga2V5RXZlbnQuTGNvZGU9a2V5RXZlbnQudmtDb2RlIHx8IGtleUV2ZW50Lkxjb2RlO1xyXG5cclxuICAgICAgICAvLyBIYW5kbGUgdW5tYXBwZWQga2V5cywgaW5jbHVkaW5nIHNwZWNpYWwga2V5c1xyXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgcGh5c2ljYWwgbGF5b3V0IGRlcGVuZGVudCwgc28gc2hvdWxkIGJlIGF2b2lkZWQgaWYgcG9zc2libGUuICBBbGwga2V5cyBzaG91bGQgYmUgbWFwcGVkLlxyXG4gICAgICAgIHRoaXMua2V5Ym9hcmRJbnRlcmZhY2UuYWN0aXZlVGFyZ2V0T3V0cHV0ID0gb3V0cHV0VGFyZ2V0O1xyXG5cclxuICAgICAgICAvLyBNYXRjaCBhZ2FpbnN0IHRoZSAnZGVmYXVsdCBrZXlib2FyZCcgLSBydWxlcyB0byBtaW1pYyB0aGUgZGVmYXVsdCBzdHJpbmcgb3V0cHV0IHdoZW4gdHlwaW5nIGluIGEgYnJvd3Nlci5cclxuICAgICAgICAvLyBNYW55IGtleWJvYXJkcyByZWx5IHVwb24gdGhlc2UgJ2ltcGxpZWQgcnVsZXMnLlxyXG4gICAgICAgIG1hdGNoQmVoYXZpb3IgPSB0aGlzLmRlZmF1bHRSdWxlQmVoYXZpb3Ioa2V5RXZlbnQsIG91dHB1dFRhcmdldCk7XHJcblxyXG4gICAgICAgIHRoaXMua2V5Ym9hcmRJbnRlcmZhY2UuYWN0aXZlVGFyZ2V0T3V0cHV0ID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG1hdGNoQmVoYXZpb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRklYTUU6ICBtYWtlcyBzb21lIGJhZCBhc3N1bXB0aW9ucy5cclxuICAgIHN0YXRpYyBzZXRNbmVtb25pY0NvZGUoTGtjOiBLZXlFdmVudCwgc2hpZnRlZDogYm9vbGVhbiwgY2Fwc0FjdGl2ZTogYm9vbGVhbikge1xyXG4gICAgICAvLyBLX1NQQUNFIGlzIG5vdCBoYW5kbGVkIGJ5IGRlZmF1bHRLZXlPdXRwdXQgZm9yIHBoeXNpY2FsIGtleXN0cm9rZXMgdW5sZXNzIHVzaW5nIHRvdWNoLWFsaWFzZWQgZWxlbWVudHMuXHJcbiAgICAgIC8vIEl0J3MgYWxzbyBhIFwiZXhjZXB0aW9uIHJlcXVpcmVkLCBNYXJjaCAyMDEzXCIgZm9yIGNsaWNrS2V5LCBzbyBhdCBsZWFzdCB0aGV5IGJvdGggaGF2ZSB0aGlzIHJlcXVpcmVtZW50LlxyXG4gICAgICBpZihMa2MuTGNvZGUgIT0gQ29kZXMua2V5Q29kZXNbJ0tfU1BBQ0UnXSkge1xyXG4gICAgICAgIC8vIFNvIGxvbmcgYXMgdGhlIGtleSBuYW1lIGlzbid0IHByZWZpeGVkIHdpdGggJ1VfJywgd2UnbGwgZ2V0IGEgZGVmYXVsdCBtYXBwaW5nIGJhc2VkIG9uIHRoZSBMY29kZSB2YWx1ZS5cclxuICAgICAgICAvLyBXZSBuZWVkIHRvIGRldGVybWluZSB0aGUgbW5lbW9uaWMgYmFzZSBjaGFyYWN0ZXIgLSBmb3IgZXhhbXBsZSwgU0hJRlQgKyBLX1BFUklPRCBuZWVkcyB0byBtYXAgdG8gJz4nLlxyXG4gICAgICAgIGxldCBtYXBwaW5nRXZlbnQ6IEtleUV2ZW50ID0gbmV3IEtleUV2ZW50KCk7XHJcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gTGtjKSB7XHJcbiAgICAgICAgICBtYXBwaW5nRXZlbnRba2V5XSA9IExrY1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBUbyBmYWNpbGl0YXRlIHN0b3JpbmcgcmVsZXZhbnQgY29tbWFuZHMsIHdlIHNob3VsZCBwcm9iYWJseSByZXZlcnNlLWxvb2t1cFxyXG4gICAgICAgIC8vIHRoZSBhY3R1YWwga2V5bmFtZSBpbnN0ZWFkLlxyXG4gICAgICAgIG1hcHBpbmdFdmVudC5rTmFtZSA9ICdLX3h4eHgnO1xyXG4gICAgICAgIG1hcHBpbmdFdmVudC5MbW9kaWZpZXJzID0gKHNoaWZ0ZWQgPyAweDEwIDogMCk7ICAvLyBtbmVtb25pYyBsb29rdXBzIG9ubHkgZXhpc3QgZm9yIGRlZmF1bHQgJiBzaGlmdCBsYXllcnMuXHJcbiAgICAgICAgdmFyIG1hcHBlZENoYXI6IHN0cmluZyA9IERlZmF1bHRPdXRwdXQuZm9yQW55KG1hcHBpbmdFdmVudCwgdHJ1ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLyogRmlyc3QsIHNhdmUgYSBiYWNrdXAgb2YgdGhlIG9yaWdpbmFsIGNvZGUuICBUaGlzIG9uZSB3b24ndCBuZWVkbGVzc2x5IHRyaWdnZXIga2V5Ym9hcmRcclxuICAgICAgICAgKiBydWxlcywgYnV0IGFsbG93cyB1cyB0byByZXBsaWNhdGUvZW11bGF0ZSBjb21tYW5kcyBhZnRlciBydWxlIHByb2Nlc3NpbmcgaWYgbmVlZGVkLlxyXG4gICAgICAgICAqIChMaWtlIGJhY2tzcGFjZXMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGtjLnZrQ29kZSA9IExrYy5MY29kZTtcclxuICAgICAgICBpZihtYXBwZWRDaGFyKSB7XHJcbiAgICAgICAgICAvLyBXaWxsIHJldHVybiA5NiBmb3IgJ2EnLCB3aGljaCBpcyBhIGtleWNvZGUgY29ycmVzcG9uZGluZyB0byBDb2Rlcy5rZXlDb2RlcygnS19OUDEnKSAtIGEgbnVtcGFkIGtleS5cclxuICAgICAgICAgIC8vIFRoYXQgc3RhdGVkLCB3ZSdyZSBpbiBtbmVtb25pYyBtb2RlIC0gdGhpcyBrZXlib2FyZCdzIHJ1bGVzIGFyZSBiYXNlZCBvbiB0aGUgY2hhciBjb2Rlcy5cclxuICAgICAgICAgIExrYy5MY29kZSA9IG1hcHBlZENoYXIuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gRG9uJ3QgbGV0IGNvbW1hbmQtdHlwZSBrZXlzIChsaWtlIEtfREVMLCB3aGljaCB3aWxsIG91dHB1dCAnLicgb3RoZXJ3aXNlISlcclxuICAgICAgICAgIC8vIHRyaWdnZXIga2V5Ym9hcmQgcnVsZXMuXHJcbiAgICAgICAgICAvL1xyXG4gICAgICAgICAgLy8gSG93ZXZlciwgRE8gbWFrZSBzdXJlIG1vZGlmaWVyIGtleXMgcGFzcyB0aHJvdWdoIHNhZmVseS5cclxuICAgICAgICAgIC8vIChodHRwczovL2dpdGh1Yi5jb20va2V5bWFuYXBwL2tleW1hbi9pc3N1ZXMvMzc0NClcclxuICAgICAgICAgIGlmKCFLZXlib2FyZFByb2Nlc3Nvci5pc01vZGlmaWVyKExrYykpIHtcclxuICAgICAgICAgICAgZGVsZXRlIExrYy5MY29kZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKGNhcHNBY3RpdmUpIHtcclxuICAgICAgICAvLyBUT0RPOiAgTmVlZHMgZml4aW5nIC0gZG9lcyBub3QgcHJvcGVybHkgbWlycm9yIHBoeXNpY2FsIGtleXN0cm9rZXMsIGFzIExjb2RlIHJhbmdlIDk2LTExMSBjb3JyZXNwb25kc1xyXG4gICAgICAgIC8vIHRvIG51bXBhZCBrZXlzISAgKFBoeXNpY2FsIGtleWJvYXJkIHNlY3Rpb24gaGFzIGl0cyBvd24gaXNzdWVzIGhlcmUuKVxyXG4gICAgICAgIGlmKChMa2MuTGNvZGUgPj0gNjUgJiYgTGtjLkxjb2RlIDw9IDkwKSAvKiAnQScgLSAnWicgKi8gfHwgKExrYy5MY29kZSA+PSA5NyAmJiBMa2MuTGNvZGUgPD0gMTIyKSAvKiAnYScgLSAneicgKi8pIHtcclxuICAgICAgICAgIExrYy5MbW9kaWZpZXJzIF49IDB4MTA7ICAvLyBGbGlwIHRoZSAnc2hpZnRlZCcgYml0LCBzbyBpdCdsbCBhY3QgYXMgdGhlIG9wcG9zaXRlIGtleS5cclxuICAgICAgICAgIExrYy5MY29kZSBePSAweDIwOyAvLyBGbGlwcyB0aGUgJ3VwcGVyJyB2cyAnbG93ZXInIGJpdCBmb3IgdGhlIGJhc2UgJ2EnLSd6JyBBU0NJSSBhbHBoYWJldGljcy5cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBtb2RpZmllciBrZXkgc3RhdGUgZnJvbSBsYXllciBpZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICAgIGxheWVySWQgICAgICAgbGF5ZXIgaWQgKGUuZy4gY3RybHNoaWZ0KVxyXG4gICAgICogQHJldHVybiAgICAgIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgICBtb2RpZmllciBrZXkgc3RhdGUgKGRlc2t0b3Aga2V5Ym9hcmRzKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0TW9kaWZpZXJTdGF0ZShsYXllcklkOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICB2YXIgbW9kaWZpZXI9MDtcclxuICAgICAgaWYobGF5ZXJJZC5pbmRleE9mKCdzaGlmdCcpID49IDApIHtcclxuICAgICAgICBtb2RpZmllciB8PSBDb2Rlcy5tb2RpZmllckNvZGVzWydTSElGVCddO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGUgY2hpcmFsIGNoZWNrcyBtdXN0IG5vdCBiZSBkaXJlY3RseSBleGNsdXNpdmUgZHVlIGVhY2ggb3RoZXIgdG8gdmlzdWFsIE9TSyBmZWVkYmFjay5cclxuICAgICAgdmFyIGN0cmxNYXRjaGVkPWZhbHNlO1xyXG4gICAgICBpZihsYXllcklkLmluZGV4T2YoJ2xlZnRjdHJsJykgPj0gMCkge1xyXG4gICAgICAgIG1vZGlmaWVyIHw9IENvZGVzLm1vZGlmaWVyQ29kZXNbJ0xDVFJMJ107XHJcbiAgICAgICAgY3RybE1hdGNoZWQ9dHJ1ZTtcclxuICAgICAgfSBcclxuICAgICAgaWYobGF5ZXJJZC5pbmRleE9mKCdyaWdodGN0cmwnKSA+PSAwKSB7XHJcbiAgICAgICAgbW9kaWZpZXIgfD0gQ29kZXMubW9kaWZpZXJDb2Rlc1snUkNUUkwnXTtcclxuICAgICAgICBjdHJsTWF0Y2hlZD10cnVlO1xyXG4gICAgICB9IFxyXG4gICAgICBpZihsYXllcklkLmluZGV4T2YoJ2N0cmwnKSAgPj0gMCAmJiAhY3RybE1hdGNoZWQpIHtcclxuICAgICAgICBtb2RpZmllciB8PSBDb2Rlcy5tb2RpZmllckNvZGVzWydDVFJMJ107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBhbHRNYXRjaGVkPWZhbHNlO1xyXG4gICAgICBpZihsYXllcklkLmluZGV4T2YoJ2xlZnRhbHQnKSA+PSAwKSB7XHJcbiAgICAgICAgbW9kaWZpZXIgfD0gQ29kZXMubW9kaWZpZXJDb2Rlc1snTEFMVCddO1xyXG4gICAgICAgIGFsdE1hdGNoZWQ9dHJ1ZTtcclxuICAgICAgfSBcclxuICAgICAgaWYobGF5ZXJJZC5pbmRleE9mKCdyaWdodGFsdCcpID49IDApIHtcclxuICAgICAgICBtb2RpZmllciB8PSBDb2Rlcy5tb2RpZmllckNvZGVzWydSQUxUJ107XHJcbiAgICAgICAgYWx0TWF0Y2hlZD10cnVlO1xyXG4gICAgICB9IFxyXG4gICAgICBpZihsYXllcklkLmluZGV4T2YoJ2FsdCcpICA+PSAwICYmICFhbHRNYXRjaGVkKSB7XHJcbiAgICAgICAgbW9kaWZpZXIgfD0gQ29kZXMubW9kaWZpZXJDb2Rlc1snQUxUJ107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtb2RpZmllcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBzdW1tYXJ5IExvb2sgdXAgYSBjdXN0b20gdmlydHVhbCBrZXkgY29kZSBpbiB0aGUgdmlydHVhbCBrZXkgY29kZSBkaWN0aW9uYXJ5IEtWS0QuICBPbiBmaXJzdCBydW4sIHdpbGwgYnVpbGQgdGhlIGRpY3Rpb25hcnkuXHJcbiAgICAgKlxyXG4gICAgICogYFZLRGljdGlvbmFyeWAgaXMgY29uc3RydWN0ZWQgZnJvbSB0aGUga2V5Ym9hcmQncyBgS1ZLRGAgbWVtYmVyLiBUaGlzIGxpc3QgaXMgY29uc3RydWN0ZWQgXHJcbiAgICAgKiBhdCBjb21waWxlLXRpbWUgYW5kIGlzIGEgbGlzdCBvZiAnYWRkaXRpb25hbCcgdmlydHVhbCBrZXkgY29kZXMsIHN0YXJ0aW5nIGF0IDI1NiAoaS5lLiBcclxuICAgICAqIG91dHNpZGUgdGhlIHJhbmdlIG9mIHN0YW5kYXJkIHZpcnR1YWwga2V5IGNvZGVzKS4gVGhlc2UgYWRkaXRpb25hbCBjb2RlcyBhcmUgYm90aCBcclxuICAgICAqIGBbVF94eHhdYCBhbmQgYFtVX3h4eHhdYCBjdXN0b20ga2V5IGNvZGVzIGZyb20gdGhlIEtleW1hbiBrZXlib2FyZCBsYW5ndWFnZS4gSG93ZXZlciwgXHJcbiAgICAgKiBgW1VfeHh4eF1gIGtleXMgb25seSBnZW5lcmF0ZSBhbiBlbnRyeSBpbiBgS1ZLRGAgaWYgdGhlcmUgaXMgYSBjb3JyZXNwb25kaW5nIHJ1bGUgdGhhdCBcclxuICAgICAqIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGVtIGluIHRoZSBrZXlib2FyZCBydWxlcy4gSWYgdGhlIGBbVV94eHh4XWAga2V5IGNvZGUgaXMgb25seSBcclxuICAgICAqIHJlZmVyZW5jZWQgYXMgdGhlIGlkIG9mIGEga2V5IGluIHRoZSB0b3VjaCBsYXlvdXQsIHRoZW4gaXQgZG9lcyBub3QgZ2V0IGFuIGVudHJ5IGluIFxyXG4gICAgICogdGhlIGBLVktEYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgICAga2V5TmFtZSAgIGN1c3RvbSB2aXJ0dWFsIGtleSBjb2RlIHRvIGxvb2t1cCBpbiB0aGUgZGljdGlvbmFyeVxyXG4gICAgICogQHJldHVybiAgICAgIHtudW1iZXJ9ICAgICAgICAgICAgICAgIGtleSBjb2RlID4gMjU1IG9uIHN1Y2Nlc3MsIG9yIDAgaWYgbm90IGZvdW5kXHJcbiAgICAgKi9cclxuICAgIGdldFZLRGljdGlvbmFyeUNvZGUoa2V5TmFtZTogc3RyaW5nKSB7XHJcbiAgICAgIHZhciBhY3RpdmVLZXlib2FyZCA9IHRoaXMuYWN0aXZlS2V5Ym9hcmQ7XHJcbiAgICAgIGlmKCFhY3RpdmVLZXlib2FyZC5zY3JpcHRPYmplY3RbJ1ZLRGljdGlvbmFyeSddKSB7XHJcbiAgICAgICAgdmFyIGE9W107XHJcbiAgICAgICAgaWYodHlwZW9mIGFjdGl2ZUtleWJvYXJkLnNjcmlwdE9iamVjdFsnS1ZLRCddID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAvLyBCdWlsZCB0aGUgVksgZGljdGlvbmFyeVxyXG4gICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGUgZGljdGlvbmFyeSBidWlsZCBpbnRvIHRoZSBjb21waWxlciAtLSBzbyBjb21waWxlciBnZW5lcmF0ZXMgY29kZSBzdWNoIGFzIGZvbGxvd2luZy4gIFxyXG4gICAgICAgICAgLy8gTWFrZXMgdGhlIFZLRGljdGlvbmFyeSBtZW1iZXIgdW5uZWNlc3NhcnkuXHJcbiAgICAgICAgICAvLyAgICAgICB0aGlzLktWS0Q9e1wiS19BQkNcIjoyNTYsXCJLX0RFRlwiOjI1NywuLi59O1xyXG4gICAgICAgICAgdmFyIHM9YWN0aXZlS2V5Ym9hcmQuc2NyaXB0T2JqZWN0WydLVktEJ10uc3BsaXQoJyAnKTtcclxuICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYVtzW2ldLnRvVXBwZXJDYXNlKCldPWkrMjU2OyAvLyBXZSBmb3JjZSB1cHBlci1jYXNlIHNpbmNlIHZpcnR1YWwga2V5cyBzaG91bGQgYmUgY2FzZS1pbnNlbnNpdGl2ZS5cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlS2V5Ym9hcmQuc2NyaXB0T2JqZWN0WydWS0RpY3Rpb25hcnknXT1hO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcmVzPWFjdGl2ZUtleWJvYXJkLnNjcmlwdE9iamVjdFsnVktEaWN0aW9uYXJ5J11ba2V5TmFtZS50b1VwcGVyQ2FzZSgpXTtcclxuICAgICAgcmV0dXJuIHJlcyA/IHJlcyA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiAgICAgX1VwZGF0ZVZLU2hpZnRcclxuICAgICAqIFNjb3BlICAgICAgICBQcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gICAgICAgICAgICBlICAgICBPU0sgZXZlbnRcclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgICAgICAgIHYgICAgIGtleWJvYXJkIHNoaWZ0IHN0YXRlXHJcbiAgICAgKiBAcGFyYW0gICAgICAgeyhib29sZWFufG51bWJlcil9ICBkICAgICBzZXQgKDEpIG9yIGNsZWFyKDApIHNoaWZ0IHN0YXRlIGJpdHNcclxuICAgICAqIEByZXR1cm4gICAgICB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIEFsd2F5cyB0cnVlXHJcbiAgICAgKiBEZXNjcmlwdGlvbiAgVXBkYXRlcyB0aGUgY3VycmVudCBzaGlmdCBzdGF0ZSB3aXRoaW4gS01XLCB1cGRhdGluZyB0aGUgT1NLJ3MgdmlzdWFsaXphdGlvbiB0aGVyZW9mLlxyXG4gICAgICovXHJcbiAgICBfVXBkYXRlVktTaGlmdChlOiBLZXlFdmVudCwgdjogbnVtYmVyLCBkOiBib29sZWFufG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICB2YXIga2V5U2hpZnRTdGF0ZT0wLCBsb2NrU3RhdGVzPTAsIGk7XHJcblxyXG4gICAgICB2YXIgbG9ja05hbWVzICA9IFsnQ0FQUycsICdOVU1fTE9DSycsICdTQ1JPTExfTE9DSyddO1xyXG4gICAgICB2YXIgbG9ja0tleXMgICA9IFsnS19DQVBTJywgJ0tfTlVNTE9DSycsICdLX1NDUk9MTCddO1xyXG5cclxuICAgICAgaWYoIXRoaXMuYWN0aXZlS2V5Ym9hcmQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoZSkge1xyXG4gICAgICAgIC8vIHJlYWQgc2hpZnQgc3RhdGVzIGZyb20gUGV2ZW50XHJcbiAgICAgICAga2V5U2hpZnRTdGF0ZSA9IGUuTG1vZGlmaWVycztcclxuICAgICAgICBsb2NrU3RhdGVzID0gZS5Mc3RhdGVzO1xyXG5cclxuICAgICAgICAvLyBBcmUgd2Ugc2ltdWxhdGluZyBBbHRHcj8gIElmIGl0J3MgYSBzaW11bGF0aW9uIGFuZCBub3QgcmVhbCwgdGltZSB0byB1bi1zaW11bGF0ZSBmb3IgdGhlIE9TSy5cclxuICAgICAgICBpZih0aGlzLmFjdGl2ZUtleWJvYXJkLmlzQ2hpcmFsICYmICh0aGlzLmFjdGl2ZUtleWJvYXJkLmVtdWxhdGVzQWx0R3IpICYmIFxyXG4gICAgICAgICAgICAodGhpcy5tb2RTdGF0ZUZsYWdzICYgQ29kZXMubW9kaWZpZXJCaXRtYXNrc1snQUxUX0dSX1NJTSddKSA9PSBDb2Rlcy5tb2RpZmllckJpdG1hc2tzWydBTFRfR1JfU0lNJ10pIHtcclxuICAgICAgICAgIGtleVNoaWZ0U3RhdGUgfD0gQ29kZXMubW9kaWZpZXJCaXRtYXNrc1snQUxUX0dSX1NJTSddO1xyXG4gICAgICAgICAga2V5U2hpZnRTdGF0ZSAmPSB+Q29kZXMubW9kaWZpZXJDb2Rlc1snUkFMVCddO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yKGk9MDsgaSA8IGxvY2tOYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYobG9ja1N0YXRlcyAmIENvZGVzLnN0YXRlQml0bWFza3NbbG9ja05hbWVzW2ldXSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlS2V5c1tsb2NrS2V5c1tpXV0gPSBsb2NrU3RhdGVzICYgQ29kZXMubW9kaWZpZXJDb2Rlc1tsb2NrTmFtZXNbaV1dO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmKGQpIHtcclxuICAgICAgICBrZXlTaGlmdFN0YXRlIHw9IHY7XHJcblxyXG4gICAgICAgIGZvcihpPTA7IGkgPCBsb2NrTmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmKHYgJiBDb2Rlcy5zdGF0ZUJpdG1hc2tzW2xvY2tOYW1lc1tpXV0pIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZUtleXNbbG9ja0tleXNbaV1dID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAga2V5U2hpZnRTdGF0ZSAmPSB+djtcclxuXHJcbiAgICAgICAgZm9yKGk9MDsgaSA8IGxvY2tOYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYodiAmIENvZGVzLnN0YXRlQml0bWFza3NbbG9ja05hbWVzW2ldXSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlS2V5c1tsb2NrS2V5c1tpXV0gPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubGF5ZXJJZCA9IHRoaXMuZ2V0TGF5ZXJJZChrZXlTaGlmdFN0YXRlKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TGF5ZXJJZChtb2RpZmllcjogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGtleWJvYXJkcy5MYXlvdXRzLmdldExheWVySWQobW9kaWZpZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IHRoZSBPU0sncyBuZXh0IGtleWJvYXJkIGxheWVyIGJhc2VkIHVwb24gbGF5ZXIgc3dpdGNoaW5nIGtleXMgYXMgYSBkZWZhdWx0XHJcbiAgICAgKiBUaGUgbmV4dCBsYXllciB3aWxsIGJlIGRldGVybWluZWQgZnJvbSB0aGUga2V5IG5hbWUgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZlZFxyXG4gICAgICpcclxuICAgICAqICBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICBrZXlOYW1lICAgICBrZXkgaWRlbnRpZmllclxyXG4gICAgICogIEBwYXJhbSAge251bWJlcnxzdHJpbmd8dW5kZWZpbmVkfSAgIG5leHRMYXllckluIG9wdGlvbmFsIG5leHQgbGF5ZXIgaWRlbnRpZmllclxyXG4gICAgICogIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlIGlmIGtleWJvYXJkIGxheWVyIGNoYW5nZWRcclxuICAgICAqL1xyXG4gICAgc2VsZWN0TGF5ZXIoa2V5RXZlbnQ6IEtleUV2ZW50LCBmcm9tTmFtZU9ubHk6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQga2V5TmFtZSA9IGtleUV2ZW50LmtOYW1lO1xyXG4gICAgICB2YXIgbmV4dExheWVyID0gZnJvbU5hbWVPbmx5ID8gbnVsbCA6IGtleUV2ZW50LmtOZXh0TGF5ZXI7XHJcbiAgICAgIHZhciBpc0NoaXJhbCA9IHRoaXMuYWN0aXZlS2V5Ym9hcmQgJiYgdGhpcy5hY3RpdmVLZXlib2FyZC5pc0NoaXJhbDtcclxuXHJcbiAgICAgIC8vIExheWVyIG11c3QgYmUgaWRlbnRpZmllZCBieSBuYW1lLCBub3QgbnVtYmVyICgyNy8wOC8yMDE1KVxyXG4gICAgICBpZih0eXBlb2YgbmV4dExheWVyID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgbmV4dExheWVyID0gdGhpcy5nZXRMYXllcklkKG5leHRMYXllciAqIDB4MTApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZGVudGlmeSBuZXh0IGxheWVyLCBpZiByZXF1aXJlZCBieSBrZXlcclxuICAgICAgaWYoIW5leHRMYXllcikge1xyXG4gICAgICAgIHN3aXRjaChrZXlOYW1lKSB7XHJcbiAgICAgICAgICBjYXNlICdLX0xTSElGVCc6XHJcbiAgICAgICAgICBjYXNlICdLX1JTSElGVCc6XHJcbiAgICAgICAgICBjYXNlICdLX1NISUZUJzpcclxuICAgICAgICAgICAgbmV4dExheWVyID0gJ3NoaWZ0JztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdLX0xDT05UUk9MJzpcclxuICAgICAgICAgIGNhc2UgJ0tfTENUUkwnOlxyXG4gICAgICAgICAgICBpZihpc0NoaXJhbCkge1xyXG4gICAgICAgICAgICAgIG5leHRMYXllciA9ICdsZWZ0Y3RybCc7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIGNhc2UgJ0tfUkNPTlRST0wnOlxyXG4gICAgICAgICAgY2FzZSAnS19SQ1RSTCc6XHJcbiAgICAgICAgICAgIGlmKGlzQ2hpcmFsKSB7XHJcbiAgICAgICAgICAgICAgbmV4dExheWVyID0gJ3JpZ2h0Y3RybCc7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIGNhc2UgJ0tfQ1RSTCc6XHJcbiAgICAgICAgICAgIG5leHRMYXllciA9ICdjdHJsJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdLX0xNRU5VJzpcclxuICAgICAgICAgIGNhc2UgJ0tfTEFMVCc6XHJcbiAgICAgICAgICAgIGlmKGlzQ2hpcmFsKSB7XHJcbiAgICAgICAgICAgICAgbmV4dExheWVyID0gJ2xlZnRhbHQnO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBjYXNlICdLX1JNRU5VJzpcclxuICAgICAgICAgIGNhc2UgJ0tfUkFMVCc6XHJcbiAgICAgICAgICAgIGlmKGlzQ2hpcmFsKSB7XHJcbiAgICAgICAgICAgICAgbmV4dExheWVyID0gJ3JpZ2h0YWx0JztcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgY2FzZSAnS19BTFQnOlxyXG4gICAgICAgICAgICBuZXh0TGF5ZXIgPSAnYWx0JztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdLX0FMVEdSJzpcclxuICAgICAgICAgICAgaWYoaXNDaGlyYWwpIHtcclxuICAgICAgICAgICAgICBuZXh0TGF5ZXIgPSAnbGVmdGN0cmwtcmlnaHRhbHQnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG5leHRMYXllciA9ICdjdHJsLWFsdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdLX0NVUlJFTkNJRVMnOlxyXG4gICAgICAgICAgY2FzZSAnS19OVU1FUkFMUyc6XHJcbiAgICAgICAgICBjYXNlICdLX1NISUZURUQnOlxyXG4gICAgICAgICAgY2FzZSAnS19VUFBFUic6XHJcbiAgICAgICAgICBjYXNlICdLX0xPV0VSJzpcclxuICAgICAgICAgIGNhc2UgJ0tfU1lNQk9MUyc6XHJcbiAgICAgICAgICAgIG5leHRMYXllciA9ICdkZWZhdWx0JztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiBubyBrZXkgY29ycmVzcG9uZGluZyB0byBhIGxheWVyIHRyYW5zaXRpb24gaXMgcHJlc3NlZCwgbWFpbnRhaW4gdGhlIGN1cnJlbnQgbGF5ZXIuXHJcbiAgICAgIGlmKCFuZXh0TGF5ZXIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoYW5nZSBsYXllciBhbmQgcmVmcmVzaCBPU0tcclxuICAgICAgdGhpcy51cGRhdGVMYXllcihrZXlFdmVudCwgbmV4dExheWVyKTtcclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbmV3IGxheWVyIGlkLCBhbGxvd2luZyBmb3IgdG9nZ2xpbmcgc2hpZnQvY3RybC9hbHQgd2hpbGUgcHJlc2VydmluZyB0aGUgcmVtYWluZGVyXHJcbiAgICAgKiBvZiB0aGUgbW9kaWZpZXJzIHJlcHJlc2VudGVkIGJ5IHRoZSBjdXJyZW50IGxheWVyIGlkICh3aGVyZSBhcHBsaWNhYmxlKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICAgIGlkICAgICAgbGF5ZXIgaWQgKGUuZy4gY3RybHNoaWZ0KVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVMYXllcihrZXlFdmVudDogS2V5RXZlbnQsIGlkOiBzdHJpbmcpIHtcclxuICAgICAgbGV0IGFjdGl2ZUxheWVyID0gdGhpcy5sYXllcklkO1xyXG4gICAgICB2YXIgcyA9IGFjdGl2ZUxheWVyO1xyXG5cclxuICAgICAgLy8gRG8gbm90IGNoYW5nZSBsYXllciB1bmxlc3MgbmVlZGVkICgyNy8wOC8yMDE1KVxyXG4gICAgICBpZihpZCA9PSBhY3RpdmVMYXllciAmJiBrZXlFdmVudC5kZXZpY2UuZm9ybUZhY3RvciAhPSB1dGlscy5Gb3JtRmFjdG9yLkRlc2t0b3ApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpZHg9aWQ7XHJcbiAgICAgIHZhciBpO1xyXG5cclxuICAgICAgaWYoa2V5RXZlbnQuZGV2aWNlLmZvcm1GYWN0b3IgPT0gdXRpbHMuRm9ybUZhY3Rvci5EZXNrdG9wKSB7XHJcbiAgICAgICAgLy8gTmVlZCB0byB0ZXN0IGlmIHRhcmdldCBsYXllciBpcyBhIHN0YW5kYXJkIGxheWVyIChiYXNlZCBvbiB0aGUgcGxhaW4gJ2RlZmF1bHQnKVxyXG4gICAgICAgIHZhciByZXBsYWNlbWVudHM9IFsnbGVmdGN0cmwnLCAncmlnaHRjdHJsJywgJ2N0cmwnLCAnbGVmdGFsdCcsICdyaWdodGFsdCcsICdhbHQnLCAnc2hpZnQnXTtcclxuXHJcbiAgICAgICAgZm9yKGk9MDsgaSA8IHJlcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgLy8gRG9uJ3QgZm9yZ2V0IHRvIHJlbW92ZSB0aGUga2ViYWItY2FzZSBoeXBoZW5zIVxyXG4gICAgICAgICAgaWR4PWlkeC5yZXBsYWNlKHJlcGxhY2VtZW50c1tpXSArICctJywgJycpO1xyXG4gICAgICAgICAgaWR4PWlkeC5yZXBsYWNlKHJlcGxhY2VtZW50c1tpXSwnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB3ZSBhcmUgcHJlc2VudGx5IG9uIHRoZSBkZWZhdWx0IGxheWVyLCBkcm9wIHRoZSAnZGVmYXVsdCcgYW5kIGdvIHN0cmFpZ2h0IHRvIHRoZSBzaGlmdGVkIG1vZGUuXHJcbiAgICAgICAgLy8gSWYgb24gYSBjb21tb24gc3ltYm9saWMgbGF5ZXIsIGRyb3Agb3V0IG9mIHN5bWJvbGljIG1vZGUgYW5kIGdvIHN0cmFpZ2h0IHRvIHRoZSBzaGlmdGVkIG1vZGUuXHJcbiAgICAgICAgaWYoYWN0aXZlTGF5ZXIgPT0gJ2RlZmF1bHQnIHx8IGFjdGl2ZUxheWVyID09ICdudW1lcmljJyB8fCBhY3RpdmVMYXllciA9PSAnc3ltYm9sJyB8fCBhY3RpdmVMYXllciA9PSAnY3VycmVuY3knIHx8IGlkeCAhPSAnJykge1xyXG4gICAgICAgICAgcyA9IGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGFyZSBiYXNlZCB1cG9uIGEgbGF5ZXIgdGhhdCBhY2NlcHRzIG1vZGlmaWVyIHZhcmlhdGlvbnMuXHJcbiAgICAgICAgLy8gTW9kaWZ5IHRoZSBsYXllciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGtleSBwcmVzc2VkLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVE9ETzogIENvbnNpZGVyOiAgc2hvdWxkIHRoaXMgZXZlciBiZSBhbGxvd2VkIGZvciBhIGJhc2UgbGF5ZXIgb3RoZXIgdGhhbiAnZGVmYXVsdCc/ICBJZiBub3QsXHJcbiAgICAgICAgLy8gaWYoaWR4ID09ICcnKSB3aXRoIGFjY29tcGFueWluZyBpZi1lbHNlIHN0cnVjdHVyYWwgc2hpZnQgd291bGQgYmUgYSBmYXIgYmV0dGVyIHRlc3QgaGVyZS5cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIC8vIFNhdmUgb3VyIGN1cnJlbnQgbW9kaWZpZXIgc3RhdGUuXHJcbiAgICAgICAgICB2YXIgbW9kaWZpZXI9S2V5Ym9hcmRQcm9jZXNzb3IuZ2V0TW9kaWZpZXJTdGF0ZShzKTtcclxuXHJcbiAgICAgICAgICAvLyBTdHJpcCBkb3duIHRvIHRoZSBiYXNlIG1vZGlmaWFibGUgbGF5ZXIuXHJcbiAgICAgICAgICBmb3IoaT0wOyBpIDwgcmVwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IGZvcmdldCB0byByZW1vdmUgdGhlIGtlYmFiLWNhc2UgaHlwaGVucyFcclxuICAgICAgICAgICAgcz1zLnJlcGxhY2UocmVwbGFjZW1lbnRzW2ldICsgJy0nLCAnJyk7XHJcbiAgICAgICAgICAgIHM9cy5yZXBsYWNlKHJlcGxhY2VtZW50c1tpXSwnJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gVG9nZ2xlIHRoZSBtb2RpZmllciByZXByZXNlbnRlZCBieSBvdXIgaW5wdXQgYXJndW1lbnQuXHJcbiAgICAgICAgICBzd2l0Y2goaWQpIHtcclxuICAgICAgICAgICAgY2FzZSAnc2hpZnQnOlxyXG4gICAgICAgICAgICAgIG1vZGlmaWVyIF49IENvZGVzLm1vZGlmaWVyQ29kZXNbJ1NISUZUJ107XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnRjdHJsJzpcclxuICAgICAgICAgICAgICBtb2RpZmllciBePSBDb2Rlcy5tb2RpZmllckNvZGVzWydMQ1RSTCddO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyaWdodGN0cmwnOlxyXG4gICAgICAgICAgICAgIG1vZGlmaWVyIF49IENvZGVzLm1vZGlmaWVyQ29kZXNbJ1JDVFJMJ107XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2N0cmwnOlxyXG4gICAgICAgICAgICAgIG1vZGlmaWVyIF49IENvZGVzLm1vZGlmaWVyQ29kZXNbJ0NUUkwnXTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbGVmdGFsdCc6XHJcbiAgICAgICAgICAgICAgbW9kaWZpZXIgXj0gQ29kZXMubW9kaWZpZXJDb2Rlc1snTEFMVCddO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyaWdodGFsdCc6XHJcbiAgICAgICAgICAgICAgbW9kaWZpZXIgXj0gQ29kZXMubW9kaWZpZXJDb2Rlc1snUkFMVCddO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdhbHQnOlxyXG4gICAgICAgICAgICAgIG1vZGlmaWVyIF49IENvZGVzLm1vZGlmaWVyQ29kZXNbJ0FMVCddO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHMgPSBpZDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDb21iaW5lIG91ciBiYXNlIG1vZGlmaWFibGUgbGF5ZXIgYW5kIGF0dGFjaCB0aGUgbmV3IG1vZGlmaWVyIHZhcmlhdGlvbiBpbmZvIHRvIG9idGFpbiBvdXIgZGVzdGluYXRpb24gbGF5ZXIuXHJcbiAgICAgICAgICBpZihzICE9ICdkZWZhdWx0Jykge1xyXG4gICAgICAgICAgICBpZihzID09ICcnKSB7XHJcbiAgICAgICAgICAgICAgcyA9IHRoaXMuZ2V0TGF5ZXJJZChtb2RpZmllcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcyA9IHRoaXMuZ2V0TGF5ZXJJZChtb2RpZmllcikgKyAnLScgKyBzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHMgPT0gJycpIHtcclxuICAgICAgICAgIHMgPSAnZGVmYXVsdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE1vYmlsZSBmb3JtLWZhY3Rvci4gIEVpdGhlciB0aGUgbGF5b3V0IGlzIHNwZWNpZmllZCBieSBhIGtleWJvYXJkIGRldmVsb3BlciB3aXRoIGRpcmVjdCBsYXllciBuYW1lIHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBvciBhbGwgbGF5ZXJzIGFyZSBhY2Nlc3NlZCB2aWEgc3Via2V5IG9mIGEgc2luZ2xlIGxheWVyLXNoaWZ0aW5nIGtleSAtIG5vIG5lZWQgZm9yIG1vZGlmaWVyLWNvbWJpbmluZyBsb2dpYy5cclxuICAgICAgICBzID0gaWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBsYXlvdXQgPSB0aGlzLmFjdGl2ZUtleWJvYXJkLmxheW91dChrZXlFdmVudC5kZXZpY2UuZm9ybUZhY3Rvcik7XHJcbiAgICAgIGlmKGxheW91dC5nZXRMYXllcihzKSkge1xyXG4gICAgICAgIHRoaXMubGF5ZXJJZCA9IHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sYXllcklkID0gJ2RlZmF1bHQnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzTW9kaWZpZXIoTGV2ZW50OiBLZXlFdmVudCk6IGJvb2xlYW4ge1xyXG4gICAgICBzd2l0Y2goTGV2ZW50Lkxjb2RlKSB7XHJcbiAgICAgICAgY2FzZSAxNjogLy9cIktfU0hJRlRcIjoxNixcIktfQ09OVFJPTFwiOjE3LFwiS19BTFRcIjoxOFxyXG4gICAgICAgIGNhc2UgMTc6IFxyXG4gICAgICAgIGNhc2UgMTg6IFxyXG4gICAgICAgIGNhc2UgMjA6IC8vXCJLX0NBUFNcIjoyMCwgXCJLX05VTUxPQ0tcIjoxNDQsXCJLX1NDUk9MTFwiOjE0NVxyXG4gICAgICAgIGNhc2UgMTQ0OlxyXG4gICAgICAgIGNhc2UgMTQ1OlxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IGV2ZW50IGlzIGEgbW9kaWZpZXIgcHJlc3MsIGFsbG93aW5nIGtleVByZXNzIHRvIHJldHVybiBzZWxlY3RpdmVseVxyXG4gICAgLy8gaW4gdGhvc2UgY2FzZXMuXHJcbiAgICBkb01vZGlmaWVyUHJlc3MoTGV2ZW50OiBLZXlFdmVudCwgb3V0cHV0VGFyZ2V0OiBPdXRwdXRUYXJnZXQsIGlzS2V5RG93bjogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgICBpZighdGhpcy5hY3RpdmVLZXlib2FyZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoTGV2ZW50Lkxjb2RlID09IDgpIHtcclxuICAgICAgICAvLyBJMzMxOCAoYWx3YXlzIGNsZWFyIGRlYWRrZXlzIGFmdGVyIGJhY2tzcGFjZSlcclxuICAgICAgICBvdXRwdXRUYXJnZXQuZGVhZGtleXMoKS5jbGVhcigpO1xyXG4gICAgICB9IGVsc2UgaWYoS2V5Ym9hcmRQcm9jZXNzb3IuaXNNb2RpZmllcihMZXZlbnQpKSB7XHJcbiAgICAgICAgLy8gRm9yIGV2ZW50dWFsIGludGVncmF0aW9uIC0gd2UgYnlwYXNzIGFuIE9TSyB1cGRhdGUgZm9yIHBoeXNpY2FsIGtleXN0cm9rZXMgd2hlbiBpbiB0b3VjaCBtb2RlLlxyXG4gICAgICAgIHRoaXMuYWN0aXZlS2V5Ym9hcmQubm90aWZ5KExldmVudC5MY29kZSwgb3V0cHV0VGFyZ2V0LCBpc0tleURvd24gPyAxIDogMCk7IFxyXG4gICAgICAgIGlmKCFMZXZlbnQuZGV2aWNlLnRvdWNoYWJsZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX1VwZGF0ZVZLU2hpZnQoTGV2ZW50LCBMZXZlbnQuTGNvZGUtMTUsIDEpOyAvLyBJMjE4N1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKExldmVudC5MbW9kaWZpZXJDaGFuZ2UpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZUtleWJvYXJkLm5vdGlmeSgwLCBvdXRwdXRUYXJnZXQsIDEpOyBcclxuICAgICAgICB0aGlzLl9VcGRhdGVWS1NoaWZ0KExldmVudCwgMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG1vZGlmaWVyIGtleXByZXNzZXMgZGV0ZWN0ZWQuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXNldENvbnRleHQoKSB7XHJcbiAgICAgIHRoaXMubGF5ZXJJZCA9ICdkZWZhdWx0JztcclxuXHJcbiAgICAgIHRoaXMua2V5Ym9hcmRJbnRlcmZhY2UucmVzZXRDb250ZXh0Q2FjaGUoKTtcclxuICAgICAgdGhpcy5fVXBkYXRlVktTaGlmdChudWxsLCAxNSwgMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNldE51bWVyaWNMYXllcihkZXZpY2U6IHV0aWxzLkRldmljZVNwZWMpIHtcclxuICAgICAgbGV0IGxheW91dCA9IHRoaXMuYWN0aXZlS2V5Ym9hcmQubGF5b3V0KGRldmljZS5mb3JtRmFjdG9yKTtcclxuICAgICAgaWYobGF5b3V0LmdldExheWVyKCdudW1lcmljJykpIHtcclxuICAgICAgICB0aGlzLmxheWVySWQgPSAnbnVtZXJpYyc7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gIGxldCBucyA9IGNvbS5rZXltYW4udGV4dDtcclxuXHJcbiAgLy8gTGV0IHRoZSBLZXlib2FyZCBQcm9jZXNzb3IgYmUgYXZhaWxhYmxlIGJvdGggaW4gdGhlIGJyb3dzZXIgYW5kIGluIE5vZGUuXHJcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gbnMuS2V5Ym9hcmRQcm9jZXNzb3I7XHJcbiAgICAvL0B0cy1pZ25vcmVcclxuICAgIG5zLktleWJvYXJkUHJvY2Vzc29yLmNvbSA9IGNvbTsgLy8gRXhwb3J0IHRoZSByb290IG5hbWVzcGFjZSBzbyB0aGF0IGFsbCBLZXlib2FyZFByb2Nlc3NvciBjbGFzc2VzIGFyZSBhY2Nlc3NpYmxlIGJ5IHVuaXQgdGVzdHMuXHJcbiAgfVxyXG59KCkpOyIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cImluZGV4LnRzXCIgLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAva2V5Ym9hcmQtcHJvY2Vzc29yL3NyYy90ZXh0L2tleWJvYXJkUHJvY2Vzc29yLnRzXCIgLz5cclxuXHJcbm5hbWVzcGFjZSBLTVdSZWNvcmRlciB7XHJcbiAgZXhwb3J0IGNsYXNzIE5vZGVQcm9jdG9yIGV4dGVuZHMgUHJvY3RvciB7XHJcbiAgICBwcml2YXRlIGtleWJvYXJkOiBjb20ua2V5bWFuLmtleWJvYXJkcy5LZXlib2FyZDtcclxuICAgIHB1YmxpYyBfX2RlYnVnID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioa2V5Ym9hcmQ6IGNvbS5rZXltYW4ua2V5Ym9hcmRzLktleWJvYXJkLCBkZXZpY2U6IGNvbS5rZXltYW4udXRpbHMuRGV2aWNlU3BlYywgYXNzZXJ0OiBBc3NlcnRDYWxsYmFjaykge1xyXG4gICAgICBzdXBlcihkZXZpY2UsIGFzc2VydCk7XHJcblxyXG4gICAgICB0aGlzLmtleWJvYXJkID0ga2V5Ym9hcmQ7XHJcbiAgICB9XHJcblxyXG4gICAgYmVmb3JlQWxsKCkge1xyXG4gICAgICAvL1xyXG4gICAgfVxyXG5cclxuICAgIGJlZm9yZSgpIHtcclxuICAgICAgLy9cclxuICAgIH1cclxuXHJcbiAgICBjb21wYXRpYmxlV2l0aFN1aXRlKHRlc3RTdWl0ZTogS2V5Ym9hcmRUZXN0KTogYm9vbGVhbiB7XHJcbiAgICAgIC8vIE9yaWdpbmFsLXZlcnNpb24gdGVzdHMgZGlkIG5vdCBzdXBwbHkgY29yZS1jb21wYXRpYmxlIEtleUV2ZW50IGRhdGEuXHJcbiAgICAgIHJldHVybiAhdGVzdFN1aXRlLnNwZWNWZXJzaW9uLmVxdWFscyhLZXlib2FyZFRlc3QuRkFMTEJBQ0tfVkVSU0lPTik7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGRlYnVnTW9kZSgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX19kZWJ1ZztcclxuICAgIH1cclxuXHJcbiAgICBzZXQgZGVidWdNb2RlKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgIHRoaXMuX19kZWJ1ZyA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIG1hdGNoZXNUZXN0U2V0KHRlc3RTZXQ6IFRlc3RTZXQ8YW55Pikge1xyXG4gICAgICAvLyBLZXlib2FyZFByb2Nlc3NvciBpcyBhYnN0cmFjdCBlbm91Z2ggdG8gcnVuIHRlc3RzIGFpbWVkIGF0IGFueSBwbGF0Zm9ybS5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2ltdWxhdGVTZXF1ZW5jZShzZXF1ZW5jZTogVGVzdFNlcXVlbmNlPGFueT4sIHRhcmdldD86IGNvbS5rZXltYW4udGV4dC5PdXRwdXRUYXJnZXQpOiBzdHJpbmcge1xyXG4gICAgICAvLyBTdGFydCB3aXRoIGFuIGVtcHR5IE91dHB1dFRhcmdldCBhbmQgYSBmcmVzaCBLZXlib2FyZFByb2Nlc3Nvci5cclxuICAgICAgaWYoIXRhcmdldCkge1xyXG4gICAgICAgIHRhcmdldCA9IG5ldyBjb20ua2V5bWFuLnRleHQuTW9jaygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFc3RhYmxpc2ggYSBmcmVzaCBwcm9jZXNzb3IsIHNldHRpbmcgaXRzIGtleWJvYXJkIGFwcHJvcHJpYXRlbHkgZm9yIHRoZSB0ZXN0LlxyXG4gICAgICBsZXQgcHJvY2Vzc29yID0gbmV3IGNvbS5rZXltYW4udGV4dC5LZXlib2FyZFByb2Nlc3NvcigpO1xyXG4gICAgICBwcm9jZXNzb3IuYWN0aXZlS2V5Ym9hcmQgPSB0aGlzLmtleWJvYXJkO1xyXG5cclxuICAgICAgaWYoc2VxdWVuY2UgaW5zdGFuY2VvZiBSZWNvcmRlZEtleXN0cm9rZVNlcXVlbmNlKSB7XHJcbiAgICAgICAgZm9yKGxldCBrZXlzdHJva2Ugb2Ygc2VxdWVuY2UuaW5wdXRzKSB7XHJcbiAgICAgICAgICBsZXQga2V5RXZlbnQ6IGNvbS5rZXltYW4udGV4dC5LZXlFdmVudDtcclxuICAgICAgICAgIGlmKGtleXN0cm9rZSBpbnN0YW5jZW9mIFJlY29yZGVkUGh5c2ljYWxLZXlzdHJva2UpIHtcclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBrZXlzdHJva2UncyBzdG9yZWQgZGF0YSB0byByZWNvbnN0cnVjdCB0aGUgS2V5RXZlbnQuXHJcbiAgICAgICAgICAgIGtleUV2ZW50ID0ge1xyXG4gICAgICAgICAgICAgIExjb2RlOiBrZXlzdHJva2Uua2V5Q29kZSxcclxuICAgICAgICAgICAgICBMbW9kaWZpZXJzOiBrZXlzdHJva2UubW9kaWZpZXJzLFxyXG4gICAgICAgICAgICAgIExtb2RpZmllckNoYW5nZToga2V5c3Ryb2tlLm1vZGlmaWVyQ2hhbmdlZCxcclxuICAgICAgICAgICAgICB2a0NvZGU6IGtleXN0cm9rZS52a0NvZGUsXHJcbiAgICAgICAgICAgICAgTHN0YXRlczoga2V5c3Ryb2tlLnN0YXRlcyxcclxuICAgICAgICAgICAgICBrTmFtZTogJycsXHJcbiAgICAgICAgICAgICAgZGV2aWNlOiB0aGlzLmRldmljZSxcclxuICAgICAgICAgICAgICBpc1N5bnRoZXRpYzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgTGlzVmlydHVhbEtleTogdGhpcy5rZXlib2FyZC5kZWZpbmVzUG9zaXRpb25hbE9yTW5lbW9uaWMgLy8gT25seSBmYWxzZSBmb3IgMS4wIGtleWJvYXJkcy5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmKGtleXN0cm9rZSBpbnN0YW5jZW9mIFJlY29yZGVkU3ludGhldGljS2V5c3Ryb2tlKSB7XHJcbiAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLmtleWJvYXJkLmxheW91dCh0aGlzLmRldmljZS5mb3JtRmFjdG9yKS5nZXRMYXllcihrZXlzdHJva2UubGF5ZXIpLmdldEtleShrZXlzdHJva2Uua2V5TmFtZSk7XHJcbiAgICAgICAgICAgIGtleUV2ZW50ID0ga2V5LmNvbnN0cnVjdEtleUV2ZW50KHByb2Nlc3NvciwgdGhpcy5kZXZpY2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZpbGwgaW4gdGhlIGZpbmFsIGRldGFpbHMgb2YgdGhlIEtleUV2ZW50Li4uXHJcbiAgICAgICAgICBrZXlFdmVudC5kZXZpY2UgPSB0aGlzLmRldmljZTtcclxuXHJcbiAgICAgICAgICAvLyBBbmQgbm93LCBleGVjdXRlIHRoZSBrZXlzdHJva2UhXHJcbiAgICAgICAgICAvLyBXZSBkb24ndCBjYXJlIHRvbyBtdWNoIGFib3V0IHBhcnRpY3VsYXJpdGllcyBvZiBwZXIta2V5c3Ryb2tlIGJlaGF2aW9yIHlldC5cclxuICAgICAgICAgIC8vIC4uLiB3ZSBfY291bGRfIGlmIHdlIHdhbnRlZCB0bywgdGhvdWdoLiAgVGhlIGZyYW1ld29yayBpcyBtb3N0bHkgaW4gcGxhY2U7IFxyXG4gICAgICAgICAgLy8gaXQncyBhIG1hdHRlciBvZiBhY3R1YWxseSBhZGRpbmcgdGhlIGZlYXR1cmUuXHJcbiAgICAgICAgICBsZXQgcnVsZUJlaGF2aW9yID0gcHJvY2Vzc29yLnByb2Nlc3NLZXlzdHJva2Uoa2V5RXZlbnQsIHRhcmdldCk7XHJcblxyXG4gICAgICAgICAgaWYodGhpcy5kZWJ1Z01vZGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkodGFyZ2V0LCBudWxsLCAnICAnKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHJ1bGVCZWhhdmlvciwgbnVsbCwgJyAgJykpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlUHJvY3RvciBvbmx5IHN1cHBvcnRzIFJlY29yZGVkS2V5c3Ryb2tlU2VxdWVuY2VzIGZvciB0ZXN0aW5nIGF0IHByZXNlbnQuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YXJnZXQuZ2V0VGV4dCgpO1xyXG4gICAgfVxyXG5cclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCB0aGUgbmFtZXNwYWNlIGl0c2VsZiwgZ2l2aW5nIGFjY2VzcyB0byBhbGwgY29udGFpbmVkIGNsYXNzZXMuXHJcbm1vZHVsZS5leHBvcnRzID0gS01XUmVjb3JkZXI7Il19