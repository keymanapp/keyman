(*
  Name:             COMMessageEditor
  Copyright:        Copyright (C) SIL International.
  Documentation:    
  Description:      
  Create Date:      20 Jun 2006

  Modified Date:    26 Jun 2012
  Authors:          mcdurdin
  Related Files:    
  Dependencies:     

  Bugs:             
  Todo:             
  Notes:            
  History:          20 Jun 2006 - mcdurdin - Initial version
                    04 Dec 2006 - mcdurdin - Save identifiers to a second .pas file as well
                    17 May 2012 - mcdurdin - I3321 - V9.0 - Fixup paths in Delphi source for v9.0
                    17 May 2012 - mcdurdin - I3310 - V9.0 - Unicode in Delphi fixes
                    08 Jun 2012 - mcdurdin - I3310 - V9.0 - Unicode in Delphi fixes
                    26 Jun 2012 - mcdurdin - I3377 - KM9 - Update code references from 8.0 to 9.0
*)
unit COMMessageEditor;

interface

uses
  System.Types,
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, Grids, contnrs, StringGridEditControlled;

type
  TCOMMessage = class
  private
    function GetTextHashed: string;
    procedure SetTextHashed(const Value: string);
  public
    Name: string;
    Code: Integer;
    Text: string;
    Source: string;
    HelpContext: Integer;
    Args: string;
    property TextHashed: string read GetTextHashed write SetTextHashed;
  end;

  TCOMMessages = class(TObjectList)
  private
    function GetItem(Index: Integer): TCOMMessage;
    procedure SetItem(Index: Integer; const Value: TCOMMessage);
  public
    function LastCode: Integer;
    property Items[Index: Integer]: TCOMMessage read GetItem write SetItem; default;
  end;

  TfrmCOMMessages = class(TForm)
    gridMessages: TStringGrid;
    cmdLoad: TButton;
    cmdSave: TButton;
    cmdAdd: TButton;
    cmdDelete: TButton;
    procedure cmdSaveClick(Sender: TObject);
    procedure cmdLoadClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure gridMessagesCanEditShow(Sender: TStringGridEditControlled;
      ACol, ARow: Integer; var CanShow: Boolean);
    procedure gridMessagesSelectCell(Sender: TObject; ACol, ARow: Integer;
      var CanSelect: Boolean);
    procedure gridMessagesSetEditText(Sender: TObject; ACol, ARow: Integer;
      const Value: String);
    procedure cmdAddClick(Sender: TObject);
    procedure cmdDeleteClick(Sender: TObject);
    procedure FormShow(Sender: TObject);
  private
    Messages: TCOMMessages;
    procedure FillGrid;
  public
    { Public declarations }
  end;

implementation

uses
  SourceRootPath;

{$R *.DFM}

procedure TfrmCOMMessages.cmdSaveClick(Sender: TObject);
var
  f: TStringList;

    procedure Generate(const UnitName: string; FStrings: Boolean);
    var
      EndComma: string;
      i: Integer;
    begin
      f.Clear;
      f.Add('{This file has been autogenerated by '+ParamStr(0)+' - COMMessages at '+FormatDateTime('dd/mm/yyyy hh:nn:ss', Now) + '}');
      f.Add('unit '+UnitName+';');
      f.Add('');
      f.Add('interface');
      f.Add('');
      f.Add('type');
      f.Add('  TKeymanErrorInfo = record');
      f.Add('    Message: string;');
      f.Add('    Source: string;');
      f.Add('    HelpContext: Integer;');
      f.Add('    Args: string;');
      f.Add('  end;');
      f.Add('');
      f.Add('const');
      f.Add('  KMN_E_BASE = $A0000200;');
      f.Add('  KMN_W_BASE = $20000200;');
      f.Add('');
      f.Add('const');
      f.Add('{ Start Message Identifiers }');
      for i := 0 to Messages.Count - 1 do
        f.Add(Format('  %s = %s_BASE + $%x;', [Messages[i].Name, Copy(Messages[i].Name, 1, 5), Messages[i].Code]));

      f.Add('{ End Message Identifiers }');
      f.Add('');
      f.Add(Format('  KMN_E_LAST = $A000%4.4x;', [Messages.LastCode+$200]));
      f.Add(Format('  KMN_W_LAST = $2000%4.4x;', [Messages.LastCode+$200]));
      f.Add('');

      if FStrings then
      begin
        f.Add('const');
        f.Add(Format('  KeymanErrors: array[KMN_E_BASE and $FFFF..KMN_E_LAST and $FFFF] of TKeymanErrorInfo = (', [Messages.LastCode+$200]));
        f.Add('{ Start Message Info }');
        for i := 0 to Messages.Count - 1 do
        begin
          if i = Messages.Count-1 then EndComma := '' else EndComma := ',';
          f.Add(Format('    {%s} (Message: ''%s''; Source: ''%s''; HelpContext: %d; Args: ''%s'')%s  // %s', [Messages[i].Name, Messages[i].TextHashed, Messages[i].Source, Messages[i].HelpContext, Messages[i].Args, EndComma, Messages[i].Text]));
        end;
        f.Add('{ End Message Info }');
        f.Add('  );');
        f.Add('');
      end;

      f.Add('implementation');
      f.Add('');
      f.Add('end.');
    end;

var
  i: Integer;
begin
  for i := 0 to Messages.Count - 1 do Messages[i].Code := i;

  f := TStringList.Create;
  try
    Generate('keymanerrorcodes', True);
    f.SaveToFile(CSourceRootPath+'\engine\kmcomapi\util\keymanerrorcodes.pas', TEncoding.UTF8);  // I3321  // I3310

    Generate('kmcomapi_errors', False);
    f.SaveToFile(CSourceRootPath+'\global\delphi\general\kmcomapi_errors.pas', TEncoding.UTF8);  // I3321  // I3310
  finally
    f.Free;
  end;
end;

{ TCOMMessage }

function TCOMMessage.GetTextHashed: string;
var
  i: Integer;
  InQuotes: Boolean;
begin
  Result := '';
  InQuotes := True;
  for i := 1 to Length(Text) do
    if (Text[i] < #32) or (Text[i] = '''') then
    begin
      if InQuotes then begin Result := Result + ''''; InQuotes := False; end;
      Result := Result + '#'+IntToStr(Ord(Text[i]));
    end
    else
    begin
      if not InQuotes then begin Result := Result + ''''; InQuotes := True; end;
      Result := Result + Text[i];
    end;

  if not InQuotes then Result := Result + '''';
end;

procedure TCOMMessage.SetTextHashed(const Value: string);
var
  i: Integer;
  InQuotes: Boolean;
begin
  Text := '';
  InQuotes := True;
  i := 1;
  while i <= Length(Value) do
  begin
    if not InQuotes then
      if Value[i] = '#' then
      begin
        Inc(i); if i > Length(Value) then raise Exception.Create('Invalid hashed text - invalid char code (1)');
        if not CharInSet(Value[i], ['0'..'9']) then raise Exception.Create('Invalid hashed text - invalid char code (2)');  // I3310
        Inc(i);
        if CharInSet(Value[i], ['0'..'9']) then  // I3310
        begin
          Text := Text + Chr(StrToInt(Copy(Value, i-1, 2)));
          Inc(i);
        end
        else
          Text := Text + Chr(StrToInt(Copy(Value, i-1, 1)));
      end
      else if Value[i] = '''' then
      begin
        InQuotes := True;
        Inc(i);
      end
      else raise Exception.Create('Invalid hashed text')
    else
      if Value[i] = '''' then
      begin
        InQuotes := False;
        Inc(i);
      end
      else
      begin
        Text := Text + Value[i];
        Inc(i);
      end;
  end;
  if not InQuotes then raise Exception.Create('Invalid hashed text - unterminated string constant');
end;

procedure TfrmCOMMessages.cmdLoadClick(Sender: TObject);
var
  f: TStringList;
  m: TCOMMessage;
  s: string;
  n, i, j, StartMID, EndMID, StartMInfo, EndMInfo: Integer;
begin
  f := TStringList.Create;
  f.LoadFromFile(CSourceRootPath+'\engine\kmcomapi\util\keymanerrorcodes.pas');  // I3321
  StartMID := -1; EndMID := -1; StartMInfo := -1; EndMinfo := -1;
  for n := 0 to f.Count - 1 do
  begin
    if f[n] = '{ Start Message Identifiers }' then StartMID := n+1
    else if f[n] = '{ End Message Identifiers }' then EndMID := n-1
    else if f[n] = '{ Start Message Info }' then StartMInfo := n+1
    else if f[n] = '{ End Message Info }' then EndMInfo := n-1;
  end;

  if (StartMID = -1) or (EndMID = -1) or (StartMInfo = -1) or (EndMinfo = -1) then
    raise Exception.Create('Could not find ids or infos');

  for i := StartMID to EndMID do
  begin
    if f[i] = '' then Continue;
    s := Trim(f[i]);
    if Copy(s,1,2) = '//' then Continue;
    m := TCOMMessage.Create;  //  %s: Cardinal = KMN_E_BASE + $%x;
    Messages.Add(m);
    n := Pos(' ', s); if n = 0 then Continue;
    m.Name := Copy(s, 1, n-1);
    Delete(s, 1, n);
    n := Pos('$', s); if n = 0 then Continue;
    Delete(s, 1, n);
    n := Pos(';', s); if n = 0 then Continue;
    Delete(s, n, Length(s));
    m.Code := StrToInt('$' + s);
  end;

  for i := StartMInfo to EndMInfo do
  begin
    if f[i] = '' then Continue;
    s := Trim(f[i]);
    if Copy(s,1,2) = '//' then Continue;

    m := nil;     // {%s} (Message: ''%s''; Source: ''%s''; HelpContext: %d; Args: ''%s'')

    n := Pos('{', s); if n = 0 then Continue;
    Delete(s,1,n);
    n := Pos('}', s); if n = 0 then Continue;
    for j := 0 to Messages.Count - 1 do
      if Messages[j].Name = Copy(s,1,n-1) then
      begin
        m := Messages[j]; Break;
      end;
    if not Assigned(m) then Continue;

    n := Pos('''', s); if n = 0 then Continue;
    Delete(s,1,n);
    n := Pos('''', s); if n = 0 then Continue;
    m.TextHashed := Copy(s, 1, n-1);
    Delete(s, 1, n);

    n := Pos('''', s); if n = 0 then Continue;
    Delete(s,1,n);
    n := Pos('''', s); if n = 0 then Continue;
    m.Source := Copy(s, 1, n-1);
    Delete(s, 1, n);

    n := Pos(':', s); if n = 0 then Continue;
    Delete(s,1,n); s := Trim(s);
    n := Pos(';', s); if n = 0 then Continue;
    m.HelpContext := StrToInt(Copy(s, 1, n-1));
    Delete(s, 1, n);

    n := Pos('''', s); if n = 0 then Continue;
    Delete(s,1,n);
    n := Pos('''', s); if n = 0 then Continue;
    m.Args := Copy(s, 1, n-1);
  end;

  f.Free;

  FillGrid;
end;

procedure TfrmCOMMessages.FormCreate(Sender: TObject);
begin
  Messages := TCOMMessages.Create;
  gridMessages.Col := 1;
  cmdLoadClick(cmdLoad);
end;

procedure TfrmCOMMessages.FormDestroy(Sender: TObject);
begin
  Messages.Free;
end;

{ TCOMMessages }                            

function TCOMMessages.GetItem(Index: Integer): TCOMMessage;
begin
  Result := inherited GetItem(Index) as TCOMMessage;
end;

function TCOMMessages.LastCode: Integer;
var
  i: Integer;
begin
  Result := 0;
  for i := 0 to Count - 1 do if Result < Items[i].Code then Result := Items[i].Code;
end;

procedure TCOMMessages.SetItem(Index: Integer; const Value: TCOMMessage);
begin
  inherited SetItem(Index, Value);
end;

procedure TfrmCOMMessages.FillGrid;
var
  i: Integer;
begin
  gridMessages.RowCount := Messages.Count + 1;
  gridMessages.Cells[0, 0] := 'Code';
  gridMessages.Cells[1, 0] := 'Name';
  gridMessages.Cells[2, 0] := 'Text';
  gridMessages.Cells[3, 0] := 'Source';
  gridMessages.Cells[4, 0] := 'HelpContext';
  gridMessages.Cells[5, 0] := 'Arguments';
  for i := 0 to Messages.Count - 1 do
  begin
    gridMessages.Objects[0, i+1] := Messages[i];
    gridMessages.Cells[0, i+1] := IntToStr(Messages[i].Code);
    gridMessages.Cells[1, i+1] := Messages[i].Name;
    gridMessages.Cells[2, i+1] := Messages[i].Text;
    gridMessages.Cells[3, i+1] := Messages[i].Source;
    gridMessages.Cells[4, i+1] := IntToStr(Messages[i].HelpContext);
    gridMessages.Cells[5, i+1] := Messages[i].Args;
  end;
end;

procedure TfrmCOMMessages.gridMessagesCanEditShow(
  Sender: TStringGridEditControlled; ACol, ARow: Integer;
  var CanShow: Boolean);
begin
  CanShow := ACol > 0;
end;

procedure TfrmCOMMessages.gridMessagesSelectCell(Sender: TObject; ACol,
  ARow: Integer; var CanSelect: Boolean);
begin
  CanSelect := ACol > 0;
end;

procedure TfrmCOMMessages.gridMessagesSetEditText(Sender: TObject; ACol,
  ARow: Integer; const Value: String);
var
  m: TCOMMessage;
begin
  m := gridMessages.Objects[0, ARow] as TCOMMessage;
  if not Assigned(m) then Exit;
  case ACol of
    1: m.Name := Value;
    2: m.Text := Value;
    3: m.Source := Value;
    4: m.HelpContext := StrToInt(Value);
    5: m.Args := Value;
  end;
end;

procedure TfrmCOMMessages.cmdAddClick(Sender: TObject);
var
  m: TCOMMessage;
begin
  m := TCOMMessage.Create;
  m.Code := Messages.LastCode + 1;
  Messages.Add(m);
  gridMessages.RowCount := gridMessages.RowCount + 1;
  gridMessages.Objects[0,gridMessages.RowCount-1] := m;
  gridMessages.Row := gridMessages.RowCount-1;
  gridMessages.Cells[0, gridMessages.RowCount-1] := IntToStr(m.Code);
end;

procedure TfrmCOMMessages.cmdDeleteClick(Sender: TObject);
var
  i, j: Integer;
begin
  Messages.Remove(gridMessages.Objects[0, gridMessages.Row]);
  for i := gridMessages.Row + 1 to gridMessages.RowCount - 1 do
  begin
    gridMessages.Objects[0, i-1] := gridMessages.Objects[0, i];
    for j := 0 to gridMessages.ColCount - 1 do
      gridMessages.Cells[j, i-1] := gridMessages.Cells[j, i];
  end;
  gridMessages.RowCount := gridMessages.RowCount - 1;
end;

procedure TfrmCOMMessages.FormShow(Sender: TObject);
begin
  ShowWindow(Handle, SW_SHOWNORMAL);
  ShowWindow(Handle, SW_MAXIMIZE);
end;

end.
