unit Keyman.System.BuildLibPalasoAllTags;

interface

type
  TBuildLibPalasoAllTags = class
    class procedure Build(AllTagsFile, DestinationFile: string);
  end;

implementation

uses
  System.Classes,
  System.Generics.Collections,
  System.StrUtils,
  System.SysUtils;

{ TBuildLibPalasoAllTags }

class procedure TBuildLibPalasoAllTags.Build(AllTagsFile,
  DestinationFile: string);
var
  FAllTags: TStringList;
  FResult: TStringList;
  i, j: Integer;
  s: string;
  items: TArray<string>;
  t: string;
  dict: TStringList; //not a TDictionary because we want sorted keys
  n: Integer;
  lang: string;
  vi: TStringList;
begin
  FAllTags := TStringList.Create;
  try
    FAllTags.LoadfromFile(AllTagsFile, TEncoding.UTF8);
    FResult := TStringList.Create;
    try

      FResult.Add('unit Keyman.System.Standards.LibPalasoAllTagsRegistry;');
      FResult.Add('');
      FResult.Add('interface');
      FResult.Add('');
      FResult.Add('// File-Date: '+FormatDateTime('yyyy-mm-dd hh:nn:ss', Now));
      FResult.Add('// Extracted from https://raw.githubusercontent.com/silnrsi/sldr/master/extras/alltags.txt');
      FResult.Add('// Generated by build_standards_data');
      FResult.Add('');
      FResult.Add('uses');
      FResult.Add('  System.Generics.Collections;');
      FResult.Add('');
      FResult.Add('type');
      FResult.Add('  TLibPalasoAllTagsMap = class');
      FResult.Add('  public');
      FResult.Add('    class procedure Fill(dict: TDictionary<string,TArray<string>>);');
      FResult.Add('  end;');
      FResult.Add('');
      FResult.Add('implementation');
      FResult.Add('');
      FResult.Add('{ TLibPalasoAllTagsMap }');
      FResult.Add('');
      FResult.Add('class procedure TLibPalasoAllTagsMap.Fill(dict: TDictionary<string,TArray<string>>);');
      FResult.Add('begin');

      dict := TStringList.Create; //' TArray<string,TArray<string>>.Create;
      try
        for i := 0 to FAllTags.Count - 1 do
        begin
          // Line format: ignore '*'
          s := FAllTags[i];
          items := s.Split([' ','=','*'], TStringSplitOptions.ExcludeEmpty);
          if Length(items) = 0 then
            Continue;

          n := items[0].IndexOf('-');
          if n >= 0 then
          begin
            // This is a lang-script tag. So we will
            // strip the basic
            lang := items[0].Substring(0, n);
          end
          else
          begin
            lang := items[0];
            items := Copy(items, 1, Length(items)-1);
          end;

          n := dict.IndexOf(lang);
          if n < 0 then
          begin
            vi := TStringList.Create;
            vi.AddStrings(items);
            dict.AddObject(lang, vi);
          end
          else
          begin
            vi := dict.Objects[n] as TStringList;
            vi.AddStrings(items);
          end;
        end;

        for i := 0 to dict.Count - 1 do
        begin
          t := Format('  dict.Add(''%s'', [', [dict[i]]);

          vi := dict.Objects[i] as TStringList;
          for j := 0 to vi.Count - 1 do
          begin
            if j > 0 then
            begin
              t := t + ', ';
              if (j mod 8) = 0 then
                t := t + #13#10;
            end;
            t := t + Format('''%s''', [vi[j]]);
          end;
          vi.Free;

          t := t + ']);';
          FResult.Add(t);
        end;
      finally
        dict.Free;
      end;

      FResult.Add('end;');
      FResult.Add('');
      FResult.Add('end.');

      FResult.SaveToFile(DestinationFile, TEncoding.UTF8);
    finally
      FResult.Free;
    end;
  finally
    FAllTags.Free;
  end;
end;

end.
