/*
  Name:             kmkey
  Copyright:        Copyright (C) SIL International.
  Documentation:    
  Description:      
  Create Date:      19 Jun 2007

  Modified Date:    28 Mar 2016
  Authors:          mcdurdin
  Related Files:    
  Dependencies:     

  Bugs:             
  Todo:             
  Notes:            
  History:          19 Jun 2007 - mcdurdin - I890 - Deadkeys not working correctly in TSF
                    19 Jun 2007 - mcdurdin - I822 - TSF Addin not working
                    07 Sep 2009 - mcdurdin - I2095 - TSF addin is not threadsafe
                    07 Nov 2012 - mcdurdin - I3549 - V9.0 - x64 version of kmtip addin
                    17 Nov 2012 - mcdurdin - I3567 - V9.0 - KeymanProcessOutput and KeymanGetContext return S_OK but are declared as BOOL
                    17 Nov 2012 - mcdurdin - I3568 - V9.0 - Support legacy output by testing for transitory context
                    20 Nov 2012 - mcdurdin - I3581 - V9.0 - KMTip needs to pass activated profile guid through to Keyman32 to switch keyboards
                    20 Nov 2012 - mcdurdin - I3581 - V9.0 - KMTip needs to pass activated profile guid through to Keyman32 to switch keyboards
                    28 Nov 2012 - mcdurdin - I3588 - V9.0 - Use preserved keys in TSF to handle key combinations in Keyman
                    28 Nov 2012 - mcdurdin - I3589 - V9.0 - Handle key state for KeyUp events in TSF
                    28 Nov 2012 - mcdurdin - I3590 - V9.0 - Initialise keystroke sink after we know which keyboard to activate
                    01 Dec 2012 - mcdurdin - I3608 - V9.0 - Shortcut test for VK_PACKET in kmtip
                    01 May 2014 - mcdurdin - I4201 - V9.0 - Shift + Arrows do not select text (only move caret) in Win 8 when Keyman keyboard is active
                    10 Jun 2014 - mcdurdin - I4262 - V9.0 - TSF deadkeys do not function correctly
                    16 Jun 2014 - mcdurdin - I4274 - V9.0 - kmtip does not work if already active before KM starts
                    13 Aug 2014 - mcdurdin - I4375 - V9.0 - Add registry flag deep integration to allow us to disable TIP context
                    13 Aug 2014 - mcdurdin - I4370 - Deadkeys are still not working in Winword TIP mode
                    14 Aug 2014 - mcdurdin - I4378 - V9.0 - Rapid typing in legacy mode breaks Keyman input
                    28 Mar 2016 - mcdurdin - I4933 - Compat issue with Firefox 42 and IE and Keyman 9 TSF
*/

#include "globals.h"
#include "kmtip.h"
#include "editsess.h"
#include "Compiler.h"
#include "registry.h"

struct deadkeyinfo
{
	int pos, val;
};

class CKeymanEditSession : public CEditSessionBase
{
public:
  CKeymanEditSession(ITfContext *pContext, HMODULE hKeyman, WPARAM wParam, LPARAM lParam, BOOL fUpdate, BOOL fPreserved, DWORD dwDeepIntegration) : CEditSessionBase(pContext)   // I3588   // I4375
  {
		_hKeyman = hKeyman;
    _wParam = wParam;
    _lParam = lParam;   // I3589
		_fUpdate = fUpdate;
    _fPreserved = fPreserved;   // I3588
    _dwDeepIntegration = dwDeepIntegration;   // I4375
  }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);

	HRESULT WINAPI KeymanProcessOutput(int n, PWSTR buf, int nbuf);   // I3567
	HRESULT WINAPI KeymanGetContext(int n, PWSTR buf);   // I3567
	HRESULT GetResult() { return _hr; }

private:
	BOOL _fUpdate;
  BOOL _fPreserved;   // I3588
	HRESULT _hr;
	HMODULE _hKeyman;
  WPARAM _wParam;
  LPARAM _lParam;   // I3589
  DWORD _dwDeepIntegration;   // I4375
	TfEditCookie _ec;
};

BOOL CKMTipTextService::_CheckKeymanLoaded() {   // I4274
  HMODULE hKeyman;

#ifdef _WIN64
	hKeyman = GetModuleHandle("keyman64.dll");   // I3549
#else
	hKeyman = GetModuleHandle("keyman32.dll");
#endif
  
  if(hKeyman == NULL) {
    _hKeyman = NULL;
    return FALSE;
  }

  if(hKeyman != _hKeyman) {
    _hKeyman = NULL;

    if(!_LoadKeyman() || !_InitKeyman()) {
      return FALSE;
    }
    TIPNotifyActivate(&guidActiveProfile);
  }

  return TRUE;
}

#define KEYEVENT_EXTRAINFO_KEYMAN 0xF00F0000   // I4370

BOOL CKMTipTextService::_KeymanProcessKeystroke(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL fUpdate, BOOL fPreserved)   // I3588
{
	CKeymanEditSession *pEditSession;
	HRESULT hr = S_OK;

  // Don't process Unicode characters injected or ProcessKey events which are generated by Windows
  if(wParam == VK_PACKET || wParam == VK_PROCESSKEY) return FALSE;   // I3608   // I4201

  Log(L"_KeymanProcessKeystroke (%x %x %s %s ex=%x)", wParam, lParam, fUpdate?L"update":L"", fPreserved?L"preserved":L"", GetMessageExtraInfo());   // I4378

  // Don't process keystrokes generated by Keyman (scan code = 0xFF)
  if((lParam & 0xFF0000) == 0xFF0000) return FALSE;   // I4378

  if(!_CheckKeymanLoaded()) {   // I4274
    return FALSE;
  }

  // we'll insert a char ourselves in place of this keystroke
  if ((pEditSession = new CKeymanEditSession(pContext, _hKeyman, wParam, lParam, fUpdate, fPreserved, _dwDeepIntegration)) == NULL)   // I3588   // I3589   // I4375
  {
		hr = E_OUTOFMEMORY;
  }
	else
	{
		if (pContext->RequestEditSession(_tfClientId, pEditSession, 
			fUpdate ? TF_ES_SYNC | TF_ES_READWRITE : TF_ES_SYNC | TF_ES_READ, &hr) != S_OK)
		{
			hr = E_FAIL;
		}
		else hr = pEditSession->GetResult();
		pEditSession->Release();
	}

  return hr == S_OK;
}

//+---------------------------------------------------------------------------
//
// CKeymanEditSession
//
//----------------------------------------------------------------------------

CKeymanEditSession *ExtEditSession = NULL;

extern "C" __declspec(dllexport) HRESULT WINAPI ExtKeymanProcessOutput(int n, WCHAR *buf, int nbuf)   // I3567
{
	HRESULT res;
	if(ExtEditSession) res = ExtEditSession->KeymanProcessOutput(n, buf, nbuf);
	else res = E_FAIL;   // I3567
	return res;
}

extern "C" __declspec(dllexport) HRESULT WINAPI ExtKeymanGetContext(int n, PWSTR buf)   // I3567
{
	HRESULT res;
	if(ExtEditSession) res = ExtEditSession->KeymanGetContext(n, buf);
	else res = E_FAIL;   // I3567
	return res;
}

typedef BOOL (WINAPI *PTIPACTIVATEFUNC)(BOOL fActivate);
typedef BOOL (WINAPI *PTIPACTIVATEKEYBOARDFUNC)(GUID *profile);   // I3581
typedef HRESULT (WINAPI *PKEYMANPROCESSOUTPUTFUNC)(int n, WCHAR *buf, int nbuf);   // I3567
typedef HRESULT (WINAPI *PKEYMANGETCONTEXTFUNC)(int n, PWSTR buf);   // I3567
typedef BOOL (WINAPI *PTIPPROCESSKEYFUNC)(WPARAM wParam, LPARAM lParam, PKEYMANPROCESSOUTPUTFUNC outfunc,   // I3588   // I3589
										  PKEYMANGETCONTEXTFUNC ctfunc, BOOL Updateable, BOOL Preserved);

STDAPI CKeymanEditSession::DoEditSession(TfEditCookie ec)
{
	_ec = ec;
	_hr = S_OK;

	ExtEditSession = this;

	PTIPPROCESSKEYFUNC pTIPProcessKey = (PTIPPROCESSKEYFUNC) GetProcAddress(_hKeyman, "TIPProcessKey");
	if(!pTIPProcessKey) 
	{
		_hr = E_FAIL;
	}
	else
  {
    if(!(*pTIPProcessKey)(_wParam, _lParam, ExtKeymanProcessOutput, ExtKeymanGetContext, _fUpdate, _fPreserved))   // I3588   // I3589
		  _hr = E_FAIL;
  }
	ExtEditSession = NULL;

	// Call keyman32.processtipkey; this may call "KeymanGetContext(n, buf)";
	// keyman32.processtipkey this will call "KeymanProcessOutput"
	// which will delete n chrs from left of cursor and output a text string
	// beeps, deadkeys, etc. will be managed from within keyman32.dll itself

	// At this point, the text will already have been output
	// callback will have the information necessary
	// to know what is happening -- make sure that pContext is available globally

	// we need a lock to do our work
	// nb: this method is one of the few places where it is legal to use
	// the TF_ES_SYNC flag

	return S_OK;
}

char *debugstr(PWSTR buf);

HRESULT WINAPI CKeymanEditSession::KeymanProcessOutput(int n, WCHAR *buf, int nbuf)   // I3567
{
  if(ShouldDebug()) {
    char *p = debugstr(buf);
  	Log(L"KeymanProcessOutput: fUpdate = %d, deleting %d, inserting %d '%hs'", _fUpdate, n, nbuf, p);   // I4262
    delete p;
  }
	
  if(_fUpdate) {
		/* Delete characters left of selection */ 
		DeleteLeftOfSelection(_ec, _pContext, n);

		/* Add text to screen */ 

		InsertTextAtSelection(_ec, _pContext, buf, nbuf);   // I4262
	}
  return S_OK;
}


HRESULT WINAPI CKeymanEditSession::KeymanGetContext(int n, PWSTR buf)   // I3567
{
  HRESULT hr;
  TF_STATUS tfStatus;

  if(_dwDeepIntegration == DEEPINTEGRATION_DISABLE) {   // I4375
    Log(L"KeymanGetContext: Exit: deep integration disabled by registry (or default)");
    return S_FALSE;
  }

  if(!SUCCEEDED(hr = _pContext->GetStatus(&tfStatus)))   // I3568
  {
    Log(L"KeymanGetContext: Exit -- Failed GetStatus = %x", hr);
    return hr;
  }

  if(tfStatus.dwStaticFlags & TF_SS_TRANSITORY)   // I3568
  {
    Log(L"KeymanGetContext: Exit: Context does not support manipulation.  Using legacy interaction");
    return S_FALSE;
  }

	if(!GetLeftOfSelection(_ec, _pContext, buf, n)) {   // I4933
    return S_FALSE;   // I4933
  }

	return S_OK;
}

BOOL CKMTipTextService::TIPNotifyActivate(GUID *guidProfile)   // I3581   // I4274
{
  _UninitKeystrokeSink();   // I3590
  if(!_InitKeystrokeSink()) {
    return FALSE;   // I3590
  }

  if(!_LoadKeyman()) {
    return FALSE;
  }

	PTIPACTIVATEKEYBOARDFUNC pTIPActivateKeyboard = (PTIPACTIVATEKEYBOARDFUNC) GetProcAddress(_hKeyman, "TIPActivateKeyboard");
	if(!pTIPActivateKeyboard) { 
    return FALSE; 
  }
	if(!(*pTIPActivateKeyboard)(guidProfile)) { 
    return FALSE; 
  }
  
  return _InitPreservedKeys();
}

BOOL CKMTipTextService::_LoadKeyman()   // I3590
{

#ifdef _WIN64
	_hKeyman = GetModuleHandle("keyman64.dll");   // I3549
#else
	_hKeyman = GetModuleHandle("keyman32.dll");
#endif

  return _hKeyman != NULL;
}
  
BOOL CKMTipTextService::_InitKeyman()   // I3590   // I4274
{
  if(_hKeyman == NULL) {
    return FALSE;
  }

	PTIPACTIVATEFUNC pTIPActivate = (PTIPACTIVATEFUNC) GetProcAddress(_hKeyman, "TIPActivateEx");   // I3581
	if(!pTIPActivate) { 
    _hKeyman = 0; 
    return FALSE; 
  }

	if(!(*pTIPActivate)(TRUE)) { 
    _hKeyman = 0; 
    return FALSE; 
  }

	return TRUE;
}

void CKMTipTextService::_UninitKeyman() {
	if(_hKeyman != NULL)	{
		PTIPACTIVATEFUNC pTIPActivate = (PTIPACTIVATEFUNC) GetProcAddress(_hKeyman, "TIPActivateEx");   // I3581
		if(pTIPActivate) {
      (*pTIPActivate)(FALSE);
    }
	}
	_hKeyman = NULL;
}
