import { assert } from 'chai';
import sinon from 'sinon';

import { KeyboardHarness, MinimalKeymanGlobal } from 'keyman/engine/keyboard';
import { DOMKeyboardLoader } from 'keyman/engine/keyboard/dom-keyboard-loader';
import { PathConfiguration } from 'keyman/engine/interfaces';
import { CloudQueryEngine, KeyboardRequisitioner, type KeyboardStub } from 'keyman/engine/keyboard-storage';
import DOMCloudRequester from 'keyman/engine/keyboard-storage/dom-requester';

const pathConfig = new PathConfiguration({
  root: '',
  resources: '/@keymanapp/keyman/src/resources',
  keyboards: '/', // The Karma config places them under `/resources/keyboards`, as expected by their 'stubs'.
  fonts: '',
  // The primary / top-level module here is the keyboard-cache bundle.
  // So, we set up our path config based upon that module for verification purposes.
}, 'http://localhost:9876/@keymanapp/keyman/build/engine/keyboard-storage/lib'); // TODO:  set up the current path like actual KMW does it.

/**
 * Performs mocking setup to facilitate unit testing for the `CloudQueryEngine` class.
 *
 * @param {*} queryResultsFile An absolute local filepath to a file containing the mocked results to generate.
 * @returns A fully-mocked `CloudQueryEngine` whose `.fetchCloudStubs()` call will yield a Promise for the
 *          expected mocked results.
 */
function mockQuery(querier: CloudQueryEngine, queryResultsFile: string) {
  const mockedRequester = (querier as any).requestEngine;        // Would attempt to https-request.
  const mockingRequester = new DOMCloudRequester(true); // Used to replace that with a local request.

  // Promises are tracked via their queryId, which is generated by the requester.
  // We need to apply it before allowing the actual registration method to execute.
  const idInjector = {
    registerFromCloud: (x: any) => {
      x.timerid = idInjector.injectionId;

      querier.registerFromCloud(x);
    },
    injectionId: undefined as undefined | number
  }

  /*
   * Serves two purposes:
   *
   * 1. Captures the queryID generated by the https-based requester (being mocked) for application
   *    as seen above.
   * 2. Forwards the local-request (mocked) query's Promise as if it were produced by the https-based requester.
   */
  mockedRequester.request = sinon.fake(() => {
    const retObj = mockingRequester.request(queryResultsFile);

    // We need to capture + inject that timerId into the returned results!
    idInjector.injectionId = retObj.queryId;
    return retObj;
  });

  // Install the queryId-injection register as the global registration point for returned queries.
  (window as any)['keyman'] = {
    register: idInjector.registerFromCloud
  };
}

describe("KeyboardRequisitioner", function () {
  it('queries for remote stubs and loads their keyboards', async () => {
    const keyboardLoader = new DOMKeyboardLoader(new KeyboardHarness(window, MinimalKeymanGlobal));
    const keyboardRequisitioner = new KeyboardRequisitioner(keyboardLoader, new DOMCloudRequester(true), pathConfig);
    const cache = keyboardRequisitioner.cache;

    // Note:  the query fixture is hand-edited from the original version obtained at
    // https://api.keyman.com/cloud/4.0/keyboards?jsonp=keyman.register&languageidtype=bcp47&version=17.0&keyboardid=khmer_angkor&timerid=49.
    //
    // The edits are minimal and notated within the fixture file.
    // Path becomes /resources/keyboards/khmer_angkor.js.
    mockQuery(keyboardRequisitioner.cloudQueryEngine, `resources/query-mock-results/khmer_angkor.hand-edited.js.fixture`);
    const [stub] = await keyboardRequisitioner.addKeyboardArray(['khmer_angkor']) as KeyboardStub[];
    assert.strictEqual(cache.getStub(stub.KI, stub.KLC), stub);

    const kbd_promise = cache.fetchKeyboard('khmer_angkor');
    const khmer_angkor = await kbd_promise;

    // Step 3: verify successful load & caching.
    assert.strictEqual(cache.getKeyboardForStub(stub), khmer_angkor);
    assert.isOk(khmer_angkor);
  });

  it('loads keyboards for page-local, API-added stubs', async () => {
    const keyboardLoader = new DOMKeyboardLoader(new KeyboardHarness(window, MinimalKeymanGlobal));
    const keyboardRequisitioner = new KeyboardRequisitioner(keyboardLoader, new DOMCloudRequester(true), pathConfig);
    const cache = keyboardRequisitioner.cache;

    // Expects the keyboard at resources/keyboards/khmer_angkor.js; this would resolve to
    // http://localhost:9876/resources/keyboards/khmer_angkor.js based on our configured path.
    const fixture = await fetch('resources/stubs/khmer_angkor.json');
    const stubJSON = await fixture.json();

    // But we can't be sure that `localhost:9876` is the actual path it will have on EVERYONE's machine.  Let's fix it.
    // We'll make it match the path for the previous test by ensuring a '/' for absolute pathing based on server root.
    stubJSON.filename = '/' + stubJSON.filename;

    // The `pathConfig` setup + internal logic should ensure that the filepath points to the correct location
    // with no additional effort required here.
    const [stub] = await keyboardRequisitioner.addKeyboardArray([stubJSON]) as KeyboardStub[];
    assert.strictEqual(cache.getStub(stub.KI, stub.KLC), stub);

    const kbd_promise = cache.fetchKeyboard('khmer_angkor');
    const khmer_angkor = await kbd_promise;

    // Step 3: verify successful load & caching.
    assert.strictEqual(cache.getKeyboardForStub(stub), khmer_angkor);
    assert.isOk(khmer_angkor);
  });
});