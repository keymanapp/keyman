import { assert } from 'chai';
import sinon from 'sinon';

import { ManagedPromise } from '@keymanapp/web-utils';
import { CloudQueryEngine, StubAndKeyboardCache, toPrefixedKeyboardId as prefixed } from 'keyman/engine/package-cache';
import { PathConfiguration } from 'keyman/engine/paths';
import NodeCloudRequester from 'keyman/engine/package-cache/node-requester';

import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const pathConfig = new PathConfiguration({
  root: '',
  resources: '',
  keyboards: '',
  fonts: '',
}, import.meta.url);

function buildIdInjector(querier) {
  // Promises are tracked via their queryId, which is generated by the requester.
  // We need to apply it before allowing the actual registration method to execute.
  const idInjector = {
    registerFromCloud: (x) => {
      x.timerid = idInjector.injectionId;

      querier.registerFromCloud(x);
    }
  };
  return idInjector;
}

function dummyResolvedPromise() {
  // The language-list promise getter expects an actual Promise to be returned.
  const promise = new ManagedPromise();
  promise.resolve()
  return {
    promise: promise
  };
}

describe("Cloud-query interface", () => {
  /**
   * Performs mocking setup to facilitate unit testing for the `CloudQueryEngine` class.
   *
   * @param {*} queryResultsFile An absolute local filepath to a file containing the mocked results to generate.
   * @returns A fully-mocked `CloudQueryEngine` whose `.fetchCloudStubs()` call will yield a Promise for the
   *          expected mocked results.
   */
  function mockQuery(queryResultsFile) {
    const mockedRequester = new NodeCloudRequester();      // Would attempt to https-request.
    const mockingRequester = new NodeCloudRequester(true); // Used to replace that with a local request.

    const querier = new CloudQueryEngine(mockedRequester, pathConfig); // The query engine builds https-request query strings.
    // Promises are tracked via their queryId, which is generated by the requester.
    // We need to apply it before allowing the actual registration method to execute.
    const idInjector = buildIdInjector(querier);

    /*
      * Serves two purposes:
      *
      * 1. Captures the queryID generated by the https-based requester (being mocked) for application
      *    as seen above.
      * 2. Forwards the local-request (mocked) query's Promise as if it were produced by the https-based requester.
      */
    mockedRequester.request = sinon.fake(() => {
      let retObj = mockingRequester.request(queryResultsFile);

      // We need to capture + inject that timerId into the returned results!
      idInjector.injectionId = retObj.queryId;
      return retObj;
    });

    // Make sure the actual (local-request) requester 'registers' the query result correctly - including the
    // ability to apply the queryId expected by the registration method.
    mockingRequester.link(idInjector);

    return querier;
  }

  describe("Query URI construction", () => {
    it('sil_euro_latin@no,sv', () => {
      const requester = new NodeCloudRequester();
      const mockedMethod = requester.request = sinon.fake(() => { return {promise: Promise.resolve()} });

      const querier = new CloudQueryEngine(requester, pathConfig);
      querier.fetchCloudStubs(['sil_euro_latin@no', 'sil_euro_latin@sv']);

      assert.isTrue(mockedMethod.called);
      const queryURI = mockedMethod.firstCall.args[0];
      assert.isTrue(queryURI.includes('keyboards?'));
      assert.isFalse(queryURI.includes('languages?'));
      assert.isTrue(queryURI.includes('&keyboardid=sil_euro_latin@no,sil_euro_latin@sv'));
      assert.isFalse(queryURI.includes('&keyboardid=sil_euro_latin@no,sil_euro_latin@sv,'));
    });

    it('sil_cameroon_azerty', () => {
      const requester = new NodeCloudRequester();
      const mockedMethod = requester.request = sinon.fake(() => { return {promise: Promise.resolve()} });

      const querier = new CloudQueryEngine(requester, pathConfig);
      querier.fetchCloudStubs(['sil_cameroon_azerty']);

      assert.isTrue(mockedMethod.called);
      const queryURI = mockedMethod.firstCall.args[0];
      assert.isTrue(queryURI.includes('keyboards?'));
      assert.isFalse(queryURI.includes('languages?'));
      assert.isTrue(queryURI.includes('&keyboardid=sil_cameroon_azerty'));
      assert.isFalse(queryURI.includes('&keyboardid=sil_cameroon_azerty@'));
    });

    it('@dz', () => {
      const requester = new NodeCloudRequester();
      const mockedMethod = requester.request = sinon.fake(() => { return {promise: Promise.resolve()} });

      const querier = new CloudQueryEngine(requester, pathConfig);
      querier.fetchCloudStubs(['@dz']);

      assert.isTrue(mockedMethod.called);
      const queryURI = mockedMethod.firstCall.args[0];
      assert.isTrue(queryURI.includes('keyboards?'));
      assert.isFalse(queryURI.includes('languages?'));
      assert.isTrue(queryURI.includes('&keyboardid=@dz'));
      assert.isFalse(queryURI.includes('&keyboardid=@dz,'));
    });

    it('sil_euro_latin@no,sv + @dz', () => {
      const requester = new NodeCloudRequester();
      const mockedMethod = requester.request = sinon.fake(() => { return {promise: Promise.resolve()} });

      const querier = new CloudQueryEngine(requester, pathConfig);
      querier.fetchCloudStubs(['sil_euro_latin@no', 'sil_euro_latin@sv', '@dz']);

      assert.isTrue(mockedMethod.called);
      const queryURI = mockedMethod.firstCall.args[0];
      assert.isTrue(queryURI.includes('keyboards?'));
      assert.isFalse(queryURI.includes('languages?'));
      assert.isTrue(queryURI.includes('&keyboardid=sil_euro_latin@no,sil_euro_latin@sv,@dz'));
      assert.isFalse(queryURI.includes('&keyboardid=sil_euro_latin@no,sil_euro_latin@sv,@dz,'));
    });

    it("'' (language list query)", () => {
      const requester = new NodeCloudRequester();
      const mockedMethod = requester.request = sinon.fake(() => dummyResolvedPromise());

      const querier = new CloudQueryEngine(requester, pathConfig);
      let dummyAssignment = querier.languageListPromise; // triggers a language-list fetch.

      assert.isTrue(mockedMethod.called);
      const queryURI = mockedMethod.firstCall.args[0];
      assert.isTrue(queryURI.includes('languages?'));
      assert.isFalse(queryURI.includes('keyboards?'));
      assert.isTrue(queryURI.includes('languageidtype=bcp47'));
      assert.isFalse(queryURI.includes('&keyboardid='));
    });
  });

  describe('Stub fetching', () => {
    it('sil_euro_latin@no,sv', async () => {
      const querier = mockQuery(`${__dirname}/../../../resources/query-mock-results/sil_euro_latin@no_sv.js.fixture`);
      const promise = querier.fetchCloudStubs(['sil_euro_latin@no', 'sil_euro_latin@sv']);

      const stubs = await promise;

      assert.equal(stubs.length, 2);
      for(let stub of stubs) {
        assert.equal(stub.KI, prefixed('sil_euro_latin'));
        assert.equal(stub.KN, "EuroLatin (SIL)");
        assert.isTrue(stub.KF.includes('s.keyman.com')); // The keyboardsURI property from the cloud options should be applied.
      }

      assert.sameOrderedMembers(stubs.map((stub) => stub.KLC), ['no', 'sv']);
      assert.sameOrderedMembers(stubs.map((stub) => stub.KL),  ['Norwegian', 'Swedish']);
    });

    it('sil_cameroon_azerty', async () => {
      const querier = mockQuery(`${__dirname}/../../../resources/query-mock-results/sil_cameroon_azerty.js.fixture`);
      const promise = querier.fetchCloudStubs(['sil_cameroon_azerty']);

      const stubs = await promise;

      assert.equal(stubs.length, 278);
      for(let stub of stubs) {
        assert.equal(stub.KI, prefixed('sil_cameroon_azerty'));
        assert.equal(stub.KN, "Cameroon AZERTY");
        assert.isTrue(stub.KF.includes('s.keyman.com')); // The keyboardsURI property from the cloud options should be applied.
      }

      assert.equal(stubs.find((stub) => stub.KLC == 'pny').KL, 'Pinyin');
    });

    it('@dz', async () => {
      const querier = mockQuery(`${__dirname}/../../../resources/query-mock-results/@dz.js.fixture`);
      const promise = querier.fetchCloudStubs(['@dz']);

      const stubs = await promise;

      // `CloudQueryEngine` returns only a single stub.
      //
      // Within `CloudQueryEngine.registerLanguagesForKeyboard`:
      // > Register the default keyboard for the language code
      assert.equal(stubs.length, 1);
      // When available, a perfect match between keyboard and language name = "the default keyboard".
      assert.equal(stubs[0].KN, "Dzongkha");
      assert.isTrue(stubs[0].KF.includes('s.keyman.com')); // The keyboardsURI property from the cloud options should be applied.
    });
  });

  it('language list fetching', async () => {
    const querier = mockQuery(`${__dirname}/../../../resources/query-mock-results/languages.js.fixture`);
    const promise = querier.languageListPromise;

    const langList = await promise;

    assert.isArray(langList);
    assert.isAtLeast(langList.length, 2000); // On initial implementation of this test:  2187.

    const km = langList.find((entry) => entry.id == 'km');
    assert.isOk(km);
    assert.equal(km.name, 'Khmer');

    const dz = langList.find((entry) => entry.id == 'dz');
    assert.isOk(dz);
    assert.equal(dz.name, 'Dzongkha');
  });
});