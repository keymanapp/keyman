/*
 * Keyman is 2025 copyright (C) SIL International. MIT License.
 *
 * Created by S. Schmitt on 2025-05-12
 *
 * Tests for KeylayoutToKmnConverter, KeylayoutFileReader, KmnFileWriter
 *
 */

import 'mocha';
import { assert } from 'chai';
import { util } from '@keymanapp/common-types';
import KEYMAN_VERSION from "@keymanapp/keyman-version";
import { compilerTestCallbacks, compilerTestOptions, makePathToFixture } from './helpers/index.js';
import { KeylayoutToKmnConverter } from '../src/keylayout-to-kmn/keylayout-to-kmn-converter.js';
import { KmnFileWriter } from '../src/keylayout-to-kmn/kmn-file-writer.js';
import { KeylayoutFileReader } from '../src/keylayout-to-kmn/keylayout-file-reader.js';

describe('KmnFileWriter', function () {

  before(function () {
    compilerTestCallbacks.clear();
  });

  describe("write() ", function () {
    const inputFilename = makePathToFixture('../data/Test.keylayout');
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const read = sut_r.read(inputFilename);
    const converted = sut.convert_bound.convert(read, inputFilename.replace(/\.keylayout$/, '.kmn'));

    // empty convert_object from unavailable file name
    const inputFilename_unavailable = makePathToFixture('../data/X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert_bound.convert(read_unavailable, inputFilename_unavailable.replace(/\.keylayout$/, '.kmn'));

    it('write() should return true (no error) if written', async function () {
      const result = sut_w.write(converted);
      assert.isTrue(result);
    });

    it('write() should return false if no inputfile', async function () {
      const result = sut_w.write(converted_unavailable);
      assert.isFalse(result);
    });

  });

  describe("writeToString() ", function () {
    const inputFilename = makePathToFixture('../data/Test.keylayout');
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const read = sut_r.read(inputFilename);
    const converted = sut.convert_bound.convert(read, inputFilename.replace(/\.keylayout$/, '.kmn'));

    const out_expected_first: string = "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "c Keyman keyboard generated by kmn-convert version: " + KEYMAN_VERSION.VERSION + "\n"
      + "c from Ukelele file: ";

    const out_expected_last: string = "\n"
      + "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "\n"
      + "store(&TARGETS) 'desktop'\n"
      + "\n"
      + "begin Unicode > use(main)\n\n"
      + "group(main) using keys\n\n"
      + "\n";

    // empty convert_object from unavailable file name
    const inputFilename_unavailable = makePathToFixture('../data/X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert_bound.convert(read_unavailable, inputFilename_unavailable.replace(/\.keylayout$/, '.kmn'));

    it('writeToString() should return result', async function () {
      const result = sut_w.writeToString(converted);
      assert.isNotNull(result);
    });

    it('writeToString() should return header in case of missing inputfile', async function () {
      const result = sut_w.writeToString(converted_unavailable);
      assert.equal(result, ("\n" + out_expected_first + out_expected_last));
    });
  });

  describe("writeToUint8Array() ", function () {
    const inputFilename = makePathToFixture('../data/Test.keylayout');
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const read = sut_r.read(inputFilename);
    const converted = sut.convert_bound.convert(read, inputFilename.replace(/\.keylayout$/, '.kmn'));

    const out_expected_first: string =
      "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "c Keyman keyboard generated by kmn-convert version: " + KEYMAN_VERSION.VERSION + "\n"
      + "c from Ukelele file: ";

    const out_expected_last: string = "\n"
      + "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "\n"
      + "store(&TARGETS) 'desktop'\n"
      + "\n"
      + "begin Unicode > use(main)\n\n"
      + "group(main) using keys\n\n"
      + "\n";


    // empty convert_object from unavailable file name
    const inputFilename_unavailable = makePathToFixture('../data/X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert_bound.convert(read_unavailable, inputFilename_unavailable.replace(/\.keylayout$/, '.kmn'));
    it('writeToUint8Array() should return header in case of missing inputfile', async function () {
      const result = sut_w.writeToUint8Array(converted_unavailable);
      assert.equal(new TextDecoder().decode(result), ("\n" + out_expected_first + out_expected_last));
    });

    it('writeToUint8Array() should return result', async function () {
      const result = sut_w.writeToUint8Array(converted);
      assert.isNotNull(result);
    });
  });

  describe("writeData_Rules() ", function () {
    const inputFilename = makePathToFixture('../data/Test.keylayout');
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const read = sut_r.read(inputFilename);
    const converted = sut.convert_bound.convert(read, inputFilename.replace(/\.keylayout$/, '.kmn'));

    // empty convert_object from unavailable file name
    const inputFilename_unavailable = makePathToFixture('../data/X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert_bound.convert(read_unavailable, inputFilename_unavailable.replace(/\.keylayout$/, '.kmn'));

    it('writeData_Rules() should return true (no error) if written', async function () {
      const result = sut_w.writeData_Rules(converted);
      assert.isTrue(result.length > 0);
    });

    it('writeData_Rules() should return false if no inputfile', async function () {
      const result = sut_w.writeData_Rules(converted_unavailable);
      assert.isFalse(result.length > 0);
    });

  });

  describe("writeData_Stores() ", function () {
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const inputFilename = makePathToFixture('../data/Test.keylayout');
    const read = sut_r.read(inputFilename);
    const converted = sut.convert_bound.convert(read, inputFilename.replace(/\.keylayout$/, '.kmn'));

    // empty convert_object from unavailable file name
    const inputFilename_unavailable = makePathToFixture('../data/X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert_bound.convert(read_unavailable, inputFilename_unavailable.replace(/\.keylayout$/, '.kmn'));

    // empty convert_object from empty filename
    const inputFilename_empty = makePathToFixture('');
    const read_empty = sut_r.read(inputFilename_empty);
    const converted_empty = sut.convert_bound.convert(read_empty, inputFilename_empty);

    const out_expected_first: string =
      "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "c Keyman keyboard generated by kmn-convert version: " + KEYMAN_VERSION.VERSION + "\n"
      + "c from Ukelele file: ";

    const out_expected_last: string =
      "\n"
      + "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "\n"
      + "store(&TARGETS) 'desktop'\n"
      + "\n"
      + "begin Unicode > use(main)\n\n"
      + "group(main) using keys\n\n"
      + "\n";

    it(('writeData_Stores should return store text with filename ').padEnd(62, " ") + 'on correct input', async function () {
      const written_correctName = sut_w.writeData_Stores(converted);
      assert.equal(written_correctName, (out_expected_first + converted.keylayout_filename + out_expected_last));
    });

    it(('writeData_Stores should return store text without filename ').padEnd(62, " ") + 'on empty input', async function () {
      const written_emptyName = sut_w.writeData_Stores(converted_empty);
      assert.equal(written_emptyName, (out_expected_first + out_expected_last));
    });

    it(('writeData_Stores should return store text without filename ').padEnd(62, " ") + 'on only filename as input', async function () {
      const written_onlyName = sut_w.writeData_Stores(converted_unavailable);
      assert.equal(written_onlyName, (out_expected_first + converted_unavailable.keylayout_filename + out_expected_last));
    });
  });

  describe('convertToUnicodeCodePoint ', function () {
    [
      ["&#x10F601;", 'U+10F601'],
      ["&#x1F601;", 'U+1F601'],
      ["&#x9;", 'U+0009'],
      ["&#x99;", 'U+0099'],
      ["&#x999;", 'U+0999'],
      ["&#x9999;", 'U+9999'],
      ["&#x99999;", 'U+99999'],
      ["&#1111553;", 'U+10F601'],
      ["&#128513;", 'U+1F601'],
      ["&#9;", 'U+0009'],
      ["&#99;", 'U+0063'],
      ["&#999;", 'U+03E7'],
      ["&#9999;", 'U+270F'],
      ["&#99999;", 'U+1869F'],
      ['0000;', '0000;'],
      ['X;', 'X;'],
      ['123;', '123;'],
      [';', ';'],
      [' ;', ' ;']
    ].forEach(function (values) {
      it(('should convert "' + values[0] + '"').padEnd(25, " ") + 'to "' + values[1] + '"', async function () {
        const result = util.convertToUnicodeCodePoint(values[0] as string);
        assert.equal(result, values[1]);
      });
    });
  });

  describe('convertToUnicodeCharacter ', function () {
    [
      ["&#x61;", 'a'],
      ["&#x1234;", 'ሴ'],
      ["&#x1F60E;", '😎'],
      ["&#x1000000;", undefined],
      ["&#97;", 'a'],
      ["&#4660;", 'ሴ'],
      ["&#128518;", '😆'],
      ["&#1000000;", undefined],
      ["U+0061;", 'a'],
      ["U+1234;", 'ሴ'],
      ["U+1F60E", '😎'],
      ["U+1000000;", undefined],
      ["&commat;", undefined],
      ["a", 'a'],
      ["ሴ", 'ሴ'],
      ['😎', '😎'],
      ["W̊", "W̊"],
      ["ab", undefined],
      ["", ''],
      [undefined, undefined],
      [null, undefined]
    ].forEach(function (values) {
      it(('should convert "' + values[0] + '"').padEnd(25, " ") + 'to "' + values[1] + '"', async function () {
        const result = util.convertToUnicodeCharacter(values[0] as string);
        assert.equal(result, values[1]);
      });
    });
  });
});
