/*
 * Keyman is 2025 copyright (C) SIL International. MIT License.
 *
 * Created by S. Schmitt on 2025-05-12
 *
 * Tests for KeylayoutToKmnConverter, KeylayoutFileReader, KmnFileWriter
 *
 */

import 'mocha';
import { assert } from 'chai';
//import { util } from '@keymanapp/common-types';
//import * as kmcConvertUtil  from '../src/kmcConvertUtil.js';
import KEYMAN_VERSION from "@keymanapp/keyman-version";
import { compilerTestCallbacks, compilerTestOptions, makePathToFixture } from './helpers/index.js';
import { KeylayoutToKmnConverter, ProcesData, Rule } from '../src/keylayout-to-kmn/keylayout-to-kmn-converter.js';
import { KmnFileWriter } from '../src/keylayout-to-kmn/kmn-file-writer.js';
import { KeylayoutFileReader } from '../src/keylayout-to-kmn/keylayout-file-reader.js';

describe('KmnFileWriter', function () {

  before(function () {
    compilerTestCallbacks.clear();
  });


  describe("write() ", function () {
    const inputFilename = makePathToFixture('../data/Test.keylayout');
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const read = sut_r.read(inputFilename);
    const converted = sut.convert_bound.convert(read, inputFilename.replace(/\.keylayout$/, '.kmn'));

    const out_expected: string =
      "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "c Keyman keyboard generated by kmn-convert version: " + KEYMAN_VERSION.VERSION + "\n"
      + "c from Ukelele file: "
      + "\n"
      + "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "\n"
      + "store(&TARGETS) 'desktop'\n"
      + "\n"
      + "begin Unicode > use(main)\n\n"
      + "group(main) using keys\n\n"
      + "\n";


    // empty ProcesData from unavailable file name
    const inputFilename_unavailable = makePathToFixture('../data/X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert_bound.convert(read_unavailable, inputFilename_unavailable.replace(/\.keylayout$/, '.kmn'));
    it('write() should return header in case of missing inputfile', async function () {
      const result = sut_w.write(converted_unavailable);
      assert.equal(new TextDecoder().decode(result), ("\n" + out_expected));
    });

    it('write() should return result', async function () {
      const result = sut_w.write(converted);
      assert.isNotNull(result);
    });
  });

  describe("writeData_Rules() ", function () {
    const inputFilename = makePathToFixture('../data/Test.keylayout');
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const read = sut_r.read(inputFilename);
    const converted = sut.convert_bound.convert(read, inputFilename.replace(/\.keylayout$/, '.kmn'));

    // empty ProcesData from unavailable file name
    const inputFilename_unavailable = makePathToFixture('../data/X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert_bound.convert(read_unavailable, inputFilename_unavailable.replace(/\.keylayout$/, '.kmn'));

    it('writeData_Rules() should return true (no error) if written', async function () {
      const result = sut_w.writeData_Rules(converted);
      assert.isTrue(result.length > 0);
    });

    it('writeData_Rules() should return false if no inputfile', async function () {
      const result = sut_w.writeData_Rules(converted_unavailable);
      assert.isFalse(result.length > 0);
    });

  });

  describe("write_KmnFileHeader() ", function () {
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const inputFilename = makePathToFixture('../data/Test.keylayout');
    const read = sut_r.read(inputFilename);
    const converted = sut.convert_bound.convert(read, inputFilename.replace(/\.keylayout$/, '.kmn'));

    // empty ProcesData from unavailable file name
    const inputFilename_unavailable = makePathToFixture('../data/X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert_bound.convert(read_unavailable, inputFilename_unavailable.replace(/\.keylayout$/, '.kmn'));

    // empty ProcesData from empty filename
    const inputFilename_empty = makePathToFixture('');
    const read_empty = sut_r.read(inputFilename_empty);
    const converted_empty = sut.convert_bound.convert(read_empty, inputFilename_empty);

    const out_expected_first: string =
      "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "c Keyman keyboard generated by kmn-convert version: " + KEYMAN_VERSION.VERSION + "\n"
      + "c from Ukelele file: ";

    const out_expected_last: string =
      "\n"
      + "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "\n"
      + "store(&TARGETS) 'desktop'\n"
      + "\n"
      + "begin Unicode > use(main)\n\n"
      + "group(main) using keys\n\n"
      + "\n";

    it(('write_KmnFileHeader should return store text with filename ').padEnd(62, " ") + 'on correct input', async function () {
      const written_correctName = sut_w.write_KmnFileHeader(converted);
      assert.equal(written_correctName, (out_expected_first + converted.keylayout_filename + out_expected_last));
    });

    it(('write_KmnFileHeader should return store text without filename ').padEnd(62, " ") + 'on empty input', async function () {
      const written_emptyName = sut_w.write_KmnFileHeader(converted_empty);
      assert.equal(written_emptyName, (out_expected_first + out_expected_last));
    });

    it(('write_KmnFileHeader should return store text without filename ').padEnd(62, " ") + 'on only filename as input', async function () {
      const written_onlyName = sut_w.write_KmnFileHeader(converted_unavailable);
      assert.equal(written_onlyName, (out_expected_first + converted_unavailable.keylayout_filename + out_expected_last));
    });
  });

  describe('reviewRules messages', function () {
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);

    [
      [[new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'UNAVAILABLE', 'K_A', new TextEncoder().encode('A'))],
      [''],
      [''],
      ['c WARNING: unavailable modifier : here: ']],

      [[new Rule("C1", '', '', 0, 0, 'CAPS', 'K_EQUAL', 0, 0, 'UNAVAILABLE', 'K_B', new TextEncoder().encode('B'))],
      [''],
      [''],
      ['c WARNING: unavailable modifier : here: ']],

      [[new Rule("C2", '', '', 0, 0, 'CAPS', 'K_EQUAL', 0, 0, 'UNAVAILABLE', 'K_C', new TextEncoder().encode('C'),)],
      [''],
      [''],
      ['c WARNING: unavailable modifier : here: ']],

      [[new Rule("C2", '', '', 0, 0, 'UNAVAILABLE_dk', 'K_EQUAL', 0, 0, 'UNAVAILABLE', 'K_C', new TextEncoder().encode('C'),)],
      [''],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable modifier : here: ']],

      [[new Rule("C3", 'UNAVAILABLE_prev_dk', 'K_D', 0, 0, 'UNAVAILABLE_dk', 'K_EQUAL', 0, 0, 'SHIFT', 'K_C', new TextEncoder().encode('D'),)],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable superior rule ( [UNAVAILABLE_dk K_EQUAL]  >  dk(B0) ) : here: ']],

      [[new Rule("C3", 'UNAVAILABLE_prev_dk', 'K_D', 0, 0, 'UNAVAILABLE_dk', 'K_EQUAL', 0, 0, 'UNAVAIL', 'K_C', new TextEncoder().encode('D'),)],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable modifier : here: ']],

      [[new Rule("C3", 'CAPS', 'K_D', 0, 0, 'RALT', 'K_EQUAL', 0, 0, 'SHIFT', 'K_C', new TextEncoder().encode('D'),)],
      [''],
      [''],
      ['']],

      [[new Rule("C3", 'X', 'K_X', 0, 0, 'Y', 'K_Y', 0, 0, 'SHIFT', 'K_Z', new TextEncoder().encode('D'),)],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable superior rule ( [Y K_Y]  >  dk(B0) ) : here: ']],

    ].forEach(function (values: any, index: number) {
      it(('rule " ' + values[0][0].rule_type + ' "') + 'should create "' + values[1] + ' | ' + values[2] + ' | ' + values[3] + '"', async function () {
        const result: string[] = sut_w.reviewRules(values[0], 0);
        assert.equal(result[0], values[1][0]);
        assert.equal(result[1], values[2][0]);
        assert.equal(result[2], values[3][0]);
      });
    });
  });

  describe('reviewRules messages duplicate and ambiguous', function () {

    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    [
      //all
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),],
      ['c WARNING: duplicate rule: earlier: [LALT K_A]  >  dk(C0) here: '],
      ["c WARNING: duplicate rule: earlier: dk(B0) + [SHIFT K_B]  >  dk(B0) here: "],
      ["c WARNING: duplicate rule: earlier: dk(B0) + [CAPS K_C]  >  'X' here: "]],

      //6-6 dup
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'CTRL', 'K_D', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),],
      [''],
      [""],
      ["c WARNING: duplicate rule: earlier: dk(B0) + [CAPS K_C]  >  'X' here: "]],

      //6-6 amb
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'CTRL', 'K_D', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('Y')),],
      [''],
      [""],
      ["c WARNING: ambiguous rule: earlier: dk(B0) + [CAPS K_C]  >  'X' here: "]],

      // 5-5 amb
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'NCAPS', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'NCAPS', 'K_B', 0, 1, 'RALT', 'K_F', new TextEncoder().encode('X')),],
      ['c WARNING: duplicate rule: earlier: [LALT K_A]  >  dk(C0) here: '],
      ["c WARNING: ambiguous rule: earlier: dk(B0) + [NCAPS K_B]  >  dk(B0) here: "], [''],
      ],

      // 5-5 dup
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'NCAPS', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'NCAPS', 'K_B', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('X')),],
      ['c WARNING: duplicate rule: earlier: [LALT K_A]  >  dk(C0) here: '],
      ["c WARNING: duplicate rule: earlier: dk(B0) + [NCAPS K_B]  >  dk(B0) here: "],
      ['']],

      // 4-2 amb
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'LALT', 'K_A', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('X')),],
      ['c WARNING: ambiguous rule: later: [LALT K_A]  >  dk(C0) here: '],
      [''],
      ['']],

      // 4-4 amb
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'LALT', 'K_A', 1, 1, 'NCAPS', 'K_E', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('Y')),],
      ['c WARNING: ambiguous rule: earlier: [LALT K_A]  >  dk(C0) here: '],
      [""],
      [''],],

      // 4-4 dup
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'NCAPS', 'K_E', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('X')),],
      ['c WARNING: duplicate rule: earlier: [LALT K_A]  >  dk(C0) here: '],
      [''],
      ['']],

      // 4-2 amb
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'LALT', 'K_A', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('Y')),],
      ['c WARNING: ambiguous rule: later: [LALT K_A]  >  dk(C0) here: '],
      [''],
      ['']],

      // 6-3 dup
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'CTRL', 'K_D', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),],
      [''],
      ["c WARNING: duplicate rule: earlier: dk(C0) + [CAPS K_C]  >  'X' here: "],
      [''],],

      // 6-3 amb
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'CTRL', 'K_D', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('Y')),],
      [''],
      ["c WARNING: ambiguous rule: earlier: dk(C0) + [CAPS K_C]  >  'X' here: "],
      [''],],

      // 2-4 amb
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'SHIFT', 'K_B', 0, 0, 'NCAPS', 'K_E', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('Y')),],
      ['c WARNING: ambiguous rule: earlier: [SHIFT K_B]  >  dk(A0) here: '],
      [''],
      ['']],

      //2-2 amb
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 1, 1, 'RALT', 'K_F', new TextEncoder().encode('Y')),],
      [''],
      ['c WARNING: ambiguous rule: earlier: [SHIFT K_B]  >  dk(C0) here: '],
      ['']],

      // 2-2 dup
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('Y')),],
      [''],
      ['c WARNING: duplicate rule: earlier: [SHIFT K_B]  >  dk(C0) here: '],
      ['']],

      // 3-3 dup
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),],
      [''],
      [''],
      ["c WARNING: duplicate rule: earlier: dk(A0) + [CAPS K_C]  >  'X' here: "]],

      // 3-3 amb
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('Y')),],
      [''],
      [''],
      ["c WARNING: ambiguous rule: earlier: dk(A0) + [CAPS K_C]  >  'X' here: "]],

      // 2-1 amb
      [[
        new Rule("C2", '', '', 0, 0, 'RALT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'RALT', 'K_B', new TextEncoder().encode('Y'))],
      [''],
      [''],
      ['c WARNING: ambiguous rule: later: [RALT K_B]  >  dk(A0) here: ']],

      // 1-1 amb
      [[
        new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('Y'))],
      [''],
      [''],
      ["c WARNING: ambiguous rule: earlier: [CAPS K_C]  >  'X' here: "]],

      // 1-1 amb
      [[
        new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X'))],
      [''],
      [''],
      ["c WARNING: duplicate rule: earlier: [CAPS K_C]  >  'X' here: "]],

    ].forEach(function (values: any, index: number) {
      it('rule ' + values[0][0].rule_type + ' should create " ' + ' "' + values[1] + ' | ' + values[2] + ' | ' + values[3] + '"', async function () {
        const result: string[] = sut_w.reviewRules(values[0], 1);
        assert.equal(result[0], values[1][0]);
        assert.equal(result[1], values[2][0]);
        assert.equal(result[2], values[3][0]);
      });
    });
  });

  describe('reviewRules messages duplicate and ambiguous with Extra warning', function () {
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    [[[
      new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'RALT', 'K_B', new TextEncoder().encode('X')),
      new Rule("C2", '', '', 0, 0, 'RALT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('Y')),
      new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'RALT', 'K_B', new TextEncoder().encode('Z'))
    ],
    [''],
    [''],
    ["c WARNING: ambiguous rule: later: [RALT K_B]  >  dk(A0) ambiguous rule: earlier: [RALT K_B]  >  'X' here: PLEASE CHECK THE FOLLOWING RULE AS IT WILL NOT BE WRITTEN !  "]],
    ].forEach(function (values: any, index: number) {
      it(('rule ' + values[0][0].rule_type + ' should create " ' + ' "') + values[1] + ' | ' + values[2] + ' | ' + values[3] + '"', async function () {
        const result: string[] = sut_w.reviewRules(values[0], 2);
        assert.equal(result[0], values[1][0]);
        assert.equal(result[1], values[2][0]);
        assert.equal(result[2], values[3][0]);
      });
    });
  });

  describe('write from intermediate data array', function () {
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    [
      [
        [ /* see ../data/Test_C0.keylayout */
          new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'NCAPS', 'K_A', new TextEncoder().encode('a')),
          new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_A', new TextEncoder().encode('A')),
          new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'NCAPS', 'K_S', new TextEncoder().encode('s')),
          new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'NCAPS', 'K_D', new TextEncoder().encode('d'))
        ],
        ["+ [NCAPS K_A]  >  'a'\n" +
          "+ [CAPS K_A]  >  'A'\n\n" +
          "+ [NCAPS K_S]  >  's'\n\n" +
          "+ [NCAPS K_D]  >  'd'\n"]
      ],
      [
        [ /* see ../data/Test_C1.keylayout */
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'NCAPS', 'K_S', new TextEncoder().encode('s')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_S', new TextEncoder().encode('S'))
        ],
        ["+ [NCAPS K_S]  >  's'\n" +
          "+ [CAPS K_S]  >  'S'\n"]
      ],
      [
        [ /* see ../data/Test_C2.keylayout */
          new Rule("C2", '', '', 0, 0, 'NCAPS', 'K_U', 1, 1, 'CAPS', 'K_A', new TextEncoder().encode('Â'))
        ],
        ["+ [NCAPS K_U]  >  dk(A1)\n" +
          "dk(A1) + [CAPS K_A]  >  'Â'\n\n"]
      ],
      [
        [ /* see ../data/Test_C3.keylayout */
          new Rule("C3", 'NCAPS SHIFT', 'K_D', 2, 1, 'NCAPS', 'K_U', 1, 2, 'CAPS', 'K_A', new TextEncoder().encode('Â'))
        ],
        ["+ [NCAPS SHIFT K_D]   >   dk(A2)\n" +
          "dk(A2)  + [NCAPS K_U]  >  dk(B1)\n" +
          "dk(B1) + [CAPS K_A]  >  'Â'\n\n"
        ]
      ],
      [
        [ /* see ../data/Test_C0_C1_C2_C3.keylayout */
          new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_A', new TextEncoder().encode('A')),
          new Rule("C2", '', '', 0, 0, 'NCAPS RALT', 'K_EQUAL', 1, 1, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_S', new TextEncoder().encode('S')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'NCAPS RALT', 'K_U', new TextEncoder().encode('S')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 1, 'CAPS', 'K_S', 2, 6, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'CAPS', 'K_U', 3, 3, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'NCAPS RALT', 'K_S', 4, 4, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'NCAPS RALT', 'K_U', 5, 5, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_S', new TextEncoder().encode('S')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'NCAPS RALT', 'K_U', new TextEncoder().encode('S')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'CAPS', 'K_S', 2, 0, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'CAPS', 'K_U', 3, 0, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'NCAPS RALT', 'K_S', 4, 0, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'NCAPS RALT', 'K_U', 5, 0, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_U', new TextEncoder().encode('U')),
        ],
        ["+ [CAPS K_A]  >  'A'\n" +
          "+ [CAPS K_S]  >  'S'\n\n" +
          "+ [NCAPS RALT K_U]  >  'S'\n" +
          "+ [CAPS K_U]  >  'U'\n" +
          "+ [NCAPS RALT K_EQUAL]  >  dk(A1)\n" +
          "dk(A1) + [CAPS K_D]  >  'Â'\n\n" +
          "+ [NCAPS RALT K_8]   >   dk(A6)\n" +
          "dk(A6)  + [CAPS K_S]  >  dk(B2)\n" +
          "dk(B2) + [CAPS K_D]  >  'Â'\n\n" +
          "dk(A6)  + [CAPS K_U]  >  dk(B3)\n" +
          "dk(B3) + [CAPS K_D]  >  'Â'\n\n" +
          "dk(A6)  + [NCAPS RALT K_S]  >  dk(B4)\n" +
          "dk(B4) + [CAPS K_D]  >  'Â'\n\n" +
          "dk(A6)  + [NCAPS RALT K_U]  >  dk(B5)\n" +
          "dk(B5) + [CAPS K_D]  >  'Â'\n\n"]
      ],
      [
        [ /* see ../data/Test_C3_several.keylayout */
          new Rule("C3", 'NCAPS RALT', 'K_8', 3, 1, 'CAPS', 'K_U', 1, 3, 'NCAPS', 'K_A', new TextEncoder().encode('â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 3, 0, 'CAPS', 'K_U', 1, 0, 'NCAPS RALT', 'K_A', new TextEncoder().encode('â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 3, 0, 'NCAPS RALT', 'K_U', 2, 2, 'NCAPS', 'K_A', new TextEncoder().encode('â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 3, 0, 'NCAPS RALT', 'K_U', 2, 0, 'NCAPS RALT', 'K_A', new TextEncoder().encode('â'))
        ],
        ["+ [NCAPS RALT K_8]   >   dk(A3)\n" +
          "dk(A3)  + [CAPS K_U]  >  dk(B1)\n" +
          "dk(B1) + [NCAPS K_A]  >  'â'\n\n" +
          "dk(B1) + [NCAPS RALT K_A]  >  'â'\n\n" +
          "dk(A3)  + [NCAPS RALT K_U]  >  dk(B2)\n" +
          "dk(B2) + [NCAPS K_A]  >  'â'\n\n" +
          "dk(B2) + [NCAPS RALT K_A]  >  'â'\n\n"
        ]
      ],
    ].forEach(function (values: any) {
      it(('an array of Rules should create a set of kmn rules '), async function () {
        const data: ProcesData = {
          keylayout_filename: "",
          kmn_filename: "",
          arrayOf_Modifiers: [[]],
          arrayOf_Rules: values[0]
        };
        const result1 = sut_w.writeData_Rules(data);
        assert.isTrue(result1 === values[1][0]);
      });
    });
  });

});
