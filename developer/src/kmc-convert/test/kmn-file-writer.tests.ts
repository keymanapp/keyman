/*
 * Keyman is 2025 copyright (C) SIL International. MIT License.
 *
 * Tests for KeylayoutToKmnConverter, KeylayoutFileReader, KmnFileWriter
 *
 */

import 'mocha';
import { util } from '@keymanapp/common-types';
import { compilerTestCallbacks, compilerTestOptions, makePathToFixture } from './helpers/index.js';
import { KeylayoutToKmnConverter } from '../src/keylayout-to-kmn/keylayout-to-kmn-converter.js';
import { KmnFileWriter } from '../src/keylayout-to-kmn/kmn-file-writer.js';
import { KeylayoutFileReader } from '../src/keylayout-to-kmn/keylayout-file-reader.js';
import { doesNotReject } from 'node:assert';


//-----------------------------------------------------------------------------------------------------------------------

describe('KmnFileWriter', function () {

  before(function () {
    compilerTestCallbacks.clear();
  });

  describe('write()', function () {
    const inputFilename = makePathToFixture('../data/Italian.keylayout');
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const read = sut_r.read(inputFilename);
    const converted = sut.convert(read);

    // empty convert_object from unavailable file name
    const inputFilename_unavailable = makePathToFixture('X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert(read_unavailable);

    it('write() should return true (no error) if written', async function () {
      await doesNotReject(async () => sut_w.write(converted));
    });

    it('write() should return false if no inputfile', async function () {
      await doesNotReject(async () => sut_w.write(converted_unavailable) === false);
    });
  });

  describe('writeData_Rules()', function () {
    const inputFilename = makePathToFixture('../data/Italian.keylayout');
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const read = sut_r.read(inputFilename);
    const converted = sut.convert(read);

    // empty convert_object from unavailable file name
    const inputFilename_unavailable = makePathToFixture('X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert(read_unavailable);

    it('writeData_Rules() should return true (no error) if written', async function () {
      await doesNotReject(async () => sut_w.writeData_Rules(converted).length > 0);
    });

    it('writeData_Rules() should return false if no inputfile', async function () {
      await doesNotReject(async () => sut_w.writeData_Rules(converted_unavailable).length > 0);
    });

  });

  describe('writeData_Stores() ', function () {
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const inputFilename = makePathToFixture('../data/Italian.keylayout');
    const read = sut_r.read(inputFilename);
    const converted = sut.convert(read);

    // empty convert_object from unavailable file name
    const inputFilename_unavailable = makePathToFixture('X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert(read_unavailable);

    // empty convert_object from empty filename
    const inputFilename_empty = makePathToFixture('');
    const read_empty = sut_r.read(inputFilename_empty);
    const converted_empty = sut.convert(read_empty);

    const out_expected_first: string =
      "c ......................................................................\n"
      + "c ......................................................................\n"
      + "c Keyman keyboard generated by kmn-convert\n"
      + "c from Ukelele file: ";

    const out_expected_last: string =
      "\n"
      + "c ......................................................................\n"
      + "c ......................................................................\n"
      + "\n"
      + "store(&VERSION) '10.0'\n"
      + "store(&TARGETS) 'any'\n"
      + "store(&KEYBOARDVERSION) '1.0'\n"
      + "store(&COPYRIGHT) 'Â© 2024 SIL International'\n"
      + "\n"
      + "begin Unicode > use(main)\n\n"
      + "group(main) using keys\n\n"
      + "\n";

    it(('writeData_Stores should return store text with filename ').padEnd(62, " ") + 'on correct input', async function () {
      const written_correctName = sut_w.writeData_Stores(converted);
      await doesNotReject(async () => (written_correctName === (out_expected_first + converted.keylayout_filename + out_expected_last)));
    });

    it(('writeData_Stores should return store text without filename ').padEnd(62, " ") + 'on empty input', async function () {
      const written_emptyName = sut_w.writeData_Stores(converted_empty);
      await doesNotReject(async () => (written_emptyName === (out_expected_first + out_expected_last)));

    });

    it(('writeData_Stores should return store text without filename ').padEnd(62, " ") + 'on only filename as input', async function () {
      const written_onlyName = sut_w.writeData_Stores(converted_unavailable);
      await doesNotReject(async () => (written_onlyName === (out_expected_first + converted_unavailable.keylayout_filename + out_expected_last)));
    });
  });

  describe('reviewRules() ', function () {
    const inputFilename = makePathToFixture('../data/Italian.keylayout');
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const read = sut_r.read(inputFilename);
    const converted = sut.convert(read);

    // empty convert_object from unavailable file name
    const inputFilename_unavailable = makePathToFixture('X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert(read_unavailable);

    it('reviewRules() should return true (no error) if written', async function () {
      await doesNotReject(async () => sut_w.write(converted));
    });

    it('reviewRules() should return false if no inputfile', async function () {
      await doesNotReject(async () => !sut_w.write(converted_unavailable));
    });
  });

  describe('convertToUnicodeCodePoint ', function () {
    [
      ["&#x10F601;", 'U+10F601'],
      ["&#x1F601;", 'U+1F601'],
      ["&#x9;", 'U+0009'],
      ["&#x99;", 'U+0099'],
      ["&#x999;", 'U+0999'],
      ["&#x9999;", 'U+9999'],
      ["&#x99999;", 'U+99999'],
      ["&#1111553;", 'U+10F601'],
      ["&#128513;", 'U+1F601'],
      ["&#9;", 'U+0009'],
      ["&#99;", 'U+0063'],
      ["&#999;", 'U+03E7'],
      ["&#9999;", 'U+270F'],
      ["&#99999;", 'U+1869F'],
      ['0000;', '0000;'],
      ['X;', 'X;'],
      ['123;', '123;'],
      [';', ';'],
      [' ;', ' ;']
    ].forEach(function (values) {
      it(('should convert "' + values[0] + '"').padEnd(25, " ") + 'to "' + values[1] + '"', async function () {
        await doesNotReject(async () => util.convertToUnicodeCodePoint(values[0] as string) === values[1]);
      });
    });
  });
});
