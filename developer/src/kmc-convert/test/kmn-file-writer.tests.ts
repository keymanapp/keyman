/*
 * Keyman is copyright (C) SIL Global. MIT License.
 *
 * Created by S. Schmitt on 2025-05-12
 *
 * Tests for KeylayoutToKmnConverter, KeylayoutFileReader, KmnFileWriter
 *
 */

import 'mocha';
import { assert } from 'chai';
import KEYMAN_VERSION from "@keymanapp/keyman-version";
import { compilerTestCallbacks, compilerTestOptions, makePathToFixture } from './helpers/index.js';
import { KeylayoutToKmnConverter, ProcessedData, Rule } from '../src/keylayout-to-kmn/keylayout-to-kmn-converter.js';
import { KmnFileWriter } from '../src/keylayout-to-kmn/kmn-file-writer.js';
import { KeylayoutFileReader } from '../src/keylayout-to-kmn/keylayout-file-reader.js';
import { ConverterMessages } from '../src/converter-messages.js';
describe('KmnFileWriter', function () {

  before(function () {
    compilerTestCallbacks.clear();
  });


  describe("write() ", function () {
    const inputFilename = makePathToFixture('../data/Test.keylayout');
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sutR = new KeylayoutFileReader(compilerTestCallbacks);
    const sutW = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const read = sutR.read(inputFilename);
    const converted = sut.convertBound.convert(read, inputFilename.replace(/\.keylayout$/, '.kmn'));

    // empty ProcesData from unavailable file name
    const inputFilename_unavailable = makePathToFixture('../data/X.keylayout');
    const read_unavailable = sut_r.read(inputFilename_unavailable);
    const converted_unavailable = sut.convert_bound.convert(read_unavailable, inputFilename_unavailable.replace(/\.keylayout$/, '.kmn'));

    it('write() should return null in case of missing inputfile', async function () {
      const result = sut_w.write(converted_unavailable);
      assert.isNull(result);
    });

    it('write() should return result for input file ' + inputFilename, async function () {
      const result = sut_w.write(converted);
      assert.isNotNull(result);
    });
  });

  describe("writeDataRules() ", function () {
    const inputFilename = makePathToFixture('../data/Test.keylayout');
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sutR = new KeylayoutFileReader(compilerTestCallbacks);
    const sutW = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const read = sutR.read(inputFilename);
    const converted = sut.convertBound.convert(read, inputFilename.replace(/\.keylayout$/, '.kmn'));

    // empty ProcessedData from unavailable file name
    const inputFilenameUnavailable = makePathToFixture('../data/X.keylayout');
    const readUnavailable = sutR.read(inputFilenameUnavailable);
    const convertedUnavailable = sut.convertBound.convert(readUnavailable, inputFilenameUnavailable.replace(/\.keylayout$/, '.kmn'));

    it('writeDataRules() should return true (no error) if written', async function () {
      const result = sutW.writeDataRules(converted);
      assert.isTrue(result.length > 0);
    });

    it('writeDataRules() should return false if no inputfile', async function () {
      const result = sutW.writeDataRules(convertedUnavailable);
      assert.isFalse(result.length > 0);
    });

  });

  describe("writeKmnFileHeader() ", function () {
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sutR = new KeylayoutFileReader(compilerTestCallbacks);
    const sutW = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    const inputFilename = makePathToFixture('../data/Test.keylayout');
    const read = sutR.read(inputFilename);
    const converted = sut.convertBound.convert(read, inputFilename.replace(/\.keylayout$/, '.kmn'));

    // empty ProcessedData from unavailable file name
    const inputFilenameUnavailable = makePathToFixture('../data/X.keylayout');
    const readUnavailable = sutR.read(inputFilenameUnavailable);
    const convertedUnavailable = sut.convertBound.convert(readUnavailable, inputFilenameUnavailable.replace(/\.keylayout$/, '.kmn'));

    // empty ProcessedData from empty filename
    const inputFilenameEmpty = makePathToFixture('');
    const readEmpty = sutR.read(inputFilenameEmpty);
    const convertedEmpty = sut.convertBound.convert(readEmpty, inputFilenameEmpty);

    const outExpectedFirst: string =
      "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "c Keyman keyboard generated by kmn-convert version: " + KEYMAN_VERSION.VERSION + "\n"
      + "c from Ukelele file: ";

    const outExpectedLast: string =
      "\n"
      + "c ..................................................................................................................\n"
      + "c ..................................................................................................................\n"
      + "\n"
      + "store(&TARGETS) 'desktop'\n"
      + "\n"
      + "begin Unicode > use(main)\n\n"
      + "group(main) using keys\n\n"
      + "\n";

    it(('writeKmnFileHeader should return store text with filename ').padEnd(62, " ") + 'on correct input', async function () {
      const writtenCorrectName = sutW.writeKmnFileHeader(converted);
      assert.equal(writtenCorrectName, (outExpectedFirst + converted.keylayoutFilename + outExpectedLast));
    });

    it(('writeKmnFileHeader should return store text without filename ').padEnd(62, " ") + 'on empty input', async function () {
      const writtenEmptyName = sutW.writeKmnFileHeader(convertedEmpty);
      assert.equal(writtenEmptyName, (outExpectedFirst + outExpectedLast));
    });

    it(('writeKmnFileHeader should return store text without filename ').padEnd(62, " ") + 'on only filename as input', async function () {
      const writtenOnlyName = sutW.writeKmnFileHeader(convertedUnavailable);
      assert.equal(writtenOnlyName, (outExpectedFirst + convertedUnavailable.keylayoutFilename + outExpectedLast));
    });
  });

  describe('reviewRules messages', function () {
    const sutW = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);

    [
      [[new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'UNAVAILABLE', 'K_A', new TextEncoder().encode('A'))],
      [''],
      [''],
      ['c WARNING: unavailable modifier : here: ']],

      [[new Rule("C1", '', '', 0, 0, 'CAPS', 'K_EQUAL', 0, 0, 'UNAVAILABLE', 'K_B', new TextEncoder().encode('B'))],
      [''],
      [''],
      ['c WARNING: unavailable modifier : here: ']],

      [[new Rule("C2", '', '', 0, 0, 'CAPS', 'K_EQUAL', 0, 0, 'UNAVAILABLE', 'K_C', new TextEncoder().encode('C'),)],
      [''],
      [''],
      ['c WARNING: unavailable modifier : here: ']],

      [[new Rule("C2", '', '', 0, 0, 'UNAVAILABLE_dk', 'K_EQUAL', 0, 0, 'UNAVAILABLE', 'K_C', new TextEncoder().encode('C'),)],
      [''],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable modifier : here: ']],

      [[new Rule("C3", 'UNAVAILABLE_prev_dk', 'K_D', 0, 0, 'UNAVAILABLE_dk', 'K_EQUAL', 0, 0, 'SHIFT', 'K_C', new TextEncoder().encode('D'),)],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable superior rule ( [UNAVAILABLE_dk K_EQUAL]  >  dk(B0) ) : here: ']],

      [[new Rule("C3", 'UNAVAILABLE_prev_dk', 'K_D', 0, 0, 'UNAVAILABLE_dk', 'K_EQUAL', 0, 0, 'UNAVAIL', 'K_C', new TextEncoder().encode('D'),)],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable modifier : here: ']],

      [[new Rule("C3", 'CAPS', 'K_D', 0, 0, 'RALT', 'K_EQUAL', 0, 0, 'SHIFT', 'K_C', new TextEncoder().encode('D'),)],
      [''],
      [''],
      ['']],

      [[new Rule("C3", 'X', 'K_X', 0, 0, 'Y', 'K_Y', 0, 0, 'SHIFT', 'K_Z', new TextEncoder().encode('D'),)],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable modifier : here: '],
      ['c WARNING: unavailable superior rule ( [Y K_Y]  >  dk(B0) ) : here: ']],

    ].forEach(function (values: any, index: number) {
      it(('rule " ' + values[0][0].ruleType + ' "') + 'should create "' + values[1] + ' | ' + values[2] + ' | ' + values[3] + '"', async function () {
        const result: string[] = sutW.reviewRules(values[0], 0);
        assert.equal(result[0], values[1][0]);
        assert.equal(result[1], values[2][0]);
        assert.equal(result[2], values[3][0]);
      });
    });
  });

  describe('reviewRules messages duplicate and ambiguous', function () {

    const sutW = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    [
      //all
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),],
      ['c WARNING: duplicate rule: earlier: [LALT K_A]  >  dk(C0) here: '],
      ["c WARNING: duplicate rule: earlier: dk(B0) + [SHIFT K_B]  >  dk(B0) here: "],
      ["c WARNING: duplicate rule: earlier: dk(B0) + [CAPS K_C]  >  'X' here: "]],

      //6-6 dup
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'CTRL', 'K_D', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),],
      [''],
      [""],
      ["c WARNING: duplicate rule: earlier: dk(B0) + [CAPS K_C]  >  'X' here: "]],

      //6-6 amb
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'CTRL', 'K_D', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('Y')),],
      [''],
      [""],
      ["c WARNING: ambiguous rule: earlier: dk(B0) + [CAPS K_C]  >  'X' here: "]],

      // 5-5 amb
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'NCAPS', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'NCAPS', 'K_B', 0, 1, 'RALT', 'K_F', new TextEncoder().encode('X')),],
      ['c WARNING: duplicate rule: earlier: [LALT K_A]  >  dk(C0) here: '],
      ["c WARNING: ambiguous rule: earlier: dk(B0) + [NCAPS K_B]  >  dk(B0) here: "], [''],
      ],

      // 5-5 dup
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'NCAPS', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'NCAPS', 'K_B', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('X')),],
      ['c WARNING: duplicate rule: earlier: [LALT K_A]  >  dk(C0) here: '],
      ["c WARNING: duplicate rule: earlier: dk(B0) + [NCAPS K_B]  >  dk(B0) here: "],
      ['']],

      // 4-2 amb
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'LALT', 'K_A', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('X')),],
      ['c WARNING: ambiguous rule: later: [LALT K_A]  >  dk(C0) here: '],
      [''],
      ['']],

      // 4-4 amb
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'LALT', 'K_A', 1, 1, 'NCAPS', 'K_E', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('Y')),],
      ['c WARNING: ambiguous rule: earlier: [LALT K_A]  >  dk(C0) here: '],
      [""],
      [''],],

      // 4-4 dup
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'NCAPS', 'K_E', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('X')),],
      ['c WARNING: duplicate rule: earlier: [LALT K_A]  >  dk(C0) here: '],
      [''],
      ['']],

      // 4-2 amb
      [[
        new Rule("C3", 'LALT', 'K_A', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'LALT', 'K_A', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('Y')),],
      ['c WARNING: ambiguous rule: later: [LALT K_A]  >  dk(C0) here: '],
      [''],
      ['']],

      // 6-3 dup
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'CTRL', 'K_D', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),],
      [''],
      ["c WARNING: duplicate rule: earlier: dk(C0) + [CAPS K_C]  >  'X' here: "],
      [''],],

      // 6-3 amb
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'CTRL', 'K_D', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('Y')),],
      [''],
      ["c WARNING: ambiguous rule: earlier: dk(C0) + [CAPS K_C]  >  'X' here: "],
      [''],],

      // 2-4 amb
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C3", 'SHIFT', 'K_B', 0, 0, 'NCAPS', 'K_E', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('Y')),],
      ['c WARNING: ambiguous rule: earlier: [SHIFT K_B]  >  dk(A0) here: '],
      [''],
      ['']],

      //2-2 amb
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 1, 1, 'RALT', 'K_F', new TextEncoder().encode('Y')),],
      [''],
      ['c WARNING: ambiguous rule: earlier: [SHIFT K_B]  >  dk(C0) here: '],
      ['']],

      // 2-2 dup
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'RALT', 'K_F', new TextEncoder().encode('Y')),],
      [''],
      ['c WARNING: duplicate rule: earlier: [SHIFT K_B]  >  dk(C0) here: '],
      ['']],

      // 3-3 dup
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),],
      [''],
      [''],
      ["c WARNING: duplicate rule: earlier: dk(A0) + [CAPS K_C]  >  'X' here: "]],

      // 3-3 amb
      [[
        new Rule("C2", '', '', 0, 0, 'SHIFT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C2", '', '', 0, 0, 'NCAPS', 'K_E', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('Y')),],
      [''],
      [''],
      ["c WARNING: ambiguous rule: earlier: dk(A0) + [CAPS K_C]  >  'X' here: "]],

      // 2-1 amb
      [[
        new Rule("C2", '', '', 0, 0, 'RALT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'RALT', 'K_B', new TextEncoder().encode('Y'))],
      [''],
      [''],
      ['c WARNING: ambiguous rule: later: [RALT K_B]  >  dk(A0) here: ']],

      // 1-1 amb
      [[
        new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('Y'))],
      [''],
      [''],
      ["c WARNING: ambiguous rule: earlier: [CAPS K_C]  >  'X' here: "]],

      // 1-1 amb
      [[
        new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X')),
        new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('X'))],
      [''],
      [''],
      ["c WARNING: duplicate rule: earlier: [CAPS K_C]  >  'X' here: "]],

    ].forEach(function (values: any, index: number) {
      it('rule ' + values[0][0].ruleType + ' should create " ' + ' "' + values[1] + ' | ' + values[2] + ' | ' + values[3] + '"', async function () {
        const result: string[] = sutW.reviewRules(values[0], 1);
        assert.equal(result[0], values[1][0]);
        assert.equal(result[1], values[2][0]);
        assert.equal(result[2], values[3][0]);
      });
    });
  });

  describe('reviewRules messages duplicate and ambiguous with Extra warning', function () {
    const sutW = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    [[[
      new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'RALT', 'K_B', new TextEncoder().encode('X')),
      new Rule("C2", '', '', 0, 0, 'RALT', 'K_B', 0, 0, 'CAPS', 'K_C', new TextEncoder().encode('Y')),
      new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'RALT', 'K_B', new TextEncoder().encode('Z'))
    ],
    [''],
    [''],
    ["c WARNING: ambiguous rule: later: [RALT K_B]  >  dk(A0) ambiguous rule: earlier: [RALT K_B]  >  'X' here: PLEASE CHECK THE FOLLOWING RULE AS IT WILL NOT BE WRITTEN !  "]],
    ].forEach(function (values: any, index: number) {
      it(('rule ' + values[0][0].ruleType + ' should create " ' + ' "') + values[1] + ' | ' + values[2] + ' | ' + values[3] + '"', async function () {
        const result: string[] = sutW.reviewRules(values[0], 2);
        assert.equal(result[0], values[1][0]);
        assert.equal(result[1], values[2][0]);
        assert.equal(result[2], values[3][0]);
      });
    });
  });

  describe('write from intermediate data array', function () {
    const sutW = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);
    [
      [
        [ /* see ../data/Test_C0.keylayout */
          new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'NCAPS', 'K_A', new TextEncoder().encode('a')),
          new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_A', new TextEncoder().encode('A')),
          new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'NCAPS', 'K_S', new TextEncoder().encode('s')),
          new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'NCAPS', 'K_D', new TextEncoder().encode('d'))
        ],
        ["+ [NCAPS K_A]  >  'a'\n" +
          "+ [CAPS K_A]  >  'A'\n\n" +
          "+ [NCAPS K_S]  >  's'\n\n" +
          "+ [NCAPS K_D]  >  'd'\n"]
      ],
      [
        [ /* see ../data/Test_C1.keylayout */
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'NCAPS', 'K_S', new TextEncoder().encode('s')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_S', new TextEncoder().encode('S'))
        ],
        ["+ [NCAPS K_S]  >  's'\n" +
          "+ [CAPS K_S]  >  'S'\n"]
      ],
      [
        [ /* see ../data/Test_C2.keylayout */
          new Rule("C2", '', '', 0, 0, 'NCAPS', 'K_U', 1, 1, 'CAPS', 'K_A', new TextEncoder().encode('Â'))
        ],
        ["+ [NCAPS K_U]  >  dk(A1)\n" +
          "dk(A1) + [CAPS K_A]  >  'Â'\n\n"]
      ],
      [
        [ /* see ../data/Test_C3.keylayout */
          new Rule("C3", 'NCAPS SHIFT', 'K_D', 2, 1, 'NCAPS', 'K_U', 1, 2, 'CAPS', 'K_A', new TextEncoder().encode('Â'))
        ],
        ["+ [NCAPS SHIFT K_D]   >   dk(A2)\n" +
          "dk(A2)  + [NCAPS K_U]  >  dk(B1)\n" +
          "dk(B1) + [CAPS K_A]  >  'Â'\n\n"
        ]
      ],
      [
        [ /* see ../data/Test_C0_C1_C2_C3.keylayout */
          new Rule("C0", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_A', new TextEncoder().encode('A')),
          new Rule("C2", '', '', 0, 0, 'NCAPS RALT', 'K_EQUAL', 1, 1, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_S', new TextEncoder().encode('S')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'NCAPS RALT', 'K_U', new TextEncoder().encode('S')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 1, 'CAPS', 'K_S', 2, 6, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'CAPS', 'K_U', 3, 3, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'NCAPS RALT', 'K_S', 4, 4, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'NCAPS RALT', 'K_U', 5, 5, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_S', new TextEncoder().encode('S')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'NCAPS RALT', 'K_U', new TextEncoder().encode('S')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'CAPS', 'K_S', 2, 0, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'CAPS', 'K_U', 3, 0, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'NCAPS RALT', 'K_S', 4, 0, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 6, 0, 'NCAPS RALT', 'K_U', 5, 0, 'CAPS', 'K_D', new TextEncoder().encode('Â')),
          new Rule("C1", '', '', 0, 0, '', '', 0, 0, 'CAPS', 'K_U', new TextEncoder().encode('U')),
        ],
        ["+ [CAPS K_A]  >  'A'\n" +
          "+ [CAPS K_S]  >  'S'\n\n" +
          "+ [NCAPS RALT K_U]  >  'S'\n" +
          "+ [CAPS K_U]  >  'U'\n" +
          "+ [NCAPS RALT K_EQUAL]  >  dk(A1)\n" +
          "dk(A1) + [CAPS K_D]  >  'Â'\n\n" +
          "+ [NCAPS RALT K_8]   >   dk(A6)\n" +
          "dk(A6)  + [CAPS K_S]  >  dk(B2)\n" +
          "dk(B2) + [CAPS K_D]  >  'Â'\n\n" +
          "dk(A6)  + [CAPS K_U]  >  dk(B3)\n" +
          "dk(B3) + [CAPS K_D]  >  'Â'\n\n" +
          "dk(A6)  + [NCAPS RALT K_S]  >  dk(B4)\n" +
          "dk(B4) + [CAPS K_D]  >  'Â'\n\n" +
          "dk(A6)  + [NCAPS RALT K_U]  >  dk(B5)\n" +
          "dk(B5) + [CAPS K_D]  >  'Â'\n\n"]
      ],
      [
        [ /* see ../data/Test_C3_several.keylayout */
          new Rule("C3", 'NCAPS RALT', 'K_8', 3, 1, 'CAPS', 'K_U', 1, 3, 'NCAPS', 'K_A', new TextEncoder().encode('â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 3, 0, 'CAPS', 'K_U', 1, 0, 'NCAPS RALT', 'K_A', new TextEncoder().encode('â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 3, 0, 'NCAPS RALT', 'K_U', 2, 2, 'NCAPS', 'K_A', new TextEncoder().encode('â')),
          new Rule("C3", 'NCAPS RALT', 'K_8', 3, 0, 'NCAPS RALT', 'K_U', 2, 0, 'NCAPS RALT', 'K_A', new TextEncoder().encode('â'))
        ],
        ["+ [NCAPS RALT K_8]   >   dk(A3)\n" +
          "dk(A3)  + [CAPS K_U]  >  dk(B1)\n" +
          "dk(B1) + [NCAPS K_A]  >  'â'\n\n" +
          "dk(B1) + [NCAPS RALT K_A]  >  'â'\n\n" +
          "dk(A3)  + [NCAPS RALT K_U]  >  dk(B2)\n" +
          "dk(B2) + [NCAPS K_A]  >  'â'\n\n" +
          "dk(B2) + [NCAPS RALT K_A]  >  'â'\n\n"
        ]
      ],
    ].forEach(function (values: any) {
      it(('an array of Rules should create a set of kmn rules '), async function () {
        const data: ProcessedData = {
          keylayoutFilename: "",
          kmnFilename: "",
          arrayOfModifiers: [[]],
          arrayOfRules: values[0]
        };
        const result1 = sutW.writeDataRules(data);
        assert.isTrue(result1 === values[1][0]);
      });
    });
  });

  describe("write() should throw for invalid output characters ", function () {
    const sut = new KeylayoutToKmnConverter(compilerTestCallbacks, compilerTestOptions);
    const sut_r = new KeylayoutFileReader(compilerTestCallbacks);
    const sut_w = new KmnFileWriter(compilerTestCallbacks, compilerTestOptions);

    [
      ['../data/Test_invalidInput_C0.keylayout', "U+-456", "CAPS", "K_S"],
      ['../data/Test_invalidInput_C1.keylayout', "U+-123", "NCAPS SHIFT", "K_U"],
      ['../data/Test_invalidInput_C2.keylayout', "U+-123", "CAPS", "K_D"],
      ['../data/Test_invalidInput_C3.keylayout', "U+-123", "CAPS", "K_D"],
    ].forEach(function (values) {
      it(("run() should throw on invalid input output character: " + values[0] + ")") +
        ' contains unsupported character \'' + values[1] +
        "\' at " + values[2] + " " + values[3] + ".", async function () {
          const inputName = makePathToFixture(values[0]);
          const read = sut_r.read(inputName);
          const converted = sut.convert_bound.convert(read, inputName.replace(/\.keylayout$/, '.kmn'));
          const result = sut_w.writeData_Rules(converted);

          assert.isNull(result);
          assert.equal(compilerTestCallbacks.messages.length, 1);
          assert.deepEqual(compilerTestCallbacks.messages[0], ConverterMessages.Error_UnsupportedCharactersDetected({
            inputFilename: inputName,
            output: values[1],
            keymap_index: values[2],
            KeyName: values[3]
          }));
        });
    });
  });

});
