/*
 * Keyman is 2025 copyright (C) SIL International. MIT License.
 *
 * Created by S. Schmitt on 2025-05-12
 *
 * Write Keyman .kmn files
 *
 */

import { CompilerCallbacks, CompilerOptions } from "@keymanapp/developer-utils";
import { KeylayoutToKmnConverter, ProcesData, Rule } from './keylayout-to-kmn-converter.js';
import { ConverterMessages } from '../converter-messages.js';
import KEYMAN_VERSION from "@keymanapp/keyman-version";
import { convertUtil } from '@keymanapp/common-types';

export class KmnFileWriter {

  constructor(private callbacks: CompilerCallbacks, private options: CompilerOptions) { };

  /**
   * @brief  member function to write data from object to a Uint8Array
   * @param  data_ukelele the array holding all keyboard data
   * @return a Uint8Array holding data
   */
  public write(data_ukelele: ProcesData): Uint8Array {
    let data: string = "\n";

    // add top part of kmn file: STORES
    data += this.write_KmnFileHeader(data_ukelele);

    // add bottom part of kmn file: RULES
    data += this.writeData_Rules(data_ukelele);

    try {
      return new TextEncoder().encode(data);
    } catch (err) {
      this.callbacks.reportMessage(ConverterMessages.Error_UnableToWrite({ outputFilename: data_ukelele.kmn_filename }));
      return null;
    }
  }
/**
   * @brief  member function to write data from object to a kmn file
   * @param  data_ukelele the array holding all keyboard data
   * @param  outputfilename the file that will be written; if no outputfilename is given an outputfilename will be created from data_ukelele.keylayout_filename
   * @return true if data has been written; false if not
   */
  public writeToFile(data_ukelele: ProcesData): boolean {

    let data: string = "\n";

    // add top part of kmn file: STORES
    data += this.write_KmnFileHeader(data_ukelele);

    // add bottom part of kmn file: RULES
    data += this.writeData_Rules(data_ukelele);

    try {
      this.callbacks.fs.writeFileSync(data_ukelele.kmn_filename, new TextEncoder().encode(data));
      return true;
    } catch (err) {
      this.callbacks.reportMessage(ConverterMessages.Error_UnableToWrite({outputFilename: data_ukelele.kmn_filename}));
      return false;
    }
  }
  /**
   * @brief  member function to create data for the header (stores) that will be printed to the resulting kmn file
   * @param  data_ukelele an object containing all data read from a .keylayout file
   * @return string -  all stores to be printed
   */
  public write_KmnFileHeader(data_ukelele: ProcesData): string {

    let data: string = "";

    data += "c ..................................................................................................................\n";
    data += "c ..................................................................................................................\n";
    data += "c Keyman keyboard generated by kmn-convert version: " + KEYMAN_VERSION.VERSION + "\n";
    data += "c from Ukelele file: " + data_ukelele.keylayout_filename + "\n";
    data += "c ..................................................................................................................\n";
    data += "c ..................................................................................................................\n";
    data += "\n";

    data += "store(&TARGETS) \'desktop\'\n";

    data += "\n";
    data += "begin Unicode > use(main)\n\n";
    data += "group(main) using keys\n\n";

    data += "\n";
    return data;
  }

  /**
   * @brief  member function to create data from rules that will be printed to the resulting kmn file
   * @param  data_ukelele an object containing all data read from a .keylayout file
   * @return string -  all rules to be printed
   */
  public writeData_Rules(data_ukelele: ProcesData): string {

    const keylayoutKmnConverter = new KeylayoutToKmnConverter(this.callbacks, this.options);
    let data: string = "";

    // filter array of all rules and remove duplicates
    // during the process of creating Rule[], duplicate rules might occur
    // (e.g. when in a keylayout file the same modifiers occur in several behaviors thus producing the same rules).
    // This is to filter out those duplicate Rule objects
    const unique_data_Rules: Rule[] = data_ukelele.arrayOf_Rules.filter((curr) => {
      return (!(curr.output === new TextEncoder().encode("") || curr.output === undefined)
        && (curr.key !== "")
        && ((curr.rule_type === "C0")
          || (curr.rule_type === "C1")
          || (curr.rule_type === "C2" && (curr.deadkey !== ""))
          || (curr.rule_type === "C3" && (curr.deadkey !== "") && (curr.prev_deadkey !== "")))
      );
    }).reduce((unique, o) => {
      if (!unique.some((obj: Rule) =>
        new TextDecoder().decode(obj.output) === new TextDecoder().decode(o.output)

        && obj.rule_type === o.rule_type
        && obj.modifier_key === o.modifier_key
        && obj.key === o.key

        && obj.modifier_deadkey === o.modifier_deadkey
        && obj.deadkey === o.deadkey

        && obj.modifier_prev_deadkey === o.modifier_prev_deadkey
        && obj.prev_deadkey === o.prev_deadkey)
      ) {
        unique.push(o);
      }
      return unique;
    }, []);

    //................................................ C0 C1 ................................................................

    for (let k = 0; k < unique_data_Rules.length; k++) {

      if ((unique_data_Rules[k].rule_type === "C0") || (unique_data_Rules[k].rule_type === "C1")) {

        // lookup key nr of the key which is being processed
        let keyNr: number = 0;
        for (let j = 0; j <= KeylayoutToKmnConverter.MAX_KEY_COUNT; j++) {
          if (keylayoutKmnConverter.map_UkeleleKC_To_VK(j) === unique_data_Rules[k].key) {
            keyNr = j;
            break;
          }
        }

        // skip keyNr 48 (K_TAB) and 36 (K_ENTER)
        if ((keyNr === 48) || (keyNr === 36)) {
          continue;
        }

        //---------------------------------------------------------------------------------------------

        // add a line after rules of each key
        if ((k > 1) && (unique_data_Rules[k - 1].key !== unique_data_Rules[k].key) && (unique_data_Rules[k - 1].rule_type === unique_data_Rules[k].rule_type)) {
          data += '\n';
        }

        // use of Unicode Character vs Unicode Codepoint;
        // If it`s a ctrl character we print out the Unicode Codepoint else we print out the Unicode Character
        let version_output_character;
        const warn_text = this.reviewRules(unique_data_Rules, k);

        const output_character = new TextDecoder().decode(unique_data_Rules[k].output);
        const output_Unicode_Character = convertUtil.convertToUnicodeCharacter(output_character);
        const output_Unicode_CodePoint = convertUtil.convertToUnicodeCodePoint(output_character);

        if ((output_Unicode_Character !== undefined) && (output_Unicode_CodePoint !== undefined)) {

          // if we are about to print a unicode codepoint instead of a single character we need to check if it is a control character
          if ((Number("0x" + output_Unicode_CodePoint.substring(2, output_Unicode_CodePoint.length)) < KeylayoutToKmnConverter.MAX_CTRL_CHARACTER)) {

            version_output_character = output_Unicode_CodePoint;

            if (output_Unicode_CodePoint.length > 1) {
              if (warn_text[2] == "") {
                warn_text[2] = warn_text[2] + "c WARNING: use of a control character " /*+ output_Unicode_CodePoint*/;
              }
              else {
                warn_text[2] = warn_text[2] + " Use of a control character "/* + output_Unicode_CodePoint*/;
              }
            }
          } else {
            version_output_character = output_Unicode_Character;
          }
        }
        // add a warning in front of rules in case unavailable modifiers or ambiguous rules are used
        // if warning contains duplicate rules we do not write out the entire rule
        // (even if there are other warnings for the same rule) since that rule had been written before
        if ((warn_text[2].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[2].length > 0)) {
            warningTextToWrite = warn_text[2];
          }

          if (!((warn_text[2].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            if (version_output_character === "'") {
              data += warningTextToWrite
                + "+ ["
                + (unique_data_Rules[k].modifier_key + ' ' + unique_data_Rules[k].key).trim()
                + `]  >  \"`
                + version_output_character
                + '\"\n';
            }
            else {
              data += warningTextToWrite
                + "+ ["
                + (unique_data_Rules[k].modifier_key + ' ' + unique_data_Rules[k].key).trim()
                + `]  >  \'`
                + version_output_character
                + '\'\n';
            }
          }
        }
      }
    }

    //................................................ C2 ...................................................................
    for (let k = 0; k < unique_data_Rules.length; k++) {

      if (unique_data_Rules[k].rule_type === "C2") {

        // use of Unicode Character vs Unicode Codepoint;
        // If it`s a ctrl character we print out the Unicode Codepoint else we print out the Unicode Character
        let version_output_character;
        const warn_text = this.reviewRules(unique_data_Rules, k);

        const output_character = new TextDecoder().decode(unique_data_Rules[k].output);
        const output_Unicode_Character = convertUtil.convertToUnicodeCharacter(output_character);
        const output_Unicode_CodePoint = convertUtil.convertToUnicodeCodePoint(output_character);

        if ((output_Unicode_Character !== undefined) && (output_Unicode_CodePoint !== undefined)) {
          // if we are about to print a unicode codepoint instead of a single character we need to check if it is a control character
          if (Number("0x" + output_Unicode_CodePoint.substring(2, output_Unicode_CodePoint.length)) < KeylayoutToKmnConverter.MAX_CTRL_CHARACTER) {
            version_output_character = output_Unicode_CodePoint;
            if (output_Unicode_CodePoint.length > 1) {
              if (warn_text[2] == "") {
                warn_text[2] = warn_text[2] + "c WARNING: use of a control character ";
              }
              else {
                warn_text[2] = warn_text[2] + "; Use of a control character ";
              }
            }
          } else {
            version_output_character = output_Unicode_Character;
          }
        }

        // add a warning in front of rules in case unavailable modifiers or ambiguous rules are used
        // if warning contains duplicate rules we do not write out the entire rule
        // (even if there are other warnings for the same rule) since that rule had been written before
        if ((warn_text[1].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[1].length > 0)) {
            warningTextToWrite = warn_text[1];
          }

          if (!((warn_text[1].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite
              + "+ [" + (unique_data_Rules[k].modifier_deadkey + " "
                + unique_data_Rules[k].deadkey).trim()
              + "]  >  dk(A" + String(unique_data_Rules[k].id_deadkey)
              + ")\n";
          }
        }

        if ((warn_text[2].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[2].length > 0)) {
            warningTextToWrite = warn_text[2];
          }

          if (!((warn_text[2].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            if (version_output_character === "'") {
              data += warningTextToWrite
                + "dk(A"
                + (String(unique_data_Rules[k].id_deadkey) + ") + ["
                  + unique_data_Rules[k].modifier_key).trim()
                + " "
                + unique_data_Rules[k].key + ']  >  \"'
                + version_output_character
                + '\"\n';
            }
            else {
              data += warningTextToWrite
                + "dk(A"
                + (String(unique_data_Rules[k].id_deadkey) + ") + ["
                  + unique_data_Rules[k].modifier_key).trim()
                + " "
                + unique_data_Rules[k].key + "]  >  \'"
                + version_output_character
                + "\'\n";
            }


          }
          data += "\n";
        }
      }
    }

    //................................................ C3 ...................................................................

    for (let k = 0; k < unique_data_Rules.length; k++) {
      if (unique_data_Rules[k].rule_type === "C3") {

        // use of Unicode Character vs Unicode Codepoint;
        // If it`s a ctrl character we print out the Unicode Codepoint else we print out the Unicode Character
        let version_output_character;

        const warn_text = this.reviewRules(unique_data_Rules, k);
        const output_character = new TextDecoder().decode(unique_data_Rules[k].output);
        const output_Unicode_Character = convertUtil.convertToUnicodeCharacter(output_character);
        const output_Unicode_CodePoint = convertUtil.convertToUnicodeCodePoint(output_character);

        if ((output_Unicode_Character !== undefined) && (output_Unicode_CodePoint !== undefined)) {
          // if we are about to print a unicode codepoint instead of a single character we need to check if a control character is to be used
          if (Number("0x" + output_Unicode_CodePoint.substring(2, output_Unicode_CodePoint.length)) < KeylayoutToKmnConverter.MAX_CTRL_CHARACTER) {

            version_output_character = output_Unicode_CodePoint;

            if (output_Unicode_CodePoint.length > 1) {
              if (warn_text[2] == "") {
                warn_text[2] = warn_text[2] + "c WARNING: use of a control character ";
              }
              else {
                warn_text[2] = warn_text[2] + "; Use of a control character ";
              }
            }
          } else {
            version_output_character = output_Unicode_Character;
          }
        }
        // add a warning in front of rules in case unavailable modifiers or ambiguous rules are used
        // if warning contains duplicate rules we do not write out the entire rule
        // (even if there are other warnings for the same rule) since that rule had been written before
        if ((warn_text[0].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";

          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[0].length > 0)) {
            warningTextToWrite = warn_text[0];
          }

          if (!((warn_text[0].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite
              + "+ ["
              + (unique_data_Rules[k].modifier_prev_deadkey + " "
                + unique_data_Rules[k].prev_deadkey).trim()
              + "]   >   dk(A"
              + String(unique_data_Rules[k].id_prev_deadkey) + ")\n";
          }
        }

        if ((warn_text[1].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[1].length > 0)) {
            warningTextToWrite = warn_text[1];
          }

          if (!((warn_text[1].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite
              + "dk(A" + (String(unique_data_Rules[k].id_prev_deadkey) + ")  + ["
                + unique_data_Rules[k].modifier_deadkey).trim()
              + " "
              + unique_data_Rules[k].deadkey
              + "]  >  dk(B"
              + String(unique_data_Rules[k].id_deadkey)
              + ")\n";
          }
        }

        if ((warn_text[2].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[2].length > 0)) {
            warningTextToWrite = warn_text[2];
          }

          if (!((warn_text[2].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite + "dk(B"
              + (String(unique_data_Rules[k].id_deadkey)
                + ") + ["
                + unique_data_Rules[k].modifier_key).trim()
              + " "
              + unique_data_Rules[k].key
              + "]  >  \'"
              + version_output_character
              + "\'\n";
          }
        }

        if ((warn_text[0].indexOf("duplicate") < 0) || (warn_text[1].indexOf("duplicate") < 0) || (warn_text[2].indexOf("duplicate") < 0)) {
          data += "\n";
        }
      }
    }
    return data;
  }

  /**
   * @brief  member function to review rules for acceptable modifiers, duplicate or ambiguous rules and return an array containing possible warnings.
   *         Keyman can not handle duplicate rules so we need to make sure a rule is written only once by either omitting a duplicate rule or commenting out an ambiguous rule.
   *         Omitting rules and definition of comparisons e.g. 1-1, 2-4, 6-6
   *         see https://docs.google.com/document/d/12J3NGO6RxIthCpZDTR8FYSRjiMgXJDLwPY2z9xqKzJ0/edit?tab=t.0#heading=h.pcz8rjyrl5ug
   * @param  rule : Rule[] - an array of all rules
   * @param  index the index of a rule in Rule[]
   * @return a string[] containing possible warnings for a rule
   */
  public reviewRules(rule: Rule[], index: number): string[] {

    const keylayoutKmnConverter = new KeylayoutToKmnConverter(this.callbacks, this.options);
    const warningTextArray: string[] = Array(3).fill("");

    // ------------------------- check unavailable modifiers -------------------------

    if ((rule[index].rule_type === "C0") || (rule[index].rule_type === "C1")) {
      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifier_key)) {
        warningTextArray[2] = "unavailable modifier : ";
      }
    }

    else if (rule[index].rule_type === "C2") {
      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifier_deadkey)) {
        warningTextArray[1] = "unavailable modifier : ";
        warningTextArray[2] = "unavailable superior rule ( ["
          + rule[index].modifier_deadkey + " "
          + rule[index].deadkey
          + "]  >  dk(A"
          + rule[index].id_deadkey
          + ") ) : ";
      }
      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifier_key)) {
        warningTextArray[2] = "unavailable modifier : ";
      }
    }

    else if (rule[index].rule_type === "C3") {

      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifier_prev_deadkey)) {
        warningTextArray[0] = "unavailable modifier : ";
        warningTextArray[1] = "unavailable superior rule ( ["
          + rule[index].modifier_prev_deadkey + " "
          + rule[index].prev_deadkey
          + "]  >  dk(A"
          + rule[index].id_prev_deadkey
          + ") ) : ";
      }

      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifier_deadkey)) {
        warningTextArray[1] = "unavailable modifier : ";
        warningTextArray[2] = "unavailable superior rule ( ["
          + rule[index].modifier_deadkey + " "
          + rule[index].deadkey
          + "]  >  dk(B"
          + rule[index].id_deadkey
          + ") ) : ";
      }

      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifier_key)) {
        warningTextArray[2] = "unavailable modifier : ";
      }
    }

    // ------------------------- check ambiguous/duplicate rules -------------------------

    if ((rule[index].rule_type === "C0") || (rule[index].rule_type === "C1")) {

      // 1-1: + [CAPS K_N]  > 'N' <-> + [CAPS K_N]  >  'A'
      const amb_1_1 = rule.filter((curr, idx) =>
        (curr.rule_type === "C0" || curr.rule_type === "C1")
        && curr.modifier_prev_deadkey === ""
        && curr.prev_deadkey === ""
        && curr.modifier_deadkey === ""
        && curr.deadkey === ""
        && curr.modifier_key === rule[index].modifier_key
        && curr.key === rule[index].key
        && new TextDecoder().decode(curr.output) !== new TextDecoder().decode(rule[index].output)
        && idx < index
      );
      // 1-1: + [CAPS K_N]  > 'N' <-> + [CAPS K_N]  >  'N'
      const dup_1_1 = rule.filter((curr, idx) =>
        (curr.rule_type === "C0" || curr.rule_type === "C1")
        && curr.modifier_prev_deadkey === ""
        && curr.prev_deadkey === ""
        && curr.modifier_deadkey === ""
        && curr.deadkey === ""
        && curr.modifier_key === rule[index].modifier_key
        && curr.key === rule[index].key
        && new TextDecoder().decode(curr.output) === new TextDecoder().decode(rule[index].output)
        && idx < index
      );

      // 4-1: + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  'Ñ'
      const amb_4_1 = rule.filter((curr, idx) =>
        ((curr.rule_type === "C3"))
        && curr.modifier_prev_deadkey === rule[index].modifier_key
        && curr.prev_deadkey === rule[index].key
      );

      // 2-1: + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  'Ñ'
      const amb_2_1 = rule.filter((curr, idx) =>
        ((curr.rule_type === "C2"))
        && curr.modifier_deadkey === rule[index].modifier_key
        && curr.deadkey === rule[index].key
      );

      if (amb_4_1.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("ambiguous rule: later: ["
            + amb_4_1[0].modifier_prev_deadkey
            + " "
            + amb_4_1[0].prev_deadkey
            + "]  >  dk(C"
            + amb_2_1[0].id_deadkey
            + ") ");
      }

      if (amb_2_1.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("ambiguous rule: later: ["
            + amb_2_1[0].modifier_deadkey
            + " "
            + amb_2_1[0].deadkey
            + "]  >  dk(A"
            + amb_2_1[0].id_deadkey
            + ") ");
      }

      if (amb_1_1.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("ambiguous rule: earlier: ["
            + amb_1_1[0].modifier_key
            + " "
            + amb_1_1[0].key
            + "]  >  \'"
            + new TextDecoder().decode(amb_1_1[0].output)
            + "\' ");
      }

      if (dup_1_1.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("duplicate rule: earlier: ["
            + dup_1_1[0].modifier_key
            + " "
            + dup_1_1[0].key
            + "]  >  \'"
            + new TextDecoder().decode(dup_1_1[0].output)
            + "\' ");
      }
    }

    if (rule[index].rule_type === "C2") {

      // 2-2: + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(C3)
      const amb_2_2 = rule.filter((curr, idx) =>
        curr.rule_type === "C2"
        && curr.modifier_deadkey === rule[index].modifier_deadkey
        && curr.deadkey === rule[index].deadkey
        && curr.id_deadkey !== rule[index].id_deadkey
        && idx < index
      );

      // 2-2: + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(C11)
      const dup_2_2 = rule.filter((curr, idx) =>
        curr.rule_type === "C2"
        && curr.modifier_deadkey === rule[index].modifier_deadkey
        && curr.deadkey === rule[index].deadkey
        && curr.id_deadkey === rule[index].id_deadkey
        && idx < index
      );

      //3-3: dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'B'
      const amb_3_3 = rule.filter((curr, idx) =>
        (curr.rule_type === "C2")
        && curr.id_deadkey === rule[index].id_deadkey
        && curr.modifier_key === rule[index].modifier_key
        && curr.key === rule[index].key
        && new TextDecoder().decode(curr.output) !== new TextDecoder().decode(rule[index].output)
        && idx < index
      );

      //3-3: dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'Ã'
      const dup_3_3 = rule.filter((curr, idx) =>
        (curr.rule_type === "C2")
        && curr.id_deadkey === rule[index].id_deadkey
        && rule[index].unique_deadkey === 0
        && curr.modifier_key === rule[index].modifier_key
        && curr.key === rule[index].key
        && new TextDecoder().decode(curr.output) === new TextDecoder().decode(rule[index].output)
        && idx < index
      );

      // 4-2: + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(B11)
      const amb_4_2 = rule.filter((curr, idx) =>
        ((curr.rule_type === "C3"))
        && curr.modifier_prev_deadkey === rule[index].modifier_deadkey
        && curr.prev_deadkey === rule[index].deadkey
        && curr.id_prev_deadkey === rule[index].id_deadkey
      );

      if (amb_2_2.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("ambiguous rule: earlier: ["
            + amb_2_2[0].modifier_deadkey
            + " "
            + amb_2_2[0].deadkey
            + "]  >  dk(C"
            + amb_2_2[0].id_deadkey
            + ") ");
      }

      if (dup_2_2.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("duplicate rule: earlier: ["
            + dup_2_2[0].modifier_deadkey
            + " "
            + dup_2_2[0].deadkey
            + "]  >  dk(C"
            + dup_2_2[0].id_deadkey
            + ") ");
      }

      if (amb_3_3.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("ambiguous rule: earlier: dk(A"
            + amb_3_3[0].id_deadkey
            + ") + ["
            + amb_3_3[0].modifier_key
            + " "
            + amb_3_3[0].key
            + "]  >  \'"
            + new TextDecoder().decode(amb_3_3[0].output)
            + "\' ");
      }

      if (dup_3_3.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("duplicate rule: earlier: dk(A"
            + dup_3_3[0].id_deadkey
            + ") + ["
            + dup_3_3[0].modifier_key
            + " "
            + dup_3_3[0].key
            + "]  >  \'"
            + new TextDecoder().decode(dup_3_3[0].output)
            + "\' ");
      }

      if (amb_4_2.length > 0) {
        warningTextArray[0] = warningTextArray[0]
          + ("ambiguous rule: later: ["
            + amb_4_2[0].modifier_prev_deadkey
            + " "
            + amb_4_2[0].prev_deadkey
            + "]  >  dk(C"
            + amb_4_2[0].id_prev_deadkey
            + ") ");
      }
    }

    if (rule[index].rule_type === "C3") {

      // 2-4 + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(B11)
      const amb_2_4 = rule.filter((curr, idx) =>
        ((curr.rule_type === "C2"))
        && curr.modifier_deadkey === rule[index].modifier_prev_deadkey
        && curr.deadkey === rule[index].prev_deadkey
        && curr.id_deadkey === rule[index].id_prev_deadkey
      );

      // 6-3  dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'B'
      const amb_6_3 = rule.filter((curr, idx) =>
        (curr.rule_type === "C2")
        && curr.id_prev_deadkey === rule[index].id_prev_deadkey
        && curr.modifier_key === rule[index].modifier_key
        && curr.key === rule[index].key
        && (new TextDecoder().decode(curr.output) !== new TextDecoder().decode(rule[index].output))
      );

      // 6-3 dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'Ã'
      const dup_6_3 = rule.filter((curr, idx) =>
        (curr.rule_type === "C2")
        && curr.id_prev_deadkey === rule[index].id_prev_deadkey
        && curr.modifier_key === rule[index].modifier_key
        && curr.key === rule[index].key
        && new TextDecoder().decode(curr.output) === new TextDecoder().decode(rule[index].output)
      );

      // 4-4 + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(C1)
      const amb_4_4 = rule.filter((curr, idx) =>
        curr.rule_type === "C3"
        && curr.modifier_prev_deadkey === rule[index].modifier_prev_deadkey
        && curr.id_prev_deadkey !== rule[index].id_prev_deadkey
        && curr.prev_deadkey === rule[index].prev_deadkey
        && rule[index].unique_prev_deadkey !== 0
        && idx < index
      );

      // 4-4 + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(C11)
      const dup_4_4 = rule.filter((curr, idx) =>
        curr.rule_type === "C3"
        && curr.modifier_prev_deadkey === rule[index].modifier_prev_deadkey
        && curr.prev_deadkey === rule[index].prev_deadkey
        && curr.id_prev_deadkey === rule[index].id_prev_deadkey
        && idx < index
      );

      // 5-5  dk(C1) + [SHIFT CAPS K_A]  >   dk(C2)  <-> dk(C1) + [SHIFT CAPS K_A]  >  dk(C3)
      const amb_5_5 = rule.filter((curr, idx) => (
        (curr.rule_type === "C3")
        && curr.id_prev_deadkey === rule[index].id_prev_deadkey
        && curr.modifier_deadkey === rule[index].modifier_deadkey
        && curr.deadkey === rule[index].deadkey
        && curr.id_deadkey === rule[index].id_deadkey)
        && idx < index
        && (rule[index].unique_deadkey !== 0 || rule[index].unique_prev_deadkey !== 0)
      );

      // 5-5 dk(C1) + [SHIFT CAPS K_A]  >   dk(C2)  <-> dk(C1) + [SHIFT CAPS K_A]  >  dk(C2)
      const dup_5_5 = rule.filter((curr, idx) =>
        (curr.rule_type === "C3")
        && curr.id_prev_deadkey === rule[index].id_prev_deadkey
        && curr.modifier_prev_deadkey === rule[index].modifier_prev_deadkey
        && curr.prev_deadkey === rule[index].prev_deadkey
        && curr.modifier_deadkey === rule[index].modifier_deadkey
        && curr.deadkey === rule[index].deadkey
        && curr.id_deadkey === rule[index].id_deadkey
        && rule[index].unique_deadkey === 0
        && idx < index
      );

      // 6-6 dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'B'
      const amb_6_6 = rule.filter((curr, idx) =>
        (curr.rule_type === "C3")
        && curr.id_prev_deadkey === rule[index].id_prev_deadkey
        && curr.modifier_key === rule[index].modifier_key
        && curr.key === rule[index].key
        && (new TextDecoder().decode(curr.output) !== new TextDecoder().decode(rule[index].output))
        && idx < index
      );

      // 6-6 dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'Ã'
      const dup_6_6 =
        rule.filter((curr, idx) =>
          (curr.rule_type === "C3")
          && curr.id_deadkey === rule[index].id_deadkey
          && curr.modifier_key === rule[index].modifier_key
          && curr.key === rule[index].key
          && (new TextDecoder().decode(curr.output) === new TextDecoder().decode(rule[index].output))
          && idx < index
        );

      if (amb_2_4.length > 0) {
        warningTextArray[0] = warningTextArray[0]
          + ("ambiguous rule: earlier: ["
            + amb_2_4[0].modifier_deadkey
            + " "
            + amb_2_4[0].deadkey
            + "]  >  dk(A"
            + amb_2_4[0].id_deadkey
            + ") ");
      }

      if (amb_6_3.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("ambiguous rule: earlier: dk(C"
            + amb_6_3[0].id_deadkey
            + ") + ["
            + amb_6_3[0].modifier_key
            + " "
            + amb_6_3[0].key
            + "]  >  \'"
            + new TextDecoder().decode(amb_6_3[0].output)
            + "\' ");
      }

      if (dup_6_3.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("duplicate rule: earlier: dk(C"
            + dup_6_3[0].id_deadkey
            + ") + ["
            + dup_6_3[0].modifier_key
            + " "
            + dup_6_3[0].key
            + "]  >  \'"
            + new TextDecoder().decode(dup_6_3[0].output)
            + "\' ");
      }

      if (amb_4_4.length > 0) {
        warningTextArray[0] = warningTextArray[0]
          + ("ambiguous rule: earlier: ["
            + amb_4_4[0].modifier_prev_deadkey
            + " "
            + amb_4_4[0].prev_deadkey
            + "]  >  dk(C"
            + amb_4_4[0].id_prev_deadkey
            + ") ");
      }

      if (dup_4_4.length > 0) {
        warningTextArray[0] = warningTextArray[0]
          + ("duplicate rule: earlier: ["
            + dup_4_4[0].modifier_prev_deadkey
            + " "
            + dup_4_4[0].prev_deadkey
            + "]  >  dk(C"
            + dup_4_4[0].id_prev_deadkey
            + ") ");
      }

      if (amb_5_5.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("ambiguous rule: earlier: dk(B"
            + amb_5_5[0].id_prev_deadkey
            + ") + ["
            + amb_5_5[0].modifier_deadkey
            + " "
            + amb_5_5[0].deadkey
            + "]  >  dk(B"
            + amb_5_5[0].id_deadkey
            + ") ");
      }

      if (dup_5_5.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("duplicate rule: earlier: dk(B"
            + dup_5_5[0].id_prev_deadkey
            + ") + ["
            + dup_5_5[0].modifier_deadkey
            + " "
            + dup_5_5[0].deadkey
            + "]  >  dk(B"
            + dup_5_5[0].id_deadkey
            + ") ");
      }

      if (amb_6_6.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("ambiguous rule: earlier: dk(B"
            + amb_6_6[0].id_deadkey
            + ") + ["
            + amb_6_6[0].modifier_key
            + " "
            + amb_6_6[0].key
            + "]  >  \'"
            + new TextDecoder().decode(amb_6_6[0].output)
            + "\' ");
      }

      if (dup_6_6.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("duplicate rule: earlier: dk(B"
            + dup_6_6[0].id_deadkey
            + ") + ["
            + dup_6_6[0].modifier_key
            + " "
            + dup_6_6[0].key
            + "]  >  \'"
            + new TextDecoder().decode(dup_6_6[0].output)
            + "\' ");
      }
    }
    // In rare cases a rule might not be written out therefore we need to inform the user:
    // usually we write the first occurance of an ambiguous C0/C1 rule and comment out the later
    //    assuming that if several C0/C1 rules are ambiguous the user prefers to use the first C0/C1 rule
    // for C2/C3 rules we write the last occurance of an ambiguous rule and comment out the earlier
    //    assuming that if a C0/C1 and a C2/C3 rule is ambiguous the user prefers to use the C2/C3 rule over the C0/C1 rule
    // if both happens, nothing would be written, therefore this messsage

    const extra_warning = "PLEASE CHECK THE FOLLOWING RULE AS IT WILL NOT BE WRITTEN !  ";

    if (warningTextArray[0] !== "") {
      warningTextArray[0] = "c WARNING: " + warningTextArray[0] + "here: ";

      if ((warningTextArray[0].indexOf("earlier:") > 0) && (warningTextArray[0].indexOf("later:") > 0)) {
        warningTextArray[0] = warningTextArray[0] + extra_warning;
      }
    }
    if (warningTextArray[1] !== "") {
      warningTextArray[1] = "c WARNING: " + warningTextArray[1] + "here: ";

      if ((warningTextArray[1].indexOf("earlier:") > 0) && (warningTextArray[1].indexOf("later:") > 0)) {
        warningTextArray[1] = warningTextArray[1] + extra_warning;
      }
    }

    if (warningTextArray[2] !== "") {
      warningTextArray[2] = "c WARNING: " + warningTextArray[2] + "here: ";

      if ((warningTextArray[2].indexOf("earlier:") > 0) && (warningTextArray[2].indexOf("later:") > 0)) {
        warningTextArray[2] = warningTextArray[2] + extra_warning;
      }
    }
    return warningTextArray;
  }

}
