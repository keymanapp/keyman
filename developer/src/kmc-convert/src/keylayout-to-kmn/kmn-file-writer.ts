/*
 * Keyman is 2025 copyright (C) SIL International. MIT License.
 *
 * Write Keyman .kmn files
 *
 */

import { CompilerCallbacks, CompilerOptions } from "@keymanapp/developer-utils";
import { KeylayoutToKmnConverter, convert_object, rule_object } from './keylayout-to-kmn-converter.js';

export class KmnFileWriter {

  constructor(private callbacks: CompilerCallbacks, private options: CompilerOptions) { };

  /**
   * @brief  member function to write data from object to a kmn file
   * @param  data_ukelele the array holding all keyboard data
   * @param  outputfilename the file that will be written; if no outputfilename is given an outputfilename will be created from data_ukelele.keylayout_filename
   * @return true if data has been written; false if not
   */
  public write(data_ukelele: convert_object): boolean {

    let data: string = "\n";

    // add top part of kmn file: STORES
    data += this.writeData_Stores(data_ukelele);

    // add bottom part of kmn file: RULES
    data += this.writeData_Rules(data_ukelele);

    try {
      this.callbacks.fs.writeFileSync(data_ukelele.kmn_filename, new TextEncoder().encode(data));
      return true;
    } catch (err) {
      console.log('ERROR writing kmn file:' + err.message);
      return false;
    }
  }

  /**
   * @brief  member function to create data for stores that will be printed to the resulting kmn file
   * @param  data_ukelele an object containing all data read from a .keylayout file
   * @return string -  all stores to be printed
   */
  public writeData_Stores(data_ukelele: convert_object): string {

    let data: string = "";
    data += "c ......................................................................\n";
    data += "c ......................................................................\n";
    data += "c Keyman keyboard generated by kmn-convert\n";
    data += "c from Ukelele file: " + data_ukelele.keylayout_filename + "\n";
    data += "c ......................................................................\n";
    data += "c ......................................................................\n";
    data += "\n";

    data += "store(&VERSION) \'10.0\'\n";
    data += "store(&TARGETS) \'any\'\n";
    data += "store(&KEYBOARDVERSION) \'1.0\'\n";
    data += "store(&COPYRIGHT) 'Â© 2024 SIL International\'\n";

    data += "\n";
    data += "begin Unicode > use(main)\n\n";
    data += "group(main) using keys\n\n";

    data += "\n";
    return data;
  }

  /**
   * @brief  member function to create data from rules that will be printed to the resulting kmn file
   * @param  data_ukelele an object containing all data read from a .keylayout file
   * @return string -  all rules to be printed
   */
  public writeData_Rules(data_ukelele: convert_object): string {

    const keylayoutKmnConverter = new KeylayoutToKmnConverter(this.callbacks, this.options);
    let data: string = "";

    // filter array of all rules and remove duplicates
    const unique_data_Rules: rule_object[] = data_ukelele.arrayOf_Rules.filter((curr) => {
      return (!(curr.output === new TextEncoder().encode("") || curr.output === undefined)
        && (curr.key !== "")
        && ((curr.rule_type === "C0")
          || (curr.rule_type === "C1")
          || (curr.rule_type === "C2" && (curr.deadkey !== ""))
          || (curr.rule_type === "C3" && (curr.deadkey !== "") && (curr.prev_deadkey !== "")))
      );
    }).reduce((unique, o) => {
      if (!unique.some((obj: rule_object) =>
        new TextDecoder().decode(obj.output) === new TextDecoder().decode(o.output)

        && obj.output !== new TextEncoder().encode("")

        && obj.rule_type === o.rule_type
        && obj.modifier_key === o.modifier_key
        && obj.key === o.key

        && obj.modifier_deadkey === o.modifier_deadkey
        && obj.deadkey === o.deadkey

        && obj.modifier_prev_deadkey === o.modifier_prev_deadkey
        && obj.prev_deadkey === o.prev_deadkey)
      ) {
        unique.push(o);
      }
      return unique;
    }, []);

    //................................................ C0 C1 ................................................................

    for (let k = 0; k < unique_data_Rules.length; k++) {

      if ((unique_data_Rules[k].rule_type === "C0") || (unique_data_Rules[k].rule_type === "C1")) {

        // lookup key nr of the key which is being processed
        let keyNr: number = 0;
        for (let j = 0; j < KeylayoutToKmnConverter.USED_KEYS_COUNT; j++) {
          if (keylayoutKmnConverter.map_UkeleleKC_To_VK(j) === unique_data_Rules[k].key) {
            keyNr = j;
            break;
          }
        }

        // skip keyNr 48 (K_TAB) and 36 (K_ENTER)
        if ((keyNr === 48) || (keyNr === 36)) {
          continue;
        }

        //---------------------------------------------------------------------------------------------

        // add a line after rules of each key
        if ((k > 1) && (unique_data_Rules[k - 1].key !== unique_data_Rules[k].key) && (unique_data_Rules[k - 1].rule_type === unique_data_Rules[k].rule_type)) {
          data += '\n';
        }

        const warn_text = keylayoutKmnConverter.reviewRules(unique_data_Rules, k);

        const output_character = new TextDecoder().decode(unique_data_Rules[k].output);
        const output_character_unicode = keylayoutKmnConverter.convertToUnicodeCodePoint(output_character);

        // if we are about to print a unicode codepoint instead of a single character we need to check if it is a control character
        if ((output_character_unicode.length > 1)
          && (Number("0x" + output_character_unicode.substring(2, output_character_unicode.length)) < KeylayoutToKmnConverter.MAX_CTRL_CHARACTER)) {
          if (warn_text[2] == "")
            warn_text[2] = warn_text[2] + "c WARNING: use of a control character ";
          else
            warn_text[2] = warn_text[2] + " Use of a control character ";
        }

        // add a warning in front of rules in case unavailable modifiers or ambiguous rules are used
        // if warning contains duplicate rules we do not write out the entire rule
        // (even if there are other warnings for the same rule) since that rule had been written before
        if ((warn_text[2].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[2].length > 0)) {
            warningTextToWrite = warn_text[2];
          }

          if (!((warn_text[2].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite
              + "+ ["
              + (unique_data_Rules[k].modifier_key + ' ' + unique_data_Rules[k].key).trim()
              + `]  > \'`
              + output_character_unicode
              + '\'\n';
          }
        }
      }
    }

    //................................................ C2 ...................................................................
    for (let k = 0; k < unique_data_Rules.length; k++) {

      if (unique_data_Rules[k].rule_type === "C2") {

        const warn_text = keylayoutKmnConverter.reviewRules(unique_data_Rules, k);

        const output_character = new TextDecoder().decode(unique_data_Rules[k].output);
        const output_character_unicode = keylayoutKmnConverter.convertToUnicodeCodePoint(output_character);

        // if we are about to print a unicode codepoint instead of a single character we need to check if it is a control character
        if ((output_character_unicode.length > 1)
          && (Number("0x" + output_character_unicode.substring(2, output_character_unicode.length)) < KeylayoutToKmnConverter.MAX_CTRL_CHARACTER)) {
          if (warn_text[2] == "")
            warn_text[2] = warn_text[2] + "c WARNING: use of a control character ";
          else
            warn_text[2] = warn_text[2] + "; Use of a control character ";
        }

        // add a warning in front of rules in case unavailable modifiers or ambiguous rules are used
        // if warning contains duplicate rules we do not write out the entire rule
        // (even if there are other warnings for the same rule) since that rule had been written before
        if ((warn_text[1].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[1].length > 0)) {
            warningTextToWrite = warn_text[1];
          }

          if (!((warn_text[1].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite
              + "+ [" + (unique_data_Rules[k].modifier_deadkey + " "
                + unique_data_Rules[k].deadkey).trim()
              + "]  >  dk(A" + String(unique_data_Rules[k].id_deadkey)
              + ")\n";
          }
        }

        if ((warn_text[2].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[2].length > 0)) {
            warningTextToWrite = warn_text[2];
          }

          if (!((warn_text[2].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite
              + "dk(A"
              + (String(unique_data_Rules[k].id_deadkey) + ") + ["
                + unique_data_Rules[k].modifier_key).trim()
              + " "
              + unique_data_Rules[k].key + "]  >  \'"
              + output_character_unicode
              + "\'\n";
          }
          data += "\n";
        }
      }
    }

    //................................................ C3 ...................................................................

    for (let k = 0; k < unique_data_Rules.length; k++) {
      if (unique_data_Rules[k].rule_type === "C3") {

        const warn_text = keylayoutKmnConverter.reviewRules(unique_data_Rules, k);

        const output_character = new TextDecoder().decode(unique_data_Rules[k].output);
        const output_character_unicode = keylayoutKmnConverter.convertToUnicodeCodePoint(output_character);

        // if we are about to print a unicode codepoint instead of a single character we need to check if a control character is to be used
        if ((output_character_unicode.length > 1)
          && (Number("0x" + output_character_unicode.substring(2, output_character_unicode.length)) < KeylayoutToKmnConverter.MAX_CTRL_CHARACTER)) {
          if (warn_text[2] == "")
            warn_text[2] = warn_text[2] + "c WARNING: use of a control character ";
          else
            warn_text[2] = warn_text[2] + "; Use of a control character ";
        }

        // add a warning in front of rules in case unavailable modifiers or ambiguous rules are used
        // if warning contains duplicate rules we do not write out the entire rule
        // (even if there are other warnings for the same rule) since that rule had been written before
        if ((warn_text[0].indexOf("duplicate") < 0)) {


          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[0].length > 0)) {
            warningTextToWrite = warn_text[0];
          }

          if (!((warn_text[0].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite
              + "+ ["
              + (unique_data_Rules[k].modifier_prev_deadkey + " "
                + unique_data_Rules[k].prev_deadkey).trim()
              + "]   >   dk(A"
              + String(unique_data_Rules[k].id_prev_deadkey) + ")\n";
          }
        }

        if ((warn_text[1].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[1].length > 0)) {
            warningTextToWrite = warn_text[1];
          }

          if (!((warn_text[1].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite
              + "dk(A" + (String(unique_data_Rules[k].id_prev_deadkey) + ")  + ["
                + unique_data_Rules[k].modifier_deadkey).trim()
              + " "
              + unique_data_Rules[k].deadkey
              + "]  >  dk(B"
              + String(unique_data_Rules[k].id_deadkey)
              + ")\n";
          }
        }

        if ((warn_text[2].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warn_text[2].length > 0)) {
            warningTextToWrite = warn_text[2];
          }

          if (!((warn_text[2].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite + "dk(B"
              + (String(unique_data_Rules[k].id_deadkey)
                + ") + ["
                + unique_data_Rules[k].modifier_key).trim()
              + " "
              + unique_data_Rules[k].key
              + "]  >  \'"
              + output_character_unicode
              + "\'\n";
          }
        }

        if ((warn_text[0].indexOf("duplicate") < 0) || (warn_text[1].indexOf("duplicate") < 0) || (warn_text[2].indexOf("duplicate") < 0)) {
          data += "\n";
        }
      }
    }
    return data;
  }
}
