/*
 * Keyman is copyright (C) SIL Global. MIT License.
 *
 * Created by S. Schmitt on 2025-05-12
 *
 * Write Keyman .kmn files
 *
 */

import { CompilerCallbacks, CompilerOptions } from "@keymanapp/developer-utils";
import { KeylayoutToKmnConverter, ProcessedData, Rule } from './keylayout-to-kmn-converter.js';
import { ConverterMessages } from '../converter-messages.js';
import KEYMAN_VERSION from "@keymanapp/keyman-version";
import { convertUtil } from '@keymanapp/common-types';

export class KmnFileWriter {

  constructor(private callbacks: CompilerCallbacks, private options: CompilerOptions) { };

  /**
   * @brief  member function to write data from object to a Uint8Array
   * @param  dataUkelele the array holding all keyboard data
   * @return a Uint8Array holding data
   */
  public write(dataUkelele: ProcessedData): Uint8Array {
    let data: string = "\n";

    // add top part of kmn file: STORES
    data += this.writeKmnFileHeader(dataUkelele);

    // add bottom part of kmn file: RULES
    const data_rules = this.writeData_Rules(data_ukelele);
    if (data_rules)
      data += data_rules;
    else {
      return null;
    }

    try {
      return new TextEncoder().encode(data);
    } catch (err) {
      this.callbacks.reportMessage(ConverterMessages.Error_UnableToWrite({ outputFilename: dataUkelele.kmnFilename }));
      return null;
    }
  }
  
  /**
   * @brief  member function to create data for the header (stores) that will be printed to the resulting kmn file
   * @param  dataUkelele an object containing all data read from a .keylayout file
   * @return string -  all stores to be printed
   */
  public writeKmnFileHeader(dataUkelele: ProcessedData): string {

    let data: string = "";

    data += "c ..................................................................................................................\n";
    data += "c ..................................................................................................................\n";
    data += "c Keyman keyboard generated by kmn-convert version: " + KEYMAN_VERSION.VERSION + "\n";
    data += "c from Ukelele file: " + dataUkelele.keylayoutFilename + "\n";
    data += "c ..................................................................................................................\n";
    data += "c ..................................................................................................................\n";
    data += "\n";

    data += "store(&TARGETS) \'desktop\'\n";

    data += "\n";
    data += "begin Unicode > use(main)\n\n";
    data += "group(main) using keys\n\n";

    data += "\n";
    return data;
  }

  /**
   * @brief  member function to create data from rules that will be printed to the resulting kmn file
   * @param  dataUkelele an object containing all data read from a .keylayout file
   * @return string -  all rules to be printed
   */
  public writeDataRules(dataUkelele: ProcessedData): string {

    const keylayoutKmnConverter = new KeylayoutToKmnConverter(this.callbacks, this.options);
    let data: string = "";

    // filter array of all rules and remove duplicates
    // during the process of creating Rule[], duplicate rules might occur
    // (e.g. when in a keylayout file the same modifiers occur in several behaviors thus producing the same rules).
    // This is to filter out those duplicate Rule objects
    const uniqueDataRules: Rule[] = dataUkelele.arrayOfRules.filter((curr) => {
      return (!(curr.output === new TextEncoder().encode("") || curr.output === undefined)
        && (curr.key !== "")
        && ((curr.ruleType === "C0")
          || (curr.ruleType === "C1")
          || (curr.ruleType === "C2" && (curr.deadkey !== ""))
          || (curr.ruleType === "C3" && (curr.deadkey !== "") && (curr.prevDeadkey !== "")))
      );
    }).reduce((unique, o) => {
      if (!unique.some((obj: Rule) =>
        new TextDecoder().decode(obj.output) === new TextDecoder().decode(o.output)

        && obj.ruleType === o.ruleType
        && obj.modifierKey === o.modifierKey
        && obj.key === o.key

        && obj.modifierDeadkey === o.modifierDeadkey
        && obj.deadkey === o.deadkey

        && obj.modifierPrevDeadkey === o.modifierPrevDeadkey
        && obj.prevDeadkey === o.prevDeadkey)
      ) {
        unique.push(o);
      }
      return unique;
    }, []);

    //................................................ C0 C1 ................................................................

    for (let k = 0; k < uniqueDataRules.length; k++) {

      if ((uniqueDataRules[k].ruleType === "C0") || (uniqueDataRules[k].ruleType === "C1")) {

        // lookup key nr of the key which is being processed
        let keyNr: number = 0;
        for (let j = 0; j <= KeylayoutToKmnConverter.MAX_KEY_COUNT; j++) {
          if (keylayoutKmnConverter.mapUkeleleKeycodeToVK(j) === uniqueDataRules[k].key) {
            keyNr = j;
            break;
          }
        }

        // skip keyNr 48 (K_TAB) and 36 (K_ENTER)
        if ((keyNr === 48) || (keyNr === 36)) {
          continue;
        }

        //---------------------------------------------------------------------------------------------

        // add a line after rules of each key
        if ((k > 1) && (uniqueDataRules[k - 1].key !== uniqueDataRules[k].key) && (uniqueDataRules[k - 1].ruleType === uniqueDataRules[k].ruleType)) {
          data += '\n';
        }

        // use of Unicode Character vs Unicode Codepoint;
        // If it`s a ctrl character we print out the Unicode Codepoint else we print out the Unicode Character
        let versionOutputCharacter;
        const warnText = this.reviewRules(uniqueDataRules, k);

        const outputCharacter = new TextDecoder().decode(uniqueDataRules[k].output);
        // TODO after merge of PR 14564 use functions from util instead of the ones in this class
        // const outputUnicodeCharacter = util.convertToUnicodeCharacter(outputCharacter);
        // const outputUnicodeCodePoint = util.convertToUnicodeCodePoint(outputCharacter);
        const outputUnicodeCharacter = this.convertToUnicodeCharacter(outputCharacter);
        const outputUnicodeCodePoint = this.convertToUnicodeCodePoint(outputCharacter);

        if ((outputUnicodeCharacter !== undefined) && (outputUnicodeCodePoint !== undefined)) {

          // if we are about to print a unicode codepoint instead of a single character we need to check if it is a control character
          if ((Number("0x" + outputUnicodeCodePoint.substring(2, outputUnicodeCodePoint.length)) < KeylayoutToKmnConverter.MAX_CTRL_CHARACTER)) {

            versionOutputCharacter = outputUnicodeCodePoint;

            if (outputUnicodeCodePoint.length > 1) {
              if (warnText[2] == "") {
                warnText[2] = warnText[2] + "c WARNING: use of a control character " /*+ outputUnicodeCodePoint*/;
              }
              else {
                warnText[2] = warnText[2] + " Use of a control character "/* + outputUnicodeCodePoint*/;
              }
            }
          } else {
            versionOutputCharacter = outputUnicodeCharacter;
          }
        }
        if ((output_Unicode_Character === undefined) || (output_Unicode_CodePoint === undefined)) {
          this.callbacks.reportMessage(ConverterMessages.Error_UnsupportedCharactersDetected({
            inputFilename: data_ukelele.keylayout_filename,
            output: new TextDecoder().decode(unique_data_Rules[k].output),
            keymap_index: data_ukelele.arrayOf_Rules[k].modifier_key,
            KeyName: unique_data_Rules[k].key
          }));
          return null;
        }
        // add a warning in front of rules in case unavailable modifiers or ambiguous rules are used
        // if warning contains duplicate rules we do not write out the entire rule
        // (even if there are other warnings for the same rule) since that rule had been written before
        if ((warnText[2].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warnText[2].length > 0)) {
            warningTextToWrite = warnText[2];
          }

          if (!((warnText[2].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            if (versionOutputCharacter === "'") {
              data += warningTextToWrite
                + "+ ["
                + (uniqueDataRules[k].modifierKey + ' ' + uniqueDataRules[k].key).trim()
                + `]  >  \"`
                + versionOutputCharacter
                + '\"\n';
            }
            else {
              data += warningTextToWrite
                + "+ ["
                + (uniqueDataRules[k].modifierKey + ' ' + uniqueDataRules[k].key).trim()
                + `]  >  \'`
                + versionOutputCharacter
                + '\'\n';
            }
          }
        }
      }
    }

    //................................................ C2 ...................................................................
    for (let k = 0; k < uniqueDataRules.length; k++) {

      if (uniqueDataRules[k].ruleType === "C2") {

        // use of Unicode Character vs Unicode Codepoint;
        // If it`s a ctrl character we print out the Unicode Codepoint else we print out the Unicode Character
        let versionOutputCharacter;
        const warnText = this.reviewRules(uniqueDataRules, k);

        const outputCharacter = new TextDecoder().decode(uniqueDataRules[k].output);
        // TODO after merge of PR 14564 use functions from util instead of the ones in this class
        // const outputUnicodeCharacter = util.convertToUnicodeCharacter(outputCharacter);
        // const outputUnicodeCodePoint = util.convertToUnicodeCodePoint(outputCharacter);
        const outputUnicodeCharacter = this.convertToUnicodeCharacter(outputCharacter);
        const outputUnicodeCodePoint = this.convertToUnicodeCodePoint(outputCharacter);

        if ((outputUnicodeCharacter !== undefined) && (outputUnicodeCodePoint !== undefined)) {
          // if we are about to print a unicode codepoint instead of a single character we need to check if it is a control character
          if (Number("0x" + outputUnicodeCodePoint.substring(2, outputUnicodeCodePoint.length)) < KeylayoutToKmnConverter.MAX_CTRL_CHARACTER) {
            versionOutputCharacter = outputUnicodeCodePoint;
            if (outputUnicodeCodePoint.length > 1) {
              if (warnText[2] == "") {
                warnText[2] = warnText[2] + "c WARNING: use of a control character ";
              }
              else {
                warnText[2] = warnText[2] + "; Use of a control character ";
              }
            }
          } else {
            versionOutputCharacter = outputUnicodeCharacter;
          }
        }
        if ((output_Unicode_Character === undefined) || (output_Unicode_CodePoint === undefined)) {
          this.callbacks.reportMessage(ConverterMessages.Error_UnsupportedCharactersDetected({
            inputFilename: data_ukelele.keylayout_filename,
            output: new TextDecoder().decode(unique_data_Rules[k].output),
            keymap_index: unique_data_Rules[k].modifier_key,
            KeyName: unique_data_Rules[k].key
          }));
          return null;
        }
        // add a warning in front of rules in case unavailable modifiers or ambiguous rules are used
        // if warning contains duplicate rules we do not write out the entire rule
        // (even if there are other warnings for the same rule) since that rule had been written before
        if ((warnText[1].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warnText[1].length > 0)) {
            warningTextToWrite = warnText[1];
          }

          if (!((warnText[1].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite
              + "+ [" + (uniqueDataRules[k].modifierDeadkey + " "
                + uniqueDataRules[k].deadkey).trim()
              + "]  >  dk(A" + String(uniqueDataRules[k].idDeadkey)
              + ")\n";
          }
        }

        if ((warnText[2].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warnText[2].length > 0)) {
            warningTextToWrite = warnText[2];
          }

          if (!((warnText[2].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            if (versionOutputCharacter === "'") {
              data += warningTextToWrite
                + "dk(A"
                + (String(uniqueDataRules[k].idDeadkey) + ") + ["
                  + uniqueDataRules[k].modifierKey).trim()
                + " "
                + uniqueDataRules[k].key + ']  >  \"'
                + versionOutputCharacter
                + '\"\n';
            }
            else {
              data += warningTextToWrite
                + "dk(A"
                + (String(uniqueDataRules[k].idDeadkey) + ") + ["
                  + uniqueDataRules[k].modifierKey).trim()
                + " "
                + uniqueDataRules[k].key + "]  >  \'"
                + versionOutputCharacter
                + "\'\n";
            }


          }
          data += "\n";
        }
      }
    }

    //................................................ C3 ...................................................................

    for (let k = 0; k < uniqueDataRules.length; k++) {
      if (uniqueDataRules[k].ruleType === "C3") {

        // use of Unicode Character vs Unicode Codepoint;
        // If it`s a ctrl character we print out the Unicode Codepoint else we print out the Unicode Character
        let versionOutputCharacter;

        const warnText = this.reviewRules(uniqueDataRules, k);
        const outputCharacter = new TextDecoder().decode(uniqueDataRules[k].output);
        // TODO after merge of PR 14564 use functions from util instead of the ones in this class
        //const outputUnicodeCharacter = util.convertToUnicodeCharacter(outputCharacter);
        //const outputUnicodeCodePoint = util.convertToUnicodeCodePoint(outputCharacter);
        const outputUnicodeCharacter = this.convertToUnicodeCharacter(outputCharacter);
        const outputUnicodeCodePoint = this.convertToUnicodeCodePoint(outputCharacter);

        if ((outputUnicodeCharacter !== undefined) && (outputUnicodeCodePoint !== undefined)) {
          // if we are about to print a unicode codepoint instead of a single character we need to check if a control character is to be used
          if (Number("0x" + outputUnicodeCodePoint.substring(2, outputUnicodeCodePoint.length)) < KeylayoutToKmnConverter.MAX_CTRL_CHARACTER) {

            versionOutputCharacter = outputUnicodeCodePoint;

            if (outputUnicodeCodePoint.length > 1) {
              if (warnText[2] == "") {
                warnText[2] = warnText[2] + "c WARNING: use of a control character ";
              }
              else {
                warnText[2] = warnText[2] + "; Use of a control character ";
              }
            }
          } else {
            versionOutputCharacter = outputUnicodeCharacter;
          }
        }
        if ((output_Unicode_Character === undefined) || (output_Unicode_CodePoint === undefined)) {
          this.callbacks.reportMessage(ConverterMessages.Error_UnsupportedCharactersDetected({
            inputFilename: data_ukelele.keylayout_filename,
            output: new TextDecoder().decode(unique_data_Rules[k].output),
            keymap_index: unique_data_Rules[k].modifier_key,
            KeyName: unique_data_Rules[k].key
          }));
          return null;
        }
        // add a warning in front of rules in case unavailable modifiers or ambiguous rules are used
        // if warning contains duplicate rules we do not write out the entire rule
        // (even if there are other warnings for the same rule) since that rule had been written before
        if ((warnText[0].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";

          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warnText[0].length > 0)) {
            warningTextToWrite = warnText[0];
          }

          if (!((warnText[0].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite
              + "+ ["
              + (uniqueDataRules[k].modifierPrevDeadkey + " "
                + uniqueDataRules[k].prevDeadkey).trim()
              + "]   >   dk(A"
              + String(uniqueDataRules[k].idPrevDeadkey) + ")\n";
          }
        }

        if ((warnText[1].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warnText[1].length > 0)) {
            warningTextToWrite = warnText[1];
          }

          if (!((warnText[1].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite
              + "dk(A" + (String(uniqueDataRules[k].idPrevDeadkey) + ")  + ["
                + uniqueDataRules[k].modifierDeadkey).trim()
              + " "
              + uniqueDataRules[k].deadkey
              + "]  >  dk(B"
              + String(uniqueDataRules[k].idDeadkey)
              + ")\n";
          }
        }

        if ((warnText[2].indexOf("duplicate") < 0)) {

          let warningTextToWrite = "";
          if (!KeylayoutToKmnConverter.SKIP_COMMENTED_LINES && (warnText[2].length > 0)) {
            warningTextToWrite = warnText[2];
          }

          if (!((warnText[2].length > 0) && KeylayoutToKmnConverter.SKIP_COMMENTED_LINES)) {
            data += warningTextToWrite + "dk(B"
              + (String(uniqueDataRules[k].idDeadkey)
                + ") + ["
                + uniqueDataRules[k].modifierKey).trim()
              + " "
              + uniqueDataRules[k].key
              + "]  >  \'"
              + versionOutputCharacter
              + "\'\n";
          }
        }

        if ((warnText[0].indexOf("duplicate") < 0) || (warnText[1].indexOf("duplicate") < 0) || (warnText[2].indexOf("duplicate") < 0)) {
          data += "\n";
        }
      }
    }
    return data;
  }

  /**
   * @brief  member function to review rules for acceptable modifiers, duplicate or ambiguous rules and return an array containing possible warnings.
   *         Keyman can not handle duplicate rules so we need to make sure a rule is written only once by either omitting a duplicate rule or commenting out an ambiguous rule.
   *         Omitting rules and definition of comparisons e.g. 1-1, 2-4, 6-6
   *         see https://docs.google.com/document/d/12J3NGO6RxIthCpZDTR8FYSRjiMgXJDLwPY2z9xqKzJ0/edit?tab=t.0#heading=h.pcz8rjyrl5ug
   * @param  rule : Rule[] - an array of all rules
   * @param  index the index of a rule in Rule[]
   * @return a string[] containing possible warnings for a rule
   */
  public reviewRules(rule: Rule[], index: number): string[] {

    const keylayoutKmnConverter = new KeylayoutToKmnConverter(this.callbacks, this.options);
    const warningTextArray: string[] = Array(3).fill("");

    // ------------------------- check unavailable modifiers -------------------------

    if ((rule[index].ruleType === "C0") || (rule[index].ruleType === "C1")) {
      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifierKey)) {
        warningTextArray[2] = "unavailable modifier : ";
      }
    }

    else if (rule[index].ruleType === "C2") {
      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifierDeadkey)) {
        warningTextArray[1] = "unavailable modifier : ";
        warningTextArray[2] = "unavailable superior rule ( ["
          + rule[index].modifierDeadkey + " "
          + rule[index].deadkey
          + "]  >  dk(A"
          + rule[index].idDeadkey
          + ") ) : ";
      }
      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifierKey)) {
        warningTextArray[2] = "unavailable modifier : ";
      }
    }

    else if (rule[index].ruleType === "C3") {

      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifierPrevDeadkey)) {
        warningTextArray[0] = "unavailable modifier : ";
        warningTextArray[1] = "unavailable superior rule ( ["
          + rule[index].modifierPrevDeadkey + " "
          + rule[index].prevDeadkey
          + "]  >  dk(A"
          + rule[index].idPrevDeadkey
          + ") ) : ";
      }

      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifierDeadkey)) {
        warningTextArray[1] = "unavailable modifier : ";
        warningTextArray[2] = "unavailable superior rule ( ["
          + rule[index].modifierDeadkey + " "
          + rule[index].deadkey
          + "]  >  dk(B"
          + rule[index].idDeadkey
          + ") ) : ";
      }

      if (!keylayoutKmnConverter.isAcceptableKeymanModifier(rule[index].modifierKey)) {
        warningTextArray[2] = "unavailable modifier : ";
      }
    }

    // ------------------------- check ambiguous/duplicate rules -------------------------

    if ((rule[index].ruleType === "C0") || (rule[index].ruleType === "C1")) {

      // 1-1: + [CAPS K_N]  > 'N' <-> + [CAPS K_N]  >  'A'
      const amb_1_1 = rule.filter((curr, idx) =>
        (curr.ruleType === "C0" || curr.ruleType === "C1")
        && curr.modifierPrevDeadkey === ""
        && curr.prevDeadkey === ""
        && curr.modifierDeadkey === ""
        && curr.deadkey === ""
        && curr.modifierKey === rule[index].modifierKey
        && curr.key === rule[index].key
        && new TextDecoder().decode(curr.output) !== new TextDecoder().decode(rule[index].output)
        && idx < index
      );
      // 1-1: + [CAPS K_N]  > 'N' <-> + [CAPS K_N]  >  'N'
      const dup_1_1 = rule.filter((curr, idx) =>
        (curr.ruleType === "C0" || curr.ruleType === "C1")
        && curr.modifierPrevDeadkey === ""
        && curr.prevDeadkey === ""
        && curr.modifierDeadkey === ""
        && curr.deadkey === ""
        && curr.modifierKey === rule[index].modifierKey
        && curr.key === rule[index].key
        && new TextDecoder().decode(curr.output) === new TextDecoder().decode(rule[index].output)
        && idx < index
      );

      // 4-1: + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  'Ñ'
      const amb_4_1 = rule.filter((curr, idx) =>
        ((curr.ruleType === "C3"))
        && curr.modifierPrevDeadkey === rule[index].modifierKey
        && curr.prevDeadkey === rule[index].key
      );

      // 2-1: + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  'Ñ'
      const amb_2_1 = rule.filter((curr, idx) =>
        ((curr.ruleType === "C2"))
        && curr.modifierDeadkey === rule[index].modifierKey
        && curr.deadkey === rule[index].key
      );

      if (amb_4_1.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("ambiguous rule: later: ["
            + amb_4_1[0].modifierPrevDeadkey
            + " "
            + amb_4_1[0].prevDeadkey
            + "]  >  dk(C"
            + amb_2_1[0].idDeadkey
            + ") ");
      }

      if (amb_2_1.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("ambiguous rule: later: ["
            + amb_2_1[0].modifierDeadkey
            + " "
            + amb_2_1[0].deadkey
            + "]  >  dk(A"
            + amb_2_1[0].idDeadkey
            + ") ");
      }

      if (amb_1_1.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("ambiguous rule: earlier: ["
            + amb_1_1[0].modifierKey
            + " "
            + amb_1_1[0].key
            + "]  >  \'"
            + new TextDecoder().decode(amb_1_1[0].output)
            + "\' ");
      }

      if (dup_1_1.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("duplicate rule: earlier: ["
            + dup_1_1[0].modifierKey
            + " "
            + dup_1_1[0].key
            + "]  >  \'"
            + new TextDecoder().decode(dup_1_1[0].output)
            + "\' ");
      }
    }

    if (rule[index].ruleType === "C2") {

      // 2-2: + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(C3)
      const amb_2_2 = rule.filter((curr, idx) =>
        curr.ruleType === "C2"
        && curr.modifierDeadkey === rule[index].modifierDeadkey
        && curr.deadkey === rule[index].deadkey
        && curr.idDeadkey !== rule[index].idDeadkey
        && idx < index
      );

      // 2-2: + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(C11)
      const dup_2_2 = rule.filter((curr, idx) =>
        curr.ruleType === "C2"
        && curr.modifierDeadkey === rule[index].modifierDeadkey
        && curr.deadkey === rule[index].deadkey
        && curr.idDeadkey === rule[index].idDeadkey
        && idx < index
      );

      //3-3: dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'B'
      const amb_3_3 = rule.filter((curr, idx) =>
        (curr.ruleType === "C2")
        && curr.idDeadkey === rule[index].idDeadkey
        && curr.modifierKey === rule[index].modifierKey
        && curr.key === rule[index].key
        && new TextDecoder().decode(curr.output) !== new TextDecoder().decode(rule[index].output)
        && idx < index
      );

      //3-3: dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'Ã'
      const dup_3_3 = rule.filter((curr, idx) =>
        (curr.ruleType === "C2")
        && curr.idDeadkey === rule[index].idDeadkey
        && rule[index].uniqueDeadkey === 0
        && curr.modifierKey === rule[index].modifierKey
        && curr.key === rule[index].key
        && new TextDecoder().decode(curr.output) === new TextDecoder().decode(rule[index].output)
        && idx < index
      );

      // 4-2: + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(B11)
      const amb_4_2 = rule.filter((curr, idx) =>
        ((curr.ruleType === "C3"))
        && curr.modifierPrevDeadkey === rule[index].modifierDeadkey
        && curr.prevDeadkey === rule[index].deadkey
        && curr.idPrevDeadkey === rule[index].idDeadkey
      );

      if (amb_2_2.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("ambiguous rule: earlier: ["
            + amb_2_2[0].modifierDeadkey
            + " "
            + amb_2_2[0].deadkey
            + "]  >  dk(C"
            + amb_2_2[0].idDeadkey
            + ") ");
      }

      if (dup_2_2.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("duplicate rule: earlier: ["
            + dup_2_2[0].modifierDeadkey
            + " "
            + dup_2_2[0].deadkey
            + "]  >  dk(C"
            + dup_2_2[0].idDeadkey
            + ") ");
      }

      if (amb_3_3.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("ambiguous rule: earlier: dk(A"
            + amb_3_3[0].idDeadkey
            + ") + ["
            + amb_3_3[0].modifierKey
            + " "
            + amb_3_3[0].key
            + "]  >  \'"
            + new TextDecoder().decode(amb_3_3[0].output)
            + "\' ");
      }

      if (dup_3_3.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("duplicate rule: earlier: dk(A"
            + dup_3_3[0].idDeadkey
            + ") + ["
            + dup_3_3[0].modifierKey
            + " "
            + dup_3_3[0].key
            + "]  >  \'"
            + new TextDecoder().decode(dup_3_3[0].output)
            + "\' ");
      }

      if (amb_4_2.length > 0) {
        warningTextArray[0] = warningTextArray[0]
          + ("ambiguous rule: later: ["
            + amb_4_2[0].modifierPrevDeadkey
            + " "
            + amb_4_2[0].prevDeadkey
            + "]  >  dk(C"
            + amb_4_2[0].idPrevDeadkey
            + ") ");
      }
    }

    if (rule[index].ruleType === "C3") {

      // 2-4 + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(B11)
      const amb_2_4 = rule.filter((curr, idx) =>
        ((curr.ruleType === "C2"))
        && curr.modifierDeadkey === rule[index].modifierPrevDeadkey
        && curr.deadkey === rule[index].prevDeadkey
        && curr.idDeadkey === rule[index].idPrevDeadkey
      );

      // 6-3  dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'B'
      const amb_6_3 = rule.filter((curr, idx) =>
        (curr.ruleType === "C2")
        && curr.idPrevDeadkey === rule[index].idPrevDeadkey
        && curr.modifierKey === rule[index].modifierKey
        && curr.key === rule[index].key
        && (new TextDecoder().decode(curr.output) !== new TextDecoder().decode(rule[index].output))
      );

      // 6-3 dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'Ã'
      const dup_6_3 = rule.filter((curr, idx) =>
        (curr.ruleType === "C2")
        && curr.idPrevDeadkey === rule[index].idPrevDeadkey
        && curr.modifierKey === rule[index].modifierKey
        && curr.key === rule[index].key
        && new TextDecoder().decode(curr.output) === new TextDecoder().decode(rule[index].output)
      );

      // 4-4 + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(C1)
      const amb_4_4 = rule.filter((curr, idx) =>
        curr.ruleType === "C3"
        && curr.modifierPrevDeadkey === rule[index].modifierPrevDeadkey
        && curr.idPrevDeadkey !== rule[index].idPrevDeadkey
        && curr.prevDeadkey === rule[index].prevDeadkey
        && rule[index].uniquPrevDeadkey !== 0
        && idx < index
      );

      // 4-4 + [CAPS K_N]  >  dk(C11) <-> + [CAPS K_N]  >  dk(C11)
      const dup_4_4 = rule.filter((curr, idx) =>
        curr.ruleType === "C3"
        && curr.modifierPrevDeadkey === rule[index].modifierPrevDeadkey
        && curr.prevDeadkey === rule[index].prevDeadkey
        && curr.idPrevDeadkey === rule[index].idPrevDeadkey
        && idx < index
      );

      // 5-5  dk(C1) + [SHIFT CAPS K_A]  >   dk(C2)  <-> dk(C1) + [SHIFT CAPS K_A]  >  dk(C3)
      const amb_5_5 = rule.filter((curr, idx) => (
        (curr.ruleType === "C3")
        && curr.idPrevDeadkey === rule[index].idPrevDeadkey
        && curr.modifierDeadkey === rule[index].modifierDeadkey
        && curr.deadkey === rule[index].deadkey
        && curr.idDeadkey === rule[index].idDeadkey)
        && idx < index
        && (rule[index].uniqueDeadkey !== 0 || rule[index].uniquPrevDeadkey !== 0)
      );

      // 5-5 dk(C1) + [SHIFT CAPS K_A]  >   dk(C2)  <-> dk(C1) + [SHIFT CAPS K_A]  >  dk(C2)
      const dup_5_5 = rule.filter((curr, idx) =>
        (curr.ruleType === "C3")
        && curr.idPrevDeadkey === rule[index].idPrevDeadkey
        && curr.modifierPrevDeadkey === rule[index].modifierPrevDeadkey
        && curr.prevDeadkey === rule[index].prevDeadkey
        && curr.modifierDeadkey === rule[index].modifierDeadkey
        && curr.deadkey === rule[index].deadkey
        && curr.idDeadkey === rule[index].idDeadkey
        && rule[index].uniqueDeadkey === 0
        && idx < index
      );

      // 6-6 dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'B'
      const amb_6_6 = rule.filter((curr, idx) =>
        (curr.ruleType === "C3")
        && curr.idPrevDeadkey === rule[index].idPrevDeadkey
        && curr.modifierKey === rule[index].modifierKey
        && curr.key === rule[index].key
        && (new TextDecoder().decode(curr.output) !== new TextDecoder().decode(rule[index].output))
        && idx < index
      );

      // 6-6 dk(C11) + [SHIFT CAPS K_A]  >  'Ã'  <-> dk(C11) + [SHIFT CAPS K_A]  >  'Ã'
      const dup_6_6 =
        rule.filter((curr, idx) =>
          (curr.ruleType === "C3")
          && curr.idDeadkey === rule[index].idDeadkey
          && curr.modifierKey === rule[index].modifierKey
          && curr.key === rule[index].key
          && (new TextDecoder().decode(curr.output) === new TextDecoder().decode(rule[index].output))
          && idx < index
        );

      if (amb_2_4.length > 0) {
        warningTextArray[0] = warningTextArray[0]
          + ("ambiguous rule: earlier: ["
            + amb_2_4[0].modifierDeadkey
            + " "
            + amb_2_4[0].deadkey
            + "]  >  dk(A"
            + amb_2_4[0].idDeadkey
            + ") ");
      }

      if (amb_6_3.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("ambiguous rule: earlier: dk(C"
            + amb_6_3[0].idDeadkey
            + ") + ["
            + amb_6_3[0].modifierKey
            + " "
            + amb_6_3[0].key
            + "]  >  \'"
            + new TextDecoder().decode(amb_6_3[0].output)
            + "\' ");
      }

      if (dup_6_3.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("duplicate rule: earlier: dk(C"
            + dup_6_3[0].idDeadkey
            + ") + ["
            + dup_6_3[0].modifierKey
            + " "
            + dup_6_3[0].key
            + "]  >  \'"
            + new TextDecoder().decode(dup_6_3[0].output)
            + "\' ");
      }

      if (amb_4_4.length > 0) {
        warningTextArray[0] = warningTextArray[0]
          + ("ambiguous rule: earlier: ["
            + amb_4_4[0].modifierPrevDeadkey
            + " "
            + amb_4_4[0].prevDeadkey
            + "]  >  dk(C"
            + amb_4_4[0].idPrevDeadkey
            + ") ");
      }

      if (dup_4_4.length > 0) {
        warningTextArray[0] = warningTextArray[0]
          + ("duplicate rule: earlier: ["
            + dup_4_4[0].modifierPrevDeadkey
            + " "
            + dup_4_4[0].prevDeadkey
            + "]  >  dk(C"
            + dup_4_4[0].idPrevDeadkey
            + ") ");
      }

      if (amb_5_5.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("ambiguous rule: earlier: dk(B"
            + amb_5_5[0].idPrevDeadkey
            + ") + ["
            + amb_5_5[0].modifierDeadkey
            + " "
            + amb_5_5[0].deadkey
            + "]  >  dk(B"
            + amb_5_5[0].idDeadkey
            + ") ");
      }

      if (dup_5_5.length > 0) {
        warningTextArray[1] = warningTextArray[1]
          + ("duplicate rule: earlier: dk(B"
            + dup_5_5[0].idPrevDeadkey
            + ") + ["
            + dup_5_5[0].modifierDeadkey
            + " "
            + dup_5_5[0].deadkey
            + "]  >  dk(B"
            + dup_5_5[0].idDeadkey
            + ") ");
      }

      if (amb_6_6.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("ambiguous rule: earlier: dk(B"
            + amb_6_6[0].idDeadkey
            + ") + ["
            + amb_6_6[0].modifierKey
            + " "
            + amb_6_6[0].key
            + "]  >  \'"
            + new TextDecoder().decode(amb_6_6[0].output)
            + "\' ");
      }

      if (dup_6_6.length > 0) {
        warningTextArray[2] = warningTextArray[2]
          + ("duplicate rule: earlier: dk(B"
            + dup_6_6[0].idDeadkey
            + ") + ["
            + dup_6_6[0].modifierKey
            + " "
            + dup_6_6[0].key
            + "]  >  \'"
            + new TextDecoder().decode(dup_6_6[0].output)
            + "\' ");
      }
    }
    // In rare cases a rule might not be written out therefore we need to inform the user:
    // usually we write the first occurance of an ambiguous C0/C1 rule and comment out the later
    //    assuming that if several C0/C1 rules are ambiguous the user prefers to use the first C0/C1 rule
    // for C2/C3 rules we write the last occurance of an ambiguous rule and comment out the earlier
    //    assuming that if a C0/C1 and a C2/C3 rule is ambiguous the user prefers to use the C2/C3 rule over the C0/C1 rule
    // if both happens, nothing would be written, therefore this messsage

    const extraWarning = "PLEASE CHECK THE FOLLOWING RULE AS IT WILL NOT BE WRITTEN !  ";

    if (warningTextArray[0] !== "") {
      warningTextArray[0] = "c WARNING: " + warningTextArray[0] + "here: ";

      if ((warningTextArray[0].indexOf("earlier:") > 0) && (warningTextArray[0].indexOf("later:") > 0)) {
        warningTextArray[0] = warningTextArray[0] + extraWarning;
      }
    }
    if (warningTextArray[1] !== "") {
      warningTextArray[1] = "c WARNING: " + warningTextArray[1] + "here: ";

      if ((warningTextArray[1].indexOf("earlier:") > 0) && (warningTextArray[1].indexOf("later:") > 0)) {
        warningTextArray[1] = warningTextArray[1] + extraWarning;
      }
    }

    if (warningTextArray[2] !== "") {
      warningTextArray[2] = "c WARNING: " + warningTextArray[2] + "here: ";

      if ((warningTextArray[2].indexOf("earlier:") > 0) && (warningTextArray[2].indexOf("later:") > 0)) {
        warningTextArray[2] = warningTextArray[2] + extraWarning;
      }
    }
    return warningTextArray;
  }

}
