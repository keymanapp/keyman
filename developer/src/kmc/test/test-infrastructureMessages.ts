import 'mocha';
import { assert } from 'chai';
import { InfrastructureMessages } from '../src/messages/infrastructureMessages.js';
import { verifyCompilerMessagesObject } from '@keymanapp/developer-test-helpers';
import { makePathToFixture } from './helpers/index.js';
import { NodeCompilerCallbacks } from '../src/util/NodeCompilerCallbacks.js';
import { CompilerErrorNamespace, CompilerEvent } from '@keymanapp/common-types';
import { unitTestEndpoints } from '../src/commands/build.js';
import { KmnCompilerMessages } from '@keymanapp/kmc-kmn';

describe('InfrastructureMessages', function () {
  it('should have a valid InfrastructureMessages object', function() {
    return verifyCompilerMessagesObject(InfrastructureMessages, CompilerErrorNamespace.Infrastructure);
  });

  //
  // Message tests
  //

  // FATAL_UnexpectedException

  it('should generate FATAL_UnexpectedException if an exception is raised', async function() {
    const ncb = new NodeCompilerCallbacks({logLevel: 'silent'});
    const expectedMessages = [InfrastructureMessages.FATAL_UnexpectedException];

    process.env.SENTRY_CLIENT_TEST_BUILD_EXCEPTION = '1';
    await unitTestEndpoints.build(null, null, ncb, {});
    delete process.env.SENTRY_CLIENT_TEST_BUILD_EXCEPTION;

    assertMessagesEqual(ncb.messages, expectedMessages);
    assert.instanceOf<Error>(ncb.messages[0].exceptionVar, Error);
    });

/*
  // ERROR_FileDoesNotExist

  it('should generate ERROR_FileDoesNotExist if a file does not exist', async function() {
    await testForMessage(this, ['invalid-keyboards', 'error_file_does_not_exist.kmn'], CompilerMessages.ERROR_FileDoesNotExist);
  });

  // ERROR_FileTypeNotRecognized

  it('should generate ERROR_FileTypeNotRecognized if a file is not a recognized type', async function() {
    await testForMessage(this, ['invalid-keyboards', 'error_file_type_not_recognized.xxx'], CompilerMessages.ERROR_FileTypeNotRecognized);
  });

  // ERROR_OutFileNotValidForProjects

  it('should generate ERROR_OutFileNotValidForProjects if an output file is specified for a project build', async function() {
    await testForMessage(this, ['invalid-keyboards', 'error_out_file_not_valid_for_projects.kpj'], CompilerMessages.ERROR_OutFileNotValidForProjects);
  });

  // ERROR_InvalidProjectFile

  it('should generate ERROR_InvalidProjectFile if a project file is invalid', async function() {
    await testForMessage(this, ['invalid-keyboards', 'error_invalid_project_file.kpj'], CompilerMessages.ERROR_InvalidProjectFile);
  });
  */

  // HINT_FilenameHasDifferingCase

  it('should generate HINT_FilenameHasDifferingCase if a referenced file has differing case', async function() {
    // This message is generated by NodeCompilerCallbacks, because that's where the filesystem is visible,
    // so we can't use our usual testForMessage pattern.
    const ncb = new NodeCompilerCallbacks({logLevel: 'silent'});
    const expectedMessages = [InfrastructureMessages.HINT_FilenameHasDifferingCase];
    ncb.loadFile(makePathToFixture('invalid-keyboards', 'Hint_Filename_Has_Differing_Case.kmn'));
    assertMessagesEqual(ncb.messages, expectedMessages);
  });

  // INFO_WarningsHaveFailedBuild

  it('should generate INFO_WarningsHaveFailedBuild if only warnings failed the build', async function() {
    const ncb = new NodeCompilerCallbacks({logLevel: 'silent'});
    const filename = makePathToFixture('compiler-warnings-as-errors', 'keyboard.kmn');
    const expectedMessages = [
      InfrastructureMessages.INFO_BuildingFile,
      KmnCompilerMessages.WARN_HeaderStatementIsDeprecated,
      InfrastructureMessages.INFO_WarningsHaveFailedBuild,
      InfrastructureMessages.INFO_FileNotBuiltSuccessfully
    ];
    await unitTestEndpoints.build(filename, null, ncb, {compilerWarningsAsErrors: true});
    assertMessagesEqual(ncb.messages, expectedMessages);
  });

  // ERROR_UnsupportedProjectVersion

  it('should generate ERROR_UnsupportedProjectVersion if a project file with an unsupported version is loaded', async function() {
    const ncb = new NodeCompilerCallbacks({logLevel: 'silent'});
    const filename = makePathToFixture('invalid-projects', 'error_unsupported_project_version.kpj');
    const expectedMessages = [
      InfrastructureMessages.INFO_BuildingFile,
      InfrastructureMessages.ERROR_UnsupportedProjectVersion,
      InfrastructureMessages.INFO_ProjectNotBuiltSuccessfully
    ];
    await unitTestEndpoints.build(filename, null, ncb, {compilerWarningsAsErrors: true});
    assertMessagesEqual(ncb.messages, expectedMessages);
  });
});

function assertMessagesEqual(actualMessages: CompilerEvent[], expectedMessages: number[]) {
  assert.deepEqual(actualMessages.map(m => m.code), expectedMessages,
    `actual callbacks.messages:\n${JSON.stringify(actualMessages,null,2)}\n\n`+
    `did not match expected:\n${JSON.stringify(expectedMessages,null,2)}\n\n`);
}