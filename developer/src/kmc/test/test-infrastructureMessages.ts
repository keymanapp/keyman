import 'mocha';
import { assert } from 'chai';
import { InfrastructureMessages } from '../src/messages/infrastructureMessages.js';
import { verifyCompilerMessagesObject } from '@keymanapp/developer-test-helpers';
import { makePathToFixture } from './helpers/index.js';
import { NodeCompilerCallbacks } from '../src/util/NodeCompilerCallbacks.js';
import { CompilerErrorNamespace } from '@keymanapp/common-types';
import { unitTestEndpoints } from '../src/commands/build.js';
import { KmnCompilerMessages } from '@keymanapp/kmc-kmn';
import { defaultCompilerOptions, CompilerOptions} from '@keymanapp/common-types';

describe('InfrastructureMessages', function () {
  it('should have a valid InfrastructureMessages object', function() {
    return verifyCompilerMessagesObject(InfrastructureMessages, CompilerErrorNamespace.Infrastructure);
  });

  //
  // Message tests
  //

  // FATAL_UnexpectedException

  it('should generate FATAL_UnexpectedException if an exception is raised', async function() {
    const ncb = new NodeCompilerCallbacks({logLevel: 'silent'});
    process.env.SENTRY_CLIENT_TEST_BUILD_EXCEPTION = '1';
    await unitTestEndpoints.build(null, ncb, {});
    delete process.env.SENTRY_CLIENT_TEST_BUILD_EXCEPTION;
    assert.isTrue(ncb.hasMessage(InfrastructureMessages.FATAL_UnexpectedException),
      `FATAL_UnexpectedException not generated, instead got: `+JSON.stringify(ncb.messages,null,2));
    assert.lengthOf(ncb.messages, 1);
    assert.instanceOf<Error>(ncb.messages[0].exceptionVar, Error);
    });

  // ERROR_FileDoesNotExist

  it('should generate ERROR_FileDoesNotExist if a file does not exist', async function() {
    const ncb = new NodeCompilerCallbacks({logLevel: 'silent'});
    await unitTestEndpoints.build(makePathToFixture('invalid-keyboards', 'Error_File_Does_Not_Exist.kmn'), ncb, {});
    assert.isTrue(ncb.hasMessage(InfrastructureMessages.ERROR_FileDoesNotExist),
      `ERROR_FileDoesNotExist not generated, instead got: `+JSON.stringify(ncb.messages,null,2));
  });

  // ERROR_FileTypeNotRecognized

  it('should generate ERROR_FileTypeNotRecognized if a file is not a recognized type', async function() {
    const ncb = new NodeCompilerCallbacks({logLevel: 'silent'});
    await unitTestEndpoints.build(makePathToFixture('invalid-keyboards', 'error_file_type_not_recognized.xxx'), ncb, {});
    assert.isTrue(ncb.hasMessage(InfrastructureMessages.ERROR_FileTypeNotRecognized),
      `ERROR_FileTypeNotRecognized not generated, instead got: `+JSON.stringify(ncb.messages,null,2));
  });

  // ERROR_OutFileNotValidForProjects

  it('should generate ERROR_OutFileNotValidForProjects if an output file is specified for a project build', async function() {
    const ncb = new NodeCompilerCallbacks({logLevel: 'silent'});
    const projectPath = makePathToFixture('kpj-2.0/khmer_angkor', 'khmer_angkor.kpj');
    const outFilePath = makePathToFixture('kpj-2.0/khmer_angkor', 'khmer_angkor.kmx');
    const options: CompilerOptions = {...defaultCompilerOptions, outFile: outFilePath};
    await unitTestEndpoints.build(projectPath, ncb, options);
    assert.isTrue(ncb.hasMessage(InfrastructureMessages.ERROR_OutFileNotValidForProjects),
      `ERROR_OutFileNotValidForProjects not generated, instead got: `+JSON.stringify(ncb.messages,null,2));
  });

  // ERROR_InvalidProjectFile

  it('should generate ERROR_InvalidProjectFile if a project file is invalid', async function() {
    const ncb = new NodeCompilerCallbacks({logLevel: 'silent'});
    await unitTestEndpoints.build(makePathToFixture('invalid-project', 'error_invalid_project_file.kpj'), ncb, {});
    assert.isTrue(ncb.hasMessage(InfrastructureMessages.ERROR_InvalidProjectFile),
      `ERROR_InvalidProjectFile not generated, instead got: `+JSON.stringify(ncb.messages,null,2));
  });

  // HINT_FilenameHasDifferingCase

  it('should generate HINT_FilenameHasDifferingCase if a referenced file has differing case', async function() {
    // This message is generated by NodeCompilerCallbacks, because that's where the filesystem is visible,
    // so we can't use our usual testForMessage pattern.
    const ncb = new NodeCompilerCallbacks({logLevel: 'silent'});
    ncb.loadFile(makePathToFixture('invalid-keyboards', 'Hint_Filename_Has_Differing_Case.kmn'));
    assert.isTrue(ncb.hasMessage(InfrastructureMessages.HINT_FilenameHasDifferingCase),
      `HINT_FilenameHasDifferingCase not generated, instead got: `+JSON.stringify(ncb.messages,null,2));
  });

  // INFO_WarningsHaveFailedBuild

  it('should generate INFO_WarningsHaveFailedBuild if only warnings failed the build', async function() {
    // NOTE: we can probably re-use this format for most other message tests in the future
    const ncb = new NodeCompilerCallbacks({logLevel: 'silent'});
    const filename = makePathToFixture('compiler-warnings-as-errors', 'keyboard.kmn');
    const expectedMessages = [
      InfrastructureMessages.INFO_BuildingFile,
      KmnCompilerMessages.WARN_HeaderStatementIsDeprecated,
      InfrastructureMessages.INFO_WarningsHaveFailedBuild,
      InfrastructureMessages.INFO_FileNotBuiltSuccessfully
    ];
    await unitTestEndpoints.build(filename, ncb, {compilerWarningsAsErrors: true});
    assert.deepEqual(ncb.messages.map(m => m.code), expectedMessages,
      `actual callbacks.messages:\n${JSON.stringify(ncb.messages,null,2)}\n\n`+
      `did not match expected:\n${JSON.stringify(expectedMessages,null,2)}\n\n`);
  });
});
