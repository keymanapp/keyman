import 'mocha';
import { assert } from 'chai';
import { InfrastructureMessages } from '../src/messages/messages.js';
import { verifyCompilerMessagesObject } from '@keymanapp/developer-test-helpers';
import { makePathToFixture } from './helpers/index.js';
import { NodeCompilerCallbacks } from '../src/messages/NodeCompilerCallbacks.js';
import { CompilerErrorNamespace } from '@keymanapp/common-types';

describe('InfrastructureMessages', function () {
  it('should have a valid InfrastructureMessages object', function() {
    return verifyCompilerMessagesObject(InfrastructureMessages, CompilerErrorNamespace.Infrastructure);
  });

  //
  // Message tests
  //

  /*
  TODO:

  let callbacks = new TestCompilerCallbacks();

  async function testForMessage(context: Mocha.Context, fixture: string[], messageId?: number) {
    context.timeout(10000);

    callbacks.clear();

    const builder = new BuildKmnKeyboard();
    const path = makePathToFixture(...fixture);
    let result = await builder.build(path, callbacks, {
      compilerVersion: false,
      compilerWarningsAsErrors: true,
      debug: false,
      warnDeprecatedCode: true,
    });

    if(messageId) {
      assert.isTrue(callbacks.hasMessage(messageId), `messageId ${messageId.toString(16)} not generated, instead got: `+JSON.stringify(callbacks.messages,null,2));
      assert.lengthOf(callbacks.messages, 1);
    } else {
      assert.lengthOf(callbacks.messages, 0, `messages should be empty, but instead got: `+JSON.stringify(callbacks.messages,null,2));
      assert.isTrue(result);
    }
  }

  // ERROR_FileDoesNotExist

  it('should generate ERROR_FileDoesNotExist if a file does not exist', async function() {
    await testForMessage(this, ['invalid-keyboards', 'error_file_does_not_exist.kmn'], CompilerMessages.ERROR_FileDoesNotExist);
  });

  // ERROR_FileTypeNotRecognized

  it('should generate ERROR_FileTypeNotRecognized if a file is not a recognized type', async function() {
    await testForMessage(this, ['invalid-keyboards', 'error_file_type_not_recognized.xxx'], CompilerMessages.ERROR_FileTypeNotRecognized);
  });

  // ERROR_OutFileNotValidForProjects

  it('should generate ERROR_OutFileNotValidForProjects if an output file is specified for a project build', async function() {
    await testForMessage(this, ['invalid-keyboards', 'error_out_file_not_valid_for_projects.kpj'], CompilerMessages.ERROR_OutFileNotValidForProjects);
  });

  // ERROR_InvalidProjectFile

  it('should generate ERROR_InvalidProjectFile if a project file is invalid', async function() {
    await testForMessage(this, ['invalid-keyboards', 'error_invalid_project_file.kpj'], CompilerMessages.ERROR_InvalidProjectFile);
  });
  */

  // HINT_FilenameHasDifferingCase

  it('should generate HINT_FilenameHasDifferingCase if a referenced file has differing case', async function() {
    // This message is generated by NodeCompilerCallbacks, because that's where the filesystem is visible,
    // so we can't use our usual testForMessage pattern.
    const ncb = new NodeCompilerCallbacks(true);
    ncb.loadFile(makePathToFixture('invalid-keyboards', 'Hint_Filename_Has_Differing_Case.kmn'));
    assert.isTrue(ncb.hasMessage(InfrastructureMessages.HINT_FilenameHasDifferingCase),
      `HINT_FilenameHasDifferingCase not generated, instead got: `+JSON.stringify(ncb.messages,null,2));
  });
});
